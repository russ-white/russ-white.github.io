"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeedleToktxContext = void 0;
const core_1 = require("@gltf-transform/core");
const extensions_1 = require("@gltf-transform/extensions");
const toktx_1 = require("./toktx");
const fs_1 = require("fs");
const functions_1 = require("@gltf-transform/functions");
const util_1 = require("./util");
const fs = require('fs/promises');
const os = require('os');
const tmp = require('tmp');
const pLimit = require('p-limit');
const NUM_CPUS = os.cpus().length || 1; // microsoft/vscode#112122
class NeedleToktxContext {
    limit;
    basisuExtension;
    version;
    tmpPathBase;
    document;
    env;
    numTextures;
    constructor(options) {
        this.limit = pLimit(options.jobs || NUM_CPUS);
        // allow overriding toktx installation location / adding additional search paths
        const isUsingWindows = process.platform === 'win32';
        if (isUsingWindows && options?.toktxPath) {
            this.env = { PATH: process.env.PATH + ";" + options.toktxPath };
        }
    }
    async prepare(document) {
        this.document = document;
        const logger = document.getLogger();
        this.version = await (0, toktx_1.checkKTXSoftware)(document.getLogger());
        logger.debug("toktx:version: " + this.version);
        this.basisuExtension = document.createExtension(extensions_1.TextureBasisu).setRequired(true);
        const tmpDir = `${tmp.tmpdir}/gltf-transform`;
        if (!((0, fs_1.existsSync)(tmpDir)))
            (0, fs_1.mkdirSync)(tmpDir);
        this.tmpPathBase = tmpDir + "/" + (0, core_1.uuid)();
        this.numTextures = document.getRoot().listTextures().length;
    }
    async process(index, texture, settings) {
        const task = async () => {
            const doc = this.document;
            const logger = doc.getLogger();
            const slots = (0, functions_1.listTextureSlots)(doc, texture);
            const channels = (0, functions_1.getTextureChannelMask)(doc, texture);
            const textureLabel = texture.getURI() ||
                texture.getName() ||
                `${index + 1}/${doc.getRoot().listTextures().length}`;
            const prefix = `toktx:texture(${textureLabel})`;
            if (slots.length > 0)
                logger.debug(`${prefix}: Slots → [${slots.join(', ')}]`);
            const image = texture.getImage();
            const size = texture.getSize();
            if (!image || !size) {
                logger.warn(`${prefix}: Skipping, unreadable texture.`);
                return;
            }
            const extension = texture.getURI()
                ? core_1.FileUtils.extension(texture.getURI())
                : core_1.ImageUtils.mimeTypeToExtension(texture.getMimeType());
            const tmpName = this.tmpPathBase + "_" + index;
            const inPath = tmpName + '.' + extension;
            const outPath = tmpName + '.ktx2';
            // const inBytes = image.byteLength;
            await fs.writeFile(inPath, Buffer.from(image));
            //@ts-ignore
            const defaults = settings.mode === "ETC1S" ? toktx_1.ETC1S_DEFAULTS : toktx_1.UASTC_DEFAULTS;
            defaults.mode = settings.mode === "ETC1S" ? toktx_1.Mode.ETC1S : toktx_1.Mode.UASTC;
            //@ts-ignore
            const toktxParams = (0, toktx_1.createParams)(slots, channels, size, logger, this.numTextures, { ...defaults }, this.version);
            const params = [
                ...toktxParams,
                outPath,
                inPath,
            ];
            logger.debug(`${prefix}: Spawning → toktx ${params.join(' ')}`);
            // COMPRESS: Run `toktx` CLI tool.
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const [status, stdout, stderr] = await (0, util_1.waitExit)((0, util_1.spawn)('toktx', params, { env: this.env }));
            if (status !== 0) {
                logger.error(`${prefix}: Failed → \n\n${stderr.toString()}`);
            }
            else {
                const result = await fs.readFile(outPath);
                texture.setImage(result).setMimeType('image/ktx2');
                return true;
            }
            return false;
        };
        return this.limit(task);
    }
    async finalize(document) {
        const usesKTX2 = document
            .getRoot()
            .listTextures()
            .some((t) => t.getMimeType() === 'image/ktx2');
        if (!usesKTX2) {
            this.basisuExtension?.dispose();
        }
    }
}
exports.NeedleToktxContext = NeedleToktxContext;
