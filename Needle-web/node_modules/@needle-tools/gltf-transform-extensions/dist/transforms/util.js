"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.underline = exports.formatXMP = exports.formatHeader = exports.formatParagraph = exports.formatBytes = exports.formatLong = exports._waitExit = exports.mockWaitExit = exports.mockCommandExists = exports.mockSpawn = exports.waitExit = exports.commandExists = exports.spawn = exports.MICROMATCH_OPTIONS = exports.XMPContext = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const { spawn: _spawn } = require('child_process');
const command_exists_1 = __importDefault(require("command-exists"));
// Constants.
exports.XMPContext = {
    dc: 'http://purl.org/dc/elements/1.1/',
    model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',
    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    xmp: 'http://ns.adobe.com/xap/1.0/',
    xmpRights: 'http://ns.adobe.com/xap/1.0/rights/',
};
// Using 'micromatch' because 'contains: true' did not work as expected with
// minimatch. Need to ensure that '*' matches patterns like 'image/png'.
exports.MICROMATCH_OPTIONS = { nocase: true, contains: true };
// Mocks for tests.
exports.spawn = _spawn;
// See https://github.com/mathisonian/command-exists/issues/22
let commandExists = (cmd) => (0, command_exists_1.default)(cmd)?.catch(() => false) ?? false;
exports.commandExists = commandExists;
exports.waitExit = _waitExit;
function mockSpawn(_spawn) {
    exports.spawn = _spawn;
}
exports.mockSpawn = mockSpawn;
function mockCommandExists(_commandExists) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    exports.commandExists = _commandExists;
}
exports.mockCommandExists = mockCommandExists;
function mockWaitExit(_waitExit) {
    exports.waitExit = _waitExit;
}
exports.mockWaitExit = mockWaitExit;
async function _waitExit(process) {
    let stdout = '';
    if (process.stdout) {
        for await (const chunk of process.stdout) {
            stdout += chunk;
        }
    }
    let stderr = '';
    if (process.stderr) {
        for await (const chunk of process.stderr) {
            stderr += chunk;
        }
    }
    const status = await new Promise((resolve, _) => {
        process.on('close', resolve);
    });
    return [status, stdout, stderr];
}
exports._waitExit = _waitExit;
// Formatting.
function formatLong(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
exports.formatLong = formatLong;
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0)
        return '0 Bytes';
    const k = 1000;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}
exports.formatBytes = formatBytes;
function formatParagraph(str) {
    return str
        .match(/.{1,80}(\s|$)/g)
        .map((line) => line.trim())
        .join('\n');
}
exports.formatParagraph = formatParagraph;
function formatHeader(title) {
    return '' + '\n ' + title.toUpperCase() + '\n ────────────────────────────────────────────';
}
exports.formatHeader = formatHeader;
function formatXMP(value) {
    if (!value) {
        return '';
    }
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        return value.toString();
    }
    if (value['@list']) {
        const list = value['@list'];
        const hasCommas = list.some((value) => value.indexOf(',') > 0);
        return list.join(hasCommas ? '; ' : ', ');
    }
    if (value['@type'] === 'rdf:Alt') {
        return value['rdf:_1']['@value'];
    }
    return JSON.stringify(value);
}
exports.formatXMP = formatXMP;
function underline(str) {
    return `\x1b[4m${str}\x1b[0m`;
}
exports.underline = underline;
