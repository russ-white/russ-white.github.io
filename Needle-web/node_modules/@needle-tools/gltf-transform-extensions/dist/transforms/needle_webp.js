"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeedleWebPContext = void 0;
const extensions_1 = require("@gltf-transform/extensions");
const squoosh_1 = require("./types/squoosh");
var Codec;
(function (Codec) {
    Codec["OXIPNG"] = "oxipng";
    Codec["MOZJPEG"] = "mozjpeg";
    Codec["WEBP"] = "webp";
})(Codec || (Codec = {}));
const CODEC_TO_MIME_TYPE = {
    [Codec.OXIPNG]: 'image/png',
    [Codec.MOZJPEG]: 'image/jpeg',
    [Codec.WEBP]: 'image/webp',
};
const defaultWebpCodecOptions = new squoosh_1.WebPEncoderOptions();
defaultWebpCodecOptions.quality = 90;
defaultWebpCodecOptions.filter_type = 0; // turn strong filter off
defaultWebpCodecOptions.use_sharp_yuv = 1; // use sharp rgb -> YUV conversion
class NeedleWebPContext {
    pool;
    options;
    logger;
    constructor(options) {
        this.options = options;
        this.pool = new options.squoosh.ImagePool(options.jobs);
    }
    async prepare(document) {
        this.logger = document.getLogger();
    }
    async process(index, texture, settings) {
        const encodingOptions = this.options.auto ? 'auto' : { ...defaultWebpCodecOptions };
        if (typeof encodingOptions !== "string" && settings.quality >= 0) {
            // the quality range is 0-1 so we remap to 0-100
            encodingOptions.quality = settings.quality * 100;
        }
        let logMessage = "Compress to webp â†’ image: " + index + ", ";
        if (typeof encodingOptions === "string")
            logMessage += " auto quality";
        else
            logMessage += " quality: " + encodingOptions.quality + ", strong filter: " + (encodingOptions.filter_type ? true : false) + ", sharpYUV: " + (encodingOptions.use_sharp_yuv ? true : false);
        this.logger.debug(logMessage);
        // COMPRESS: Run `squoosh/lib` library.
        const image = this.pool.ingestImage(texture.getImage());
        const codec = "webp";
        await image.encode({ [codec]: encodingOptions });
        const encodedImage = await image.encodedWith[codec];
        texture.setImage(encodedImage.binary).setMimeType(CODEC_TO_MIME_TYPE[codec]);
        return true;
    }
    async finalize(document) {
        await this.pool.close();
        const textures = document.getRoot().listTextures();
        if (textures.some((texture) => texture.getMimeType() === CODEC_TO_MIME_TYPE[Codec.WEBP])) {
            document.createExtension(extensions_1.TextureWebP).setRequired(true);
        }
    }
}
exports.NeedleWebPContext = NeedleWebPContext;
