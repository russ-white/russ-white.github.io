"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOpaqueExtension = void 0;
const core_1 = require("@gltf-transform/core");
const utils_1 = require("../utils");
const ALL_PROPERTY_TYPES = [];
for (const key in core_1.PropertyType) {
    ALL_PROPERTY_TYPES.push(core_1.PropertyType[key]);
}
// an opaque extension can be used to pass data through the gltf transform process
// it should also be able to re-write/fix json pointers after the transformation which might have shuffled them around 
function createOpaqueExtension(name, types, opts) {
    if (!Array.isArray(types))
        types = [types];
    const EXTENSION_NAME = name;
    const ExtensionPropertyTypes = ALL_PROPERTY_TYPES;
    const debugLog = opts?.debug ?? false;
    class NEEDLE_opaque extends core_1.Extension {
        extensionName = EXTENSION_NAME;
        static EXTENSION_NAME = EXTENSION_NAME;
        // private roots: Array<OpaqueProperty> = [];
        jsonPointerHandler;
        read(context) {
            if (debugLog)
                console.log("READ " + EXTENSION_NAME);
            this.jsonPointerHandler = new JsonPointerHandler(this.document, EXTENSION_NAME);
            this.jsonPointerHandler.debug = debugLog;
            for (const type of types) {
                switch (type) {
                    case core_1.PropertyType.ACCESSOR:
                        this.onRead(context, "accessors", "accessorIndexMap");
                        break;
                    case core_1.PropertyType.ANIMATION:
                        this.onRead(context, "animations", "animationIndexMap");
                        break;
                    case core_1.PropertyType.ANIMATION_CHANNEL:
                        if (EXTENSION_NAME === "KHR_animation_pointer") {
                            context.jsonDoc.json.animations?.forEach((animDef, animIndex) => {
                                animDef.channels?.forEach((channel, channelIndex) => {
                                    const jsonTarget = channel.target;
                                    const khr_animation = jsonTarget.extensions && jsonTarget.extensions[EXTENSION_NAME];
                                    if (!khr_animation)
                                        return;
                                    const anim = context.animations[animIndex];
                                    const existing = anim.getExtension(EXTENSION_NAME);
                                    if (debugLog)
                                        console.log(">>>", EXTENSION_NAME, "animation", animIndex, "channel", channelIndex, khr_animation);
                                    if (existing) {
                                        assignChannels(existing);
                                        return;
                                    }
                                    const prop = this.createExtension();
                                    // there seems no way (yet?) to add extensions to channel.targets (?) 
                                    // https://github.com/donmccurdy/glTF-Transform/discussions/613
                                    // so we add it to an object by keys to the animation itself and read it back in WRITE
                                    const khr_animation_data = {};
                                    khr_animation_data[channelIndex] = khr_animation;
                                    anim.setExtension(EXTENSION_NAME, prop);
                                    assignChannels(prop);
                                    function assignChannels(prop) {
                                        prop.add(ctx => {
                                            const animations = ctx.jsonDoc.json.animations;
                                            if (!animations)
                                                return;
                                            const animDef = animations[animIndex];
                                            const channel = animDef?.channels[channelIndex];
                                            if (channel) {
                                                if (debugLog)
                                                    console.log("<<<", EXTENSION_NAME, "animation", animIndex, "channel", channelIndex, khr_animation);
                                                channel.target = jsonTarget;
                                            }
                                            else if (debugLog)
                                                console.log("WARN: ", EXTENSION_NAME, "animation", animIndex, "channel", channelIndex, "not found");
                                        });
                                    }
                                    ;
                                });
                            });
                        }
                        break;
                    case core_1.PropertyType.ANIMATION_SAMPLER:
                        break;
                    case core_1.PropertyType.BUFFER:
                        this.onRead(context, "buffers", "bufferIndexMap");
                        break;
                    case core_1.PropertyType.CAMERA:
                        this.onRead(context, "cameras", "cameraIndexMap");
                        break;
                    case core_1.PropertyType.MATERIAL:
                        this.onRead(context, "materials", "materialIndexMap");
                        break;
                    case core_1.PropertyType.TEXTURE:
                        context.jsonDoc.json.textures?.forEach((textureDefinition, index) => {
                            if (!textureDefinition.extensions)
                                return;
                            const ext = textureDefinition.extensions[EXTENSION_NAME];
                            if (!ext)
                                return;
                            const texture = context.textures[index];
                            this.jsonPointerHandler.read(context, texture, ext);
                            const prop = this.createExtension();
                            texture.setExtension(EXTENSION_NAME, prop);
                            const handler = new TextureHandler(this.document, textureDefinition, EXTENSION_NAME, ext, debugLog);
                            prop.add(handler);
                        });
                        break;
                    case core_1.PropertyType.NODE:
                        this.onRead(context, "nodes", "nodeIndexMap");
                        break;
                    case core_1.PropertyType.MESH:
                        this.onRead(context, "meshes", "meshIndexMap");
                        break;
                    case core_1.PropertyType.PRIMITIVE:
                        context.jsonDoc.json.meshes?.forEach((meshDefinition, meshIndex) => {
                            const mesh = context.meshes[meshIndex];
                            const primitives = mesh.listPrimitives();
                            meshDefinition.primitives?.forEach((primitiveDefinition, primitiveIndex) => {
                                if (!primitiveDefinition.extensions)
                                    return;
                                const ext = primitiveDefinition.extensions[EXTENSION_NAME];
                                if (!ext)
                                    return;
                                const primitive = primitives[primitiveIndex];
                                this.jsonPointerHandler.read(context, primitive, ext);
                                const prop = this.createExtension();
                                primitive.setExtension(EXTENSION_NAME, prop);
                                // this is invoked on write
                                prop.add(ctx => {
                                    const newMeshIndex = ctx.meshIndexMap.get(mesh);
                                    const newMesh = ctx.jsonDoc.json.meshes[newMeshIndex];
                                    const newPrimitive = newMesh.primitives[primitiveIndex];
                                    newPrimitive.extensions = newPrimitive.extensions || {};
                                    newPrimitive.extensions[EXTENSION_NAME] = ext;
                                });
                            });
                        });
                        break;
                    case core_1.PropertyType.ROOT:
                        const sourceArray = context.jsonDoc.json.extensions;
                        if (!sourceArray)
                            continue;
                        const ext = sourceArray[EXTENSION_NAME];
                        if (ext) {
                            this.lightmapWorkaround(context);
                            const root = this.document.getRoot();
                            this.jsonPointerHandler.read(context, root, ext);
                            const prop = this.createExtension();
                            root.setExtension(EXTENSION_NAME, prop);
                            prop.add(ctx => {
                                ctx.jsonDoc.json.extensions = ctx.jsonDoc.json.extensions || {};
                                ctx.jsonDoc.json.extensions[EXTENSION_NAME] = ext;
                            });
                        }
                        break;
                }
            }
            return this;
        }
        // this is temporarely here to prevent compression on textures named Lightmap
        // until we have better control over the compression process
        lightmapWorkaround(context) {
            const textureDefinitions = context.jsonDoc.json.textures;
            if (!textureDefinitions)
                return;
            const textures = this.document.getRoot().listTextures();
            for (let i = 0; i < textures.length; i++) {
                const tex = textures[i];
                const texDef = textureDefinitions[i];
                const name = texDef?.name;
                if (name?.startsWith("Lightmap") && tex.getMimeType() !== "image/exr") {
                    if (debugLog)
                        console.log("Found lightmap texture", name, tex.getMimeType(), EXTENSION_NAME);
                    tex.setMimeType("image/lightmap");
                }
            }
        }
        createExtension(name = '') {
            return new OpaqueProperty(this.document.getGraph(), name);
        }
        onRead(context, gltfField, map) {
            if (gltfField === undefined)
                return;
            try {
                const sourceArray = context.jsonDoc.json[gltfField];
                const target = context[gltfField];
                sourceArray?.forEach((def, index) => {
                    if (!def.extensions || !def.extensions[EXTENSION_NAME])
                        return;
                    const ext = def.extensions[EXTENSION_NAME];
                    if (debugLog)
                        console.log("READ", index, ext);
                    const prop = this.createExtension();
                    // attach the property
                    target[index].setExtension(EXTENSION_NAME, prop);
                    // capture all the json pointers in the extension
                    this.jsonPointerHandler.read(context, target[index], ext);
                    // make sure we write our extension back to the gltf
                    prop.add(new OpaqueWriter(map, gltfField, ext));
                });
            }
            catch (error) {
                console.error("ERR: " + error);
            }
        }
        write(context) {
            if (opts?.write === false) {
                return this;
            }
            if (debugLog)
                console.log("WRITE " + EXTENSION_NAME);
            this.jsonPointerHandler.resolveAndWrite(context);
            const root = this.document.getRoot();
            // for (const rootExt of this.roots) {
            //     rootExt.onWrite(context, root);
            // }
            for (const type of types) {
                switch (type) {
                    case core_1.PropertyType.ACCESSOR:
                        this.onWrite(context, () => root.listAccessors());
                        break;
                    case core_1.PropertyType.ANIMATION:
                        this.onWrite(context, () => root.listAnimations());
                        break;
                    case core_1.PropertyType.ANIMATION_CHANNEL:
                        break;
                    case core_1.PropertyType.ANIMATION_SAMPLER:
                        break;
                    case core_1.PropertyType.BUFFER:
                        this.onWrite(context, () => root.listBuffers());
                        break;
                    case core_1.PropertyType.CAMERA:
                        this.onWrite(context, () => root.listCameras());
                        break;
                    case core_1.PropertyType.MATERIAL:
                        this.onWrite(context, () => root.listMaterials());
                        break;
                    case core_1.PropertyType.TEXTURE:
                        this.onWrite(context, () => root.listTextures());
                        break;
                    case core_1.PropertyType.NODE:
                        this.onWrite(context, () => root.listNodes());
                        break;
                    case core_1.PropertyType.MESH:
                        this.onWrite(context, () => root.listMeshes());
                        break;
                    case core_1.PropertyType.PRIMITIVE:
                        const allPrimitives = root.listMeshes().flatMap(mesh => mesh.listPrimitives());
                        for (const primitive of allPrimitives) {
                            const ext = primitive.getExtension(EXTENSION_NAME);
                            if (ext instanceof OpaqueProperty) {
                                ext.onWrite(context, primitive);
                            }
                        }
                        break;
                    case core_1.PropertyType.ROOT:
                        const prop = root.getExtension(EXTENSION_NAME);
                        if (prop instanceof OpaqueProperty) {
                            prop.onWrite(context, root);
                        }
                        break;
                }
            }
            return this;
        }
        onWrite(context, get) {
            const arr = get();
            if (!arr)
                return;
            for (const entry of arr) {
                const ext = entry.getExtension(EXTENSION_NAME);
                if (ext instanceof OpaqueProperty) {
                    ext.onWrite(context, entry);
                }
            }
            ;
        }
    }
    class OpaqueProperty extends core_1.ExtensionProperty {
        static EXTENSION_NAME = EXTENSION_NAME;
        extensionName = EXTENSION_NAME;
        parentTypes = ExtensionPropertyTypes;
        propertyType = "NEEDLE_opaque_property";
        init() { }
        writers = [];
        add(writer) {
            if (typeof writer === "function") {
                writer = new GenericWriter(writer);
            }
            this.writers.push(writer);
        }
        onWrite(context, prop) {
            for (const writer of this.writers) {
                writer.write?.call(writer, context, prop);
            }
        }
        getExtensionDefinition() {
            const ext = {};
            for (const writer of this.writers) {
                if (writer.assignTo)
                    writer.assignTo(ext);
            }
            return ext;
        }
    }
    // called after the transformation
    // writes the extension json back to the correct object
    class OpaqueWriter {
        map;
        gltfField;
        ext;
        assignTo(obj) {
            Object.assign(obj, this.ext);
        }
        constructor(map, gltfField, ext) {
            this.map = map;
            this.gltfField = gltfField;
            this.ext = ext;
        }
        write(context, prop) {
            if (prop && this.gltfField !== undefined) {
                const map = context[this.map];
                const index = map.get(prop);
                const result = (0, utils_1.tryGetInArray)(context.jsonDoc.json[this.gltfField], index);
                (0, utils_1.writeExtension)(result, EXTENSION_NAME, this.ext);
                if (debugLog) {
                    // console.log("WRITE", EXTENSION_NAME, "to", this.gltfField, "at index", index);
                    console.log(result);
                }
            }
        }
    }
    return NEEDLE_opaque;
}
exports.createOpaqueExtension = createOpaqueExtension;
/** use to register a generic callback */
class GenericWriter {
    fn;
    constructor(fn) {
        this.fn = fn;
    }
    write(ctx) {
        this.fn(ctx);
    }
}
class TextureHandler {
    document;
    textureDefinition;
    index;
    key;
    ext;
    debug = false;
    assignTo(obj) {
        Object.assign(obj, this.ext);
    }
    constructor(doc, def, key, ext, debug) {
        this.document = doc;
        this.textureDefinition = def;
        this.key = key;
        this.ext = ext;
        this.debug = debug;
        this.index = this.tryGetSourceIndex(this.textureDefinition);
        if (debug)
            console.log(def);
    }
    write(ctx) {
        let foundTexture = false;
        const textureDefs = ctx.jsonDoc.json.textures || [];
        const imageIndex = this.index !== undefined ? this.index : this.tryGetSourceIndex(this.textureDefinition);
        if (imageIndex === undefined) {
            console.warn("WARN: no source index found for texture", this.key);
        }
        textureDefs?.forEach((textureDef, i) => {
            if (foundTexture)
                return;
            const textureImageIndex = this.tryGetSourceIndex(textureDef);
            if (imageIndex === textureImageIndex) {
                if (!textureDef.extensions || !textureDef.extensions[this.key]) {
                    // assign texture extension again
                    textureDef.extensions = textureDef.extensions || {};
                    foundTexture = true;
                    if (this.debug)
                        console.log("Re-Assign extension:", this.key, "at", i);
                    const newExt = { ...this.ext };
                    if (newExt.source !== undefined)
                        newExt.source = imageIndex;
                    textureDef.extensions[this.key] = newExt;
                }
            }
        });
        if (foundTexture === false) {
            console.warn("WARN: failed to re-assign extension:", this.key, this.index, this.tryGetSourceIndex(this.textureDefinition), textureDefs.length);
        }
        // this.document
        //     .getRoot()
        //     .listTextures()
        //     .forEach((texture, index) => {
        //         if (foundTexture) return;
        //         if (!texture.getExtension(this.key)) return;
        //         const imageIndex = ctx.imageIndexMap.get(texture);
        //     });
    }
    tryGetSourceIndex(def) {
        let index = def.source;
        if (index !== undefined)
            return index;
        // if a glb was already compressed the source index might be missing so we also need to search in extensions
        if (def.extensions) {
            for (const ext of Object.keys(def.extensions)) {
                const extDef = def.extensions[ext];
                if (extDef.source !== undefined) {
                    index = extDef.source;
                    break;
                }
            }
        }
        return index;
    }
}
// declare type MaterialTextureCallback = (ctx: WriterContext, map: TemporaryMaterial, index: number) => void;
// class TemporaryMaterial implements IExtensionWriter {
//     private readonly document: Document;
//     private readonly material: Material;
//     private readonly tex: Texture;
//     private readonly callbacks: MaterialTextureCallback[] = [];
//     constructor(doc: Document, tex: Texture, name: string) {
//         console.log("Create material", name);
//         this.document = doc;
//         this.tex = tex;
//         this.material = this.document
//             .createMaterial(name)
//             .setBaseColorTexture(tex);
//     }
//     add(cb: MaterialTextureCallback): TemporaryMaterial {
//         this.callbacks.push(cb);
//         return this;
//     }
//     write(context: WriterContext): void {
//         const matIndex = context.materialIndexMap.get(this.material);
//         if (matIndex !== undefined && matIndex !== -1) {
//             console.log("Remove material", this.material.getName(), matIndex);
//             context.jsonDoc.json.materials?.splice(matIndex, 1);
//             if (this.callbacks.length > 0) {
//                 const texInfo = this.material.getBaseColorTextureInfo();
//                 if (texInfo) {
//                     const def = context.textureInfoDefMap.get(texInfo);
//                     if (def) {
//                         const index = def.index;
//                         for (const cb of this.callbacks) {
//                             cb(context, this, index);
//                         }
//                     }
//                 }
//             }
//         }
//     }
// }
// json pointer -------------------------------------------------------------
// abstract class PointerProperty extends ExtensionProperty {
//     abstract setPointer(texture: Texture, name: string);
// }
// const { R, G, B, A } = TextureChannel;
// function createPointerProperty(EXTENSION_NAME: string, doc: Document): PointerProperty {
//     class TexturePointerPointerProperty extends ExtensionProperty<any> {
//         static EXTENSION_NAME = EXTENSION_NAME;
//         readonly extensionName: string = EXTENSION_NAME;
//         parentTypes: PropertyType[] = ALL_PROPERTY_TYPES;
//         propertyType = "NEEDLE_pointer_property";
//         init() { }
//         public setPointer(texture: Texture | null, name: string): this {
//             console.log("SET REF", name);
//             return this.setRef(name, texture, { channels: R | G | B | A });
//         }
//     }
//     return new TexturePointerPointerProperty(doc.getGraph());
// }
class JsonPointerHandler {
    id;
    document;
    map = new Map();
    debug = false;
    constructor(document, id) {
        this.document = document;
        this.id = id;
    }
    read(context, prop, obj, key, fullPath) {
        const value = key !== undefined ? obj[key] : obj;
        // the pointer path contains the full path from the root object to the json pointer
        if (key !== undefined) {
            fullPath ??= "";
            fullPath += "/" + key;
        }
        switch (typeof value) {
            case 'object':
                if (value !== null && value !== undefined) {
                    for (const key of Object.keys(value)) {
                        this.read(context, prop, value, key, fullPath);
                    }
                }
                break;
            case "string":
                if (value && key) {
                    if (value.startsWith("/textures/")) {
                        let pointer = this.map.get(value);
                        if (!pointer) {
                            const length = "/textures/".length;
                            const index = parseInt(value.substring(length));
                            const path = value.substring(0, length);
                            const definition = context.jsonDoc.json.textures[index];
                            const imageIndex = findSource(definition);
                            // console.log("Texture index", index, imageIndex, context.jsonDoc.json.textures.length, "Textures:" + context.textures.length)
                            const object = (0, utils_1.tryGetInArray)(context.textures, imageIndex);
                            if (object) {
                                const res = new TexturePointerResolver(this.document, object, definition);
                                res.init(context); // < init here otherwise the fields defined in the TexturePointer will be undefined (this caused e.g. finding the previous texture filter to fail)
                                pointer = new JsonPointer(path, res);
                                pointer.debug = this.debug;
                                this.map.set(value, pointer);
                            }
                            else {
                                console.warn("Texture not found", fullPath, value);
                            }
                        }
                        if (pointer) {
                            if (this.debug)
                                console.log("> Register pointer", this.id + "/" + fullPath + " : " + value);
                            pointer?.register(obj, key);
                        }
                        else
                            console.warn("WARN: failed registering pointer", fullPath, value);
                    }
                }
                break;
        }
    }
    resolveAndWrite(context) {
        this.map?.forEach(ptr => {
            ptr.resolve(context);
            ptr.write();
        });
    }
}
class JsonPointer {
    debug = false;
    resolver;
    pointerBase;
    constructor(pointerBase, resolver) {
        this.pointerBase = pointerBase;
        this.resolver = resolver;
    }
    _objects = [];
    _props = [];
    register(obj, prop) {
        this._objects.push(obj);
        this._props.push(prop);
    }
    newPointer;
    resolve(context) {
        //@ts-ignore
        this.resolver.debug = this.debug;
        const index = this.resolver.resolve(context);
        this.newPointer = this.pointerBase + index;
        if (this.debug)
            console.log("RESOLVED", this.newPointer);
    }
    write() {
        for (let i = 0; i < this._objects.length; i++) {
            const obj = this._objects[i];
            const prop = this._props[i];
            if (this.debug)
                console.log("< Resolved pointer", this.newPointer, "in", prop);
            obj[prop] = this.newPointer;
        }
    }
}
class PointerResolver {
    document;
    /* the object originally being referenced by the pointer */
    inputObject;
    /* the original json definition */
    inputDefinition;
    constructor(doc, obj, def) {
        this.document = doc;
        this.inputObject = obj;
        this.inputDefinition = def;
    }
    debug = false;
}
class TexturePointerResolver extends PointerResolver {
    _debugName;
    _samplerDef;
    init(context) {
        this._debugName = this.inputDefinition.name ?? this.inputDefinition.source?.toString() ?? "unknown";
        const samplerIndex = this.inputDefinition.sampler;
        if (samplerIndex !== undefined) {
            this._samplerDef = context.jsonDoc.json.samplers[samplerIndex];
        }
        if (this.debug)
            console.log(this._debugName, this._samplerDef);
    }
    resolve(context) {
        const imgIndex = context.imageIndexMap.get(this.inputObject);
        if (imgIndex === undefined) {
            console.error("ERR: image is missing", imgIndex);
            return -1;
        }
        // ensure we have a texture array
        context.jsonDoc.json.textures = context.jsonDoc.json.textures || [];
        // try find the texture that points to the same image source
        for (let i = 0; i < context.jsonDoc.json.textures.length; i++) {
            const textureDef = context.jsonDoc.json.textures[i];
            if (findSource(textureDef) === imgIndex) {
                if (textureDef.sampler === undefined) {
                    textureDef.sampler = this.findOrCreateSampler(context.jsonDoc.json);
                }
                if (this.debug)
                    console.log("Found texture def at " + i, "using image", imgIndex, textureDef);
                return i;
            }
        }
        // the texture was not found - add it
        // create a new texture def entry
        if (this.debug)
            console.log("Creating new texture", this._debugName);
        const hasExtensionWithSource = this.inputDefinition.extensions && Object.keys(this.inputDefinition.extensions).some(key => this.inputDefinition.extensions[key]["source"] !== undefined);
        const textureDef = {
            source: hasExtensionWithSource ? undefined : imgIndex,
            sampler: this.findOrCreateSampler(context.jsonDoc.json),
            extensions: this.inputDefinition.extensions,
            extras: this.inputDefinition.extras,
        };
        context.jsonDoc.json.textures.push(textureDef);
        return context.jsonDoc.json.textures.length - 1;
    }
    findOrCreateSampler(json) {
        json.samplers = json.samplers || [];
        if (this._samplerDef === undefined) {
            console.log("WARN: Creating default sampler", this._debugName);
            // create a default sampler
            this._samplerDef = {
                magFilter: 9729,
                minFilter: 9729,
                wrapS: 33648,
                wrapT: 33648
            };
        }
        else {
            for (let i = 0; i < json.samplers.length; i++) {
                const sampler = json.samplers[i];
                if (sampler.minFilter === this._samplerDef.minFilter &&
                    sampler.magFilter === this._samplerDef.magFilter &&
                    sampler.wrapS === this._samplerDef.wrapS &&
                    sampler.wrapT === this._samplerDef.wrapT) {
                    return i;
                }
            }
        }
        // append previous sampler
        json.samplers.push(this._samplerDef);
        return json.samplers.length - 1;
    }
}
function findSource(texDef) {
    if (texDef.source !== undefined) {
        return texDef.source;
    }
    if (texDef.extensions) {
        const keys = Object.keys(texDef.extensions);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const ext = texDef.extensions[key];
            if (ext["source"] !== undefined) {
                return ext["source"];
            }
        }
    }
    return undefined;
}
