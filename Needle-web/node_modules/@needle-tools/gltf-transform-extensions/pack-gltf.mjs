import glob from 'glob';
import path from 'path';
import { NodeIO, PropertyType } from '@gltf-transform/core';
import { ALL_EXTENSIONS } from '@gltf-transform/extensions';
import { draco, webp } from '@gltf-transform/functions';
import draco3d from 'draco3dgltf';
import { ALL_EXTENSIONS as NEEDLE_EXTENSIONS } from "./dist/extensions/NEEDLE_opaque/index.js";
import commandLineArgs from "command-line-args";
import { NEEDLE_mesh_compression, NEEDLE_compression_texture } from './dist/extensions/index.js';
import { needle_simplify } from "./dist/transforms/needle_simplify.js";
import { needle_texture_transform } from "./dist/transforms/needle_texture_transform.js";
import { existsSync, fstat, readdirSync, statSync } from 'fs';

const args = process.argv;

const optionDefinitions = [
    { name: 'debug', type: Boolean },
    { name: 'toktxPath', type: String, multiple: true },
    { name: 'file', type: String, multiple: true },
];
let options = undefined;
try {
    options = commandLineArgs(optionDefinitions);
}
catch (err) {
    console.log("Failed parsing commandline args:", err.message);
    options = {
        file: [...process.argv],
        debug: args?.includes("debug"),
    };
    for (const arg of args) {
        if (arg.includes("KTX-Software")) {
            options.toktxPath = [arg];
            break;
        }
    }
}

const toktxPaths = options?.toktxPath?.join(";");
if (!toktxPaths) {
    console.log("You can define a toktx search path by adding --toktxPath <path> to the command line. The command may appear multiple times");
}
else console.log("Toktx path at " + toktxPaths);

// console.log(args);
const debug = options?.debug ?? false;
console.log("Debug", debug);
if (debug)
    console.log(options);

let allowCaching = true;
if (args.includes("no-caching")) {
    console.log("Caching is disabled")
    allowCaching = false;
}
else console.log("Caching is enabled, use \"no-caching\" to disable it")


async function packFile(file) {
    const io = new NodeIO()
        .registerExtensions(ALL_EXTENSIONS)
        .registerExtensions(NEEDLE_EXTENSIONS)
        .registerExtensions([
            NEEDLE_compression_texture,
            NEEDLE_mesh_compression,
        ])
        .registerDependencies({
            'draco3d.decoder': await draco3d.createDecoderModule(),
            'draco3d.encoder': await draco3d.createEncoderModule(),
        });

    console.log("now packing: " + file);
    const startTime = Date.now();
    const document = await io.read(file);
    document.getLogger().verbosity = 0;
    // document.createExtension(NEEDLE_gameobject_data);
    await document.transform(
        // Remove duplicate vertex or texture data, if any.
        // dedup(),

        needle_texture_transform({
            useCache: allowCaching,
        }),

        needle_simplify({ ratio: 0.75, error: 0.001 }),

        // see https://github.com/donmccurdy/glTF-Transform/blob/main/packages/cli/src/transforms/draco.ts
        draco(),
    );

    // let filename = path.dirname(file) + "/" + path.basename(file) + ".etc1s+draco" + path.extname(file);
    if (debug) file += ".debugPacking.glb";
    const prevSize = statSync(file).size;
    await io.write(file, document);
    const duration = Date.now() - startTime;
    const sizeInBytes = statSync(file).size;
    console.log(`Compressing done in ${(duration / 1000).toFixed(1)} sec, ${(prevSize / 1024 / 1024).toFixed(1)} MB â†’ ${(sizeInBytes / 1024 / 1024).toFixed(1)} MB: ${file}`);
}





const defaultPath = "dist/assets";
const filesToIgnore = ["TrongCom Website.glb", "OldMacDonald Website.glb"]
let dir = defaultPath;

if (options.file?.length > 0) {
    options?.file?.forEach(async file => {
        // if the path is glb
        // file = file.replace('^', '');
        if (file.endsWith(".glb") || file.endsWith(".gltf")) {
            console.log("use passed in path: " + file);
            dir = null;
            await packFile(file);
            return;
        }
        // is directory?
        if (existsSync(file)) {
            const isDir = statSync(file).isDirectory();
            if (isDir) {
                const dir = file;
                const files = readdirSync(dir);
                for (const f of files) {
                    if (f.endsWith(".glb") || f.endsWith(".gltf")) {
                        if (debug && f.includes(".debugPacking")) return;
                        await packFile(path.join(dir, f));
                    }
                }
            }
        }
    });
}

const basePath = process.env.INIT_CWD;
if (basePath && dir) {
    console.log("Prefix basepath: " + basePath);
    dir = path.join(basePath, dir);
}

if (dir !== null && dir !== undefined) {
    glob(dir + "/*.glb", {}, async (err, files) => {
        console.log("GLB files in " + dir + ":", files);
        for (let file of files) {
            if (file.endsWith("_resources.glb")) {
                console.log("skip packing: " + file);
                continue;
            }
            if (filesToIgnore.includes(path.basename(file))) {
                // TODO: remove this hack once the opaque extensions dont break glbs that are already packed with custom extensions
                console.log("HACK: Ignoring glb because it's explicitly configured: " + file);
                continue;
            }
            if (debug && file.includes(".debugPacking")) continue;
            await packFile(file);
        }
    });

}
