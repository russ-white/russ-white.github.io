import { Context } from "./engine_setup";
import { Animator } from '../engine-components/Animator';
import { Animation } from '../engine-components/Animation';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
// import * as object from "./engine_gltf_builtin_components";
import * as loaders from "./engine_loaders";
import * as utils from "./engine_utils";
import { registerComponentExtension, registerExtensions } from "./extensions/extensions";
import { getLoader, registerLoader } from "./engine_gltf";
import { createBuiltinComponents, writeBuiltinComponentData } from "./engine_gltf_builtin_components";
import { addNewComponent, getComponentInChildren } from "./engine_components";
export class NeedleGltfLoader {
    createBuiltinComponents(context, gltfId, gltf, seed, extension) {
        return createBuiltinComponents(context, gltfId, gltf, seed, extension);
    }
    writeBuiltinComponentData(comp, context) {
        return writeBuiltinComponentData(comp, context);
    }
    parseSync(context, data, path, seed) {
        return parseSync(context, data, path, seed);
    }
    loadSync(context, url, seed, _allowAddingAnimator, prog) {
        return loadSync(context, url, seed, _allowAddingAnimator, prog);
    }
}
registerLoader(NeedleGltfLoader);
const printGltf = utils.getParam("printGltf");
// const loader = new GLTFLoader();
// registerExtensions(loader);
export var GltfLoadEventType;
(function (GltfLoadEventType) {
    GltfLoadEventType[GltfLoadEventType["BeforeLoad"] = 0] = "BeforeLoad";
    GltfLoadEventType[GltfLoadEventType["AfterLoaded"] = 1] = "AfterLoaded";
    GltfLoadEventType[GltfLoadEventType["FinishedSetup"] = 10] = "FinishedSetup";
})(GltfLoadEventType || (GltfLoadEventType = {}));
export class GltfLoadEvent {
    context;
    loader;
    path;
    gltf;
    constructor(context, path, loader, gltf) {
        this.context = context;
        this.path = path;
        this.loader = loader;
        this.gltf = gltf;
    }
}
const eventListeners = {};
export function addGltfLoadEventListener(type, listener) {
    eventListeners[type] = eventListeners[type] || [];
    eventListeners[type].push(listener);
}
export function removeGltfLoadEventListener(type, listener) {
    if (eventListeners[type]) {
        const index = eventListeners[type].indexOf(listener);
        if (index >= 0) {
            eventListeners[type].splice(index, 1);
        }
    }
}
function invokeEvents(type, event) {
    if (eventListeners[type]) {
        for (const listener of eventListeners[type]) {
            listener(event);
        }
    }
}
async function handleLoadedGltf(context, gltfId, gltf, seed, componentsExtension) {
    if (printGltf)
        console.log(gltf);
    await context.assets.registerGltf(gltf);
    await getLoader().createBuiltinComponents(context, gltfId, gltf, seed, componentsExtension);
    // load and assign animation
    // we still need this for Animation component
    // findAnimationsLate(context, gltf, context.new_scripts_pre_setup_callbacks, false);
}
export function parseSync(context, data, path, seed) {
    if (typeof path !== "string") {
        console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", path, typeof path);
    }
    const loader = new GLTFLoader();
    const sourceId = path;
    registerExtensions(loader, context, sourceId);
    const componentsExtension = registerComponentExtension(loader);
    return new Promise((resolve, reject) => {
        try {
            loaders.addDracoAndKTX2Loaders(loader, context);
            invokeEvents(GltfLoadEventType.BeforeLoad, new GltfLoadEvent(context, path, loader));
            loader.parse(data, path, async (data) => {
                invokeEvents(GltfLoadEventType.AfterLoaded, new GltfLoadEvent(context, path, loader, data));
                await handleLoadedGltf(context, path, data, seed, componentsExtension);
                invokeEvents(GltfLoadEventType.FinishedSetup, new GltfLoadEvent(context, path, loader, data));
                resolve(data);
            }, err => {
                console.error("failed loading " + path, err);
                resolve(undefined);
            });
        }
        catch (err) {
            console.error(err);
            reject(err);
        }
    });
}
export function loadSync(context, url, seed, _allowAddingAnimator = false, prog) {
    // better to create new loaders every time
    // (maybe we can cache them...)
    // but due to the async nature and potentially triggering multiple loads at the same time
    // we need to make sure the extensions dont override each other
    // creating new loaders should not be expensive as well
    const loader = new GLTFLoader();
    const sourceId = url;
    registerExtensions(loader, context, sourceId);
    const componentsExtension = registerComponentExtension(loader);
    return new Promise((resolve, reject) => {
        try {
            loaders.addDracoAndKTX2Loaders(loader, context);
            invokeEvents(GltfLoadEventType.BeforeLoad, new GltfLoadEvent(context, url, loader));
            loader.load(url, async (data) => {
                invokeEvents(GltfLoadEventType.AfterLoaded, new GltfLoadEvent(context, url, loader, data));
                await handleLoadedGltf(context, url, data, seed, componentsExtension);
                invokeEvents(GltfLoadEventType.FinishedSetup, new GltfLoadEvent(context, url, loader, data));
                resolve(data);
            }, evt => {
                prog?.call(loader, evt);
            }, err => {
                console.error("failed loading " + url, err);
                resolve(undefined);
            });
        }
        catch (err) {
            console.error(err);
            reject(err);
        }
    });
}
export function findAnimationsLate(_context, gltf, callbackarray, allowAddingAnimator = false) {
    if (gltf && gltf.animations && gltf.animations.length > 0) {
        callbackarray.push(() => {
            // console.trace("callback", gltf);
            findAnimations(gltf, allowAddingAnimator);
        });
    }
}
export function findAnimations(gltf, allowAddingAnimator = false) {
    // console.log(gltf);
    if (!gltf || !gltf.animations || !gltf.scene)
        return;
    if (!allowAddingAnimator) {
        // we only need to search if any animation component is in the scene
        // otherwise if we dont add anything there is no reason to search and log anything
        if (!getComponentInChildren(gltf.scene, Animation))
            return;
    }
    for (let i = 0; i < gltf.animations.length; i++) {
        const animation = gltf.animations[i];
        if (!animation.tracks || animation.tracks.length <= 0)
            continue;
        for (const t in animation.tracks) {
            const track = animation.tracks[t];
            const objectName = track["__objectName"] ?? track.name.substring(0, track.name.indexOf("."));
            const obj = gltf.scene.getObjectByName(objectName);
            if (!obj) {
                // console.warn("could not find " + objectName, animation, gltf.scene);
                continue;
            }
            let animationComponent = findAnimationGameObjectInParent(obj);
            if (!animationComponent) {
                if (allowAddingAnimator)
                    animationComponent = addNewComponent(gltf.scene, new Animation());
                else {
                    console.warn("Failed finding animator for", track.name, objectName);
                    continue;
                }
            }
            const animations = animationComponent.animations = animationComponent.animations || [];
            animation["name_animator"] = animationComponent.name;
            // console.log(objectName, obj, animator.name, animations.length);
            if (animations.indexOf(animation) < 0) {
                animations.push(animation);
            }
        }
    }
    function findAnimationGameObjectInParent(obj) {
        if (!obj)
            return;
        const components = obj.userData?.components;
        if (components && components.length > 0) {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                // console.log(component);
                if (component instanceof Animator || component instanceof Animation) {
                    return obj;
                    ;
                }
            }
        }
        return findAnimationGameObjectInParent(obj.parent);
    }
}
// TODO: save references in guid map
// const guidMap = {};
export function tryFindObjectByName(name, obj, recursive = true) {
    if (obj.userData && obj.userData.name === name)
        return obj;
    if (obj.children && obj.children.length > 0) {
        for (let i = 0; i < obj.children.length; i++) {
            const child = obj.children[i];
            const found = tryFindObjectByName(name, child, recursive);
            if (found)
                return found;
        }
    }
}
// obj can be a three.object or a gltf root
export function tryFindObject(globalObjectIdentifier, obj, recursive = true) {
    return utils.tryFindObject(globalObjectIdentifier, obj, recursive);
}
export function tryFindScript(globalObjectIdentifier, list = null) {
    const arr = list ?? Context.Current.scripts;
    for (const i in arr) {
        const script = arr[i];
        if (script && script.guid === globalObjectIdentifier)
            return script;
    }
    return null;
}
//# sourceMappingURL=engine_scenetools.js.map