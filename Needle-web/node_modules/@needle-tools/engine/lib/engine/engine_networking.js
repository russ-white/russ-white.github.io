// import geckos, { ClientChannel, Data } from '@geckos.io/client';
// const serverUrl = 'wss://tiny-server-1-r26roub2hq-ew.a.run.app/';
let serverUrl = 'wss://needle-tiny-starter.glitch.me/socket';
import { WebsocketBuilder } from 'websocket-ts';
import * as utils from "./engine_utils";
import * as flatbuffers from 'flatbuffers';
import * as schemes from "../engine-schemes/schemes";
import { PeerNetworking } from './engine_networking_peer';
import { SendQueue } from './engine_networking_types';
import { isHostedOnGlitch } from './engine_networking_utils';
export const debugNet = utils.getParam("debugnet") ? true : false;
export const debugOwner = debugNet || utils.getParam("debugowner") ? true : false;
export var ConnectionEvents;
(function (ConnectionEvents) {
    ConnectionEvents["ConnectionInfo"] = "connection-start-info";
})(ConnectionEvents || (ConnectionEvents = {}));
export var RoomEvents;
(function (RoomEvents) {
    RoomEvents["Join"] = "join-room";
    RoomEvents["Leave"] = "leave-room";
    RoomEvents["JoinedRoom"] = "joined-room";
    RoomEvents["LeftRoom"] = "left-room";
    RoomEvents["UserJoinedRoom"] = "user-joined-room";
    RoomEvents["UserLeftRoom"] = "user-left-room";
})(RoomEvents || (RoomEvents = {}));
export class JoinedRoomResponse {
    room; // room name
    viewId;
    allowEditing;
    inRoom; // connection ids
}
export class LeftRoomResponse {
    room; // room name
}
export class UserJoinedOrLeftRoomModel {
    userId;
}
export var OwnershipEvent;
(function (OwnershipEvent) {
    OwnershipEvent["RequestHasOwner"] = "request-has-owner";
    OwnershipEvent["ResponseHasOwner"] = "response-has-owner";
    OwnershipEvent["RequestIsOwner"] = "request-is-owner";
    OwnershipEvent["ResponseIsOwner"] = "response-is-owner";
    OwnershipEvent["RequestOwnership"] = "request-ownership";
    OwnershipEvent["GainedOwnership"] = "gained-ownership";
    OwnershipEvent["RemoveOwnership"] = "remove-ownership";
    OwnershipEvent["LostOwnership"] = "lost-ownership";
    OwnershipEvent["GainedOwnershipBroadcast"] = "gained-ownership-broadcast";
    OwnershipEvent["LostOwnershipBroadcast"] = "lost-ownership-broadcast";
})(OwnershipEvent || (OwnershipEvent = {}));
export class OwnershipModel {
    guid;
    connection;
    get hasOwnership() {
        return this._hasOwnership;
    }
    // TODO: server should just send id to everyone
    // if anyone has ownership
    get isOwned() {
        return this._isOwned;
    }
    get isConnected() {
        return this.connection.isConnected;
    }
    _hasOwnership = false;
    _isOwned = undefined;
    _gainSubscription;
    _lostSubscription;
    _hasOwnerResponse;
    constructor(connection, guid) {
        this.connection = connection;
        this.guid = guid;
        this._gainSubscription = this.onGainedOwnership.bind(this);
        this._lostSubscription = this.onLostOwnership.bind(this);
        connection.beginListen(OwnershipEvent.LostOwnership, this._lostSubscription);
        connection.beginListen(OwnershipEvent.GainedOwnershipBroadcast, this._gainSubscription);
        this._hasOwnerResponse = this.onHasOwnerResponse.bind(this);
        connection.beginListen(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
    }
    _isWaitingForOwnershipResponseCallback = null;
    updateIsOwned() {
        this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
    }
    onHasOwnerResponse(res) {
        if (res.guid === this.guid) {
            this._isOwned = res.value;
        }
    }
    requestOwnershipIfNotOwned() {
        if (this._isWaitingForOwnershipResponseCallback !== null)
            return this;
        this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this);
        this.connection.beginListen(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
        this.connection.send(OwnershipEvent.RequestHasOwner, { guid: this.guid });
        return this;
    }
    waitForHasOwnershipRequestResponse(res) {
        // console.log(res);
        if (res.guid === this.guid) {
            if (this._isWaitingForOwnershipResponseCallback) {
                this.connection.stopListening(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
                this._isWaitingForOwnershipResponseCallback = null;
            }
            this._isOwned = res.value;
            if (!res.value) {
                if (debugOwner)
                    console.log("request ownership", this.guid);
                this.requestOwnership();
            }
        }
    }
    requestOwnershipAsync() {
        return new Promise((resolve, reject) => {
            this.requestOwnership();
            let updates = 0;
            const waitForOwnership = () => {
                if (updates++ > 10)
                    return reject("Timeout");
                setTimeout(() => {
                    if (this.hasOwnership)
                        resolve(this);
                    else
                        waitForOwnership();
                }, 100);
            };
            waitForOwnership();
        });
    }
    requestOwnership() {
        if (debugOwner)
            console.log("Request ownership", this.guid);
        this.connection.send(OwnershipEvent.RequestOwnership, { guid: this.guid });
        return this;
    }
    freeOwnership() {
        // TODO: abort "requestOwnershipIfNotOwned"
        this.connection.send(OwnershipEvent.RemoveOwnership, { guid: this.guid });
        if (this._isWaitingForOwnershipResponseCallback) {
            this.connection.stopListening(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
            this._isWaitingForOwnershipResponseCallback = null;
        }
        return this;
    }
    destroy() {
        this.connection.stopListening(OwnershipEvent.GainedOwnership, this._gainSubscription);
        this.connection.stopListening(OwnershipEvent.LostOwnership, this._lostSubscription);
        this.connection.stopListening(OwnershipEvent.ResponseHasOwner, this._hasOwnerResponse);
        if (this._isWaitingForOwnershipResponseCallback) {
            this.connection.stopListening(OwnershipEvent.ResponseHasOwner, this._isWaitingForOwnershipResponseCallback);
            this._isWaitingForOwnershipResponseCallback = null;
        }
    }
    onGainedOwnership(res) {
        if (res.guid === this.guid) {
            this._isOwned = true;
            // console.log(res.owner, connection.connectionId)
            if (this.connection.connectionId === res.owner) {
                if (debugOwner)
                    console.log("GAINED OWNERSHIP", this.guid);
                this._hasOwnership = true;
            }
            else
                this._hasOwnership = false;
        }
    }
    onLostOwnership(guid) {
        if (guid === this.guid) {
            if (debugOwner)
                console.log("LOST OWNERSHIP", this.guid);
            this._hasOwnership = false;
            this._isOwned = false;
        }
    }
}
export class NetworkConnection {
    context;
    _peer = null;
    constructor(context) {
        this.context = context;
    }
    get peer() {
        if (!this._peer) {
            this._peer = new PeerNetworking();
        }
        return this._peer;
    }
    tryGetState(guid) {
        if (guid === "invalid")
            return null;
        return this._state[guid];
    }
    get connectionId() {
        return this._connectionId;
    }
    get isDebugEnabled() {
        return debugNet;
    }
    get isConnected() {
        return this.connected;
    }
    get currentRoomName() { return this._currentRoomName; }
    get allowEditing() { return this._currentRoomAllowEditing; }
    // use this to join a room in view mode (see SyncedRoom)
    get currentRoomViewId() { return this._currentRoomViewId; }
    get isInRoom() {
        return this._isInRoom;
    }
    get currentLatency() {
        return this._currentDelay;
    }
    userIsInRoom(id) {
        return this._currentInRoom.indexOf(id) !== -1;
    }
    _usersInRoomCopy = [];
    usersInRoom(target = null) {
        if (!target)
            target = this._usersInRoomCopy;
        target.length = 0;
        for (const user of this._currentInRoom)
            target.push(user);
        return target;
    }
    joinRoom(room, viewOnly = false) {
        this.connect();
        if (debugNet)
            console.log("join: " + room);
        this.send(RoomEvents.Join, { room: room, viewOnly: viewOnly }, SendQueue.OnConnection);
    }
    leaveRoom(room = null) {
        if (!room)
            room = this.currentRoomName;
        if (!room) {
            console.error("Can not leave unknown room");
            return;
        }
        this.send(RoomEvents.Leave, { room: room });
    }
    send(key, data = null, queue = SendQueue.Queued) {
        if (data === null)
            data = {};
        if (queue === SendQueue.Queued) {
            this._defaultMessagesBuffer.push({ key: key, value: data });
            return;
        }
        // if (!this.connected) return;
        // if (this.channelId)
        //     data["__id"] = this.channelId;
        // else if (this.connectionId)
        //     data["__id"] = this.connectionId;
        // this.sendGeckosIo(key, data);
        return this.sendWithWebsocket(key, data, queue);
    }
    sendDeleteRemoteState(guid) {
        this.send("delete-state", { guid: guid, dontSave: true });
        delete this._state[guid];
    }
    sendDeleteRemoteStateAll() {
        this.send("delete-all-state");
        this._state = {};
    }
    sendBinary(bin) {
        if (debugNet)
            console.log("<< bin", bin.length);
        this._ws?.send(bin);
    }
    _defaultMessagesBuffer = [];
    _defaultMessagesBufferArray = [];
    sendBufferedMessagesNow() {
        if (!this._ws)
            return;
        this._defaultMessagesBufferArray.length = 0;
        const count = Object.keys(this._defaultMessagesBuffer).length;
        for (const key in this._defaultMessagesBuffer) {
            const data = this._defaultMessagesBuffer[key];
            // if there is only one message to be sent we dont need to send an array
            if (count <= 1) {
                this.sendWithWebsocket(data.key, data.value, SendQueue.Immediate);
                break;
            }
            const msg = this.toMessage(data.key, data.value);
            this._defaultMessagesBufferArray.push(msg);
        }
        this._defaultMessagesBuffer.length = 0;
        if (this._defaultMessagesBufferArray.length > 0 && debugNet)
            console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length);
        if (this._defaultMessagesBufferArray.length <= 0)
            return;
        const message = JSON.stringify(this._defaultMessagesBufferArray);
        this._ws?.send(message);
    }
    beginListen(key, callback) {
        if (!this._listeners[key])
            this._listeners[key] = [];
        this._listeners[key].push(callback);
        return callback;
    }
    stopListening(key, callback) {
        if (!callback)
            return;
        if (!this._listeners[key])
            return;
        const index = this._listeners[key].indexOf(callback);
        if (index >= 0) {
            this._listeners[key].splice(index, 1);
        }
    }
    beginListenBinrary(identifier, callback) {
        if (!this._listenersBinary[identifier])
            this._listenersBinary[identifier] = [];
        this._listenersBinary[identifier].push(callback);
        return callback;
    }
    stopListenBinary(identifier, callback) {
        if (!this._listenersBinary[identifier])
            return;
        const index = this._listenersBinary[identifier].indexOf(callback);
        if (index >= 0) {
            this._listenersBinary[identifier].splice(index, 1);
        }
    }
    netWebSocketUrlProvider;
    registerProvider(prov) {
        this.netWebSocketUrlProvider = prov;
    }
    connect() {
        if (this.connected)
            return;
        if (debugNet)
            console.log("connecting");
        // this.channel = geckos({ port: 9208, url: 'http://127.0.0.1' });
        // this.channel.onConnect(this.onConnectGeckosIo.bind(this));
        // const networking = GameObject.findObjectOfType(Networking, this.context, false);
        const overrideUrl = this.netWebSocketUrlProvider?.getWebsocketUrl();
        if (overrideUrl) {
            serverUrl = overrideUrl;
        }
        else if (isHostedOnGlitch()) {
            serverUrl = "wss://" + window.location.host + "/socket";
        }
        this.connectWebsocket();
    }
    ;
    _listeners = {};
    _listenersBinary = {};
    connected = false;
    channelId;
    _connectionId = null;
    // Websocket ------------------------------------------------------------
    _isConnectingToWebsocket = false;
    _ws;
    _waitingForSocket = {};
    _isInRoom = false;
    _currentRoomName = null;
    _currentRoomViewId = null;
    _currentRoomAllowEditing = true;
    _currentInRoom = [];
    _state = {};
    _currentDelay = -1;
    connectWebsocket() {
        if (this._isConnectingToWebsocket)
            return;
        this._isConnectingToWebsocket = true;
        console.log("Connecting to " + serverUrl);
        const ws = new WebsocketBuilder(serverUrl)
            .onOpen(() => {
            this._ws = ws;
            this._isConnectingToWebsocket = false;
            this.connected = true;
            console.log("Connected to websocket");
            this.onSendQueued(SendQueue.OnConnection);
        })
            .onClose((_evt) => {
            this.connected = false;
            this._isInRoom = false;
        })
            .onError((i, ev) => { console.error(i, ev); })
            .onMessage(this.onMessage.bind(this))
            .onRetry(() => { console.log("websocket connection retry"); })
            .build();
    }
    onMessage(_, ev) {
        const msg = ev.data;
        try {
            if (typeof msg !== "string") {
                if (msg.size) {
                    // is binary blob
                    this.handleIncomingBinaryMessage(msg);
                }
                return;
            }
            const message = JSON.parse(msg);
            if (Array.isArray(message)) {
                // console.log("Receive package of " + message.length + " messages")
                for (const msg of message) {
                    this.handleIncomingStringMessage(msg);
                }
            }
            else
                this.handleIncomingStringMessage(message);
            return;
        }
        catch {
            if (debugNet && msg === "pong")
                console.log("<<", msg);
        }
    }
    async handleIncomingBinaryMessage(blob) {
        const buf = await blob.arrayBuffer();
        var data = new Uint8Array(buf);
        const bb = new flatbuffers.ByteBuffer(data);
        const id = bb.getBufferIdentifier();
        const callbacks = this._listenersBinary[id];
        // use registered cast methods to get the correct type from the flatbuffer
        const obj = schemes.tryCast(bb);
        const guid = schemes.tryGetGuid(obj);
        if (guid && typeof guid === "string") {
            this._state[guid] = obj;
        }
        if (!callbacks)
            return;
        const res = obj ?? bb; // fallback to bytebuffer if no cast method is registered
        // call all listeners subscribed to these events
        for (const cb of callbacks) {
            cb(res);
        }
    }
    handleIncomingStringMessage(message) {
        if (debugNet)
            console.log("<<", message.key ?? message);
        if (message.key) {
            switch (message.key) {
                case ConnectionEvents.ConnectionInfo:
                    if (message.data) {
                        const connection = message.data;
                        if (connection) {
                            console.assert(connection.id !== undefined && connection.id !== null && connection.id.length > 0, "server did not send connection id", connection.id);
                            // if (debugNet) 
                            console.log("Your id is: " + connection.id, this.context.alias ?? "");
                            this._connectionId = connection.id;
                        }
                    }
                    else
                        console.warn("Expected connection id in " + message.key);
                    break;
                case RoomEvents.JoinedRoom:
                    if (debugNet)
                        console.log(message);
                    if (message) {
                        this._isInRoom = true;
                        const model = message;
                        this._currentRoomName = model.room;
                        this._currentRoomViewId = model.viewId;
                        this._currentRoomAllowEditing = model.allowEditing ?? true;
                        console.log("Room view id", this._currentRoomViewId);
                        this._currentInRoom.length = 0;
                        this._currentInRoom.push(...model.inRoom);
                        if (debugNet)
                            console.log("joined room with", this._currentInRoom, this.context.alias ?? "");
                    }
                    this.onSendQueued(SendQueue.OnRoomJoin);
                    break;
                case RoomEvents.LeftRoom:
                    const model = message;
                    if (model.room === this.currentRoomName) {
                        this._isInRoom = false;
                        this._currentRoomName = null;
                        this._currentInRoom.length = 0;
                    }
                    break;
                case RoomEvents.UserJoinedRoom:
                    if (message.data) {
                        const model = message.data;
                        this._currentInRoom.push(model.userId);
                        if (debugNet)
                            console.log(model.userId + " joined", "now in room:", this._currentInRoom);
                    }
                    break;
                case RoomEvents.UserLeftRoom:
                    if (message.data) {
                        const model = message.data;
                        const index = this._currentInRoom.indexOf(model.userId);
                        if (index >= 0) {
                            console.log(model.userId + " left", this.context.alias ?? "");
                            this._currentInRoom.splice(index, 1);
                        }
                        if (model.userId === this.connectionId) {
                            // you left the room
                            console.log("you left the room");
                        }
                    }
                    break;
                case "all-room-state-deleted":
                    if (debugNet)
                        console.log("RECEIVED all-room-state-deleted");
                    this._state = {};
                    break;
                case "ping":
                case "pong":
                    const time = message.data?.time;
                    if (time) {
                        this._currentDelay = this.context.time.time - time;
                    }
                    if (debugNet)
                        console.log("Current latency: " + this._currentDelay.toFixed(1) + " sec", "Clients in room: " + this._currentInRoom?.length);
                    break;
            }
        }
        const listeners = this._listeners[message.key];
        if (listeners) {
            for (const listener of listeners) {
                listener(message.data);
            }
        }
        const model = message.data;
        if (model) {
            this._state[model.guid] = model;
        }
    }
    toMessage(key, data) {
        return {
            key: key,
            data: data
        };
    }
    sendWithWebsocket(key, data, queue = SendQueue.OnRoomJoin) {
        // console.log(key);
        if (!this._ws) {
            const arr = this._waitingForSocket[queue] || [];
            arr.push(() => this.sendWithWebsocket(key, data, queue));
            this._waitingForSocket[queue] = arr;
            // console.log(this._bufferedMessages)
            return;
        }
        const str = JSON.stringify(this.toMessage(key, data));
        if (debugNet)
            console.log(">>", key);
        this._ws.send(str);
    }
    onSendQueued(queue) {
        const queued = this._waitingForSocket[queue];
        // console.log("send", queue, queued);
        if (queued) {
            for (const callback of queued) {
                callback();
            }
            queued.length = 0;
        }
    }
}
//# sourceMappingURL=engine_networking.js.map