import { BufferAttribute, Line, BoxGeometry, EdgesGeometry, Color, LineSegments, LineBasicMaterial, Mesh, SphereGeometry, Vector3, Quaternion } from 'three';
import { Context } from './engine_setup';
import { setWorldPositionXYZ } from './engine_three_utils';
const _tmp = new Vector3();
const _quat = new Quaternion();
const defaultColor = 0x888888;
export class Gizmos {
    static DrawRay(origin, dir, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getLine(duration);
        const positions = obj.geometry.getAttribute("position");
        positions.setXYZ(0, origin.x, origin.y, origin.z);
        _tmp.set(dir.x, dir.y, dir.z).multiplyScalar(999999999);
        positions.setXYZ(1, origin.x + _tmp.x, origin.y + _tmp.y, origin.z + _tmp.z);
        positions.needsUpdate = true;
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
    }
    static DrawDirection(pt, direction, color = defaultColor, duration = 0, depthTest = true, lengthFactor = 1) {
        const obj = Internal.getLine(duration);
        const positions = obj.geometry.getAttribute("position");
        positions.setXYZ(0, pt.x, pt.y, pt.z);
        if (direction["w"] !== undefined) {
            _tmp.set(0, 0, -lengthFactor);
            _quat.set(direction["x"], direction["y"], direction["z"], direction["w"]);
            _tmp.applyQuaternion(_quat);
        }
        else {
            _tmp.set(direction.x, direction.y, direction.z);
            _tmp.multiplyScalar(lengthFactor);
        }
        positions.setXYZ(1, pt.x + _tmp.x, pt.y + _tmp.y, pt.z + _tmp.z);
        positions.needsUpdate = true;
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
    }
    static DrawLine(pt0, pt1, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getLine(duration);
        const positions = obj.geometry.getAttribute("position");
        positions.setXYZ(0, pt0.x, pt0.y, pt0.z);
        positions.setXYZ(1, pt1.x, pt1.y, pt1.z);
        positions.needsUpdate = true;
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
    }
    static DrawWireSphere(center, radius, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getSphere(radius, duration, true);
        setWorldPositionXYZ(obj, center.x, center.y, center.z);
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
    }
    static DrawSphere(center, radius, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getSphere(radius, duration, false);
        setWorldPositionXYZ(obj, center.x, center.y, center.z);
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
    }
    static DrawBox(center, size, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getBox(duration);
        obj.position.set(center.x, center.y, center.z);
        obj.scale.set(size.x, size.y, size.z);
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
        obj.material["wireframe"] = true;
    }
    static DrawBox3(box, color = defaultColor, duration = 0, depthTest = true) {
        const obj = Internal.getBox(duration);
        obj.position.copy(box.getCenter(_tmp));
        obj.scale.copy(box.getSize(_tmp));
        obj.material["color"].set(color);
        obj.material["depthTest"] = depthTest;
        obj.material["wireframe"] = true;
    }
}
const box = new BoxGeometry(1, 1, 1);
export function CreateWireCube(col = null) {
    const color = new Color(col ?? 0xdddddd);
    // const material = new THREE.MeshBasicMaterial();
    // material.color = new THREE.Color(col ?? 0xdddddd);
    // material.wireframe = true;
    // const box = new THREE.Mesh(box, material);
    // box.name = "BOX_GIZMO";
    const edges = new EdgesGeometry(box);
    const line = new LineSegments(edges, new LineBasicMaterial({ color: color }));
    return line;
}
const $cacheSymbol = Symbol("GizmoCache");
class Internal {
    // private static createdLines: number = 0;
    static getBox(duration) {
        let box = this.boxesCache.pop();
        if (!box) {
            const geo = new BoxGeometry(1, 1, 1);
            box = new Mesh(geo);
        }
        this.registerTimedObject(Context.Current, box, duration, this.boxesCache);
        return box;
    }
    static getLine(duration) {
        let line = this.linesCache.pop();
        if (!line) {
            line = new Line();
            let positions = line.geometry.getAttribute("position");
            if (!positions) {
                positions = new BufferAttribute(new Float32Array(2 * 3), 3);
                line.geometry.setAttribute("position", positions);
            }
        }
        this.registerTimedObject(Context.Current, line, duration, this.linesCache);
        return line;
    }
    static getSphere(radius, duration, wireframe) {
        let sphere = this.spheresCache.pop();
        if (!sphere) {
            sphere = new Mesh(new SphereGeometry(.5, 8, 8));
        }
        sphere.scale.set(radius, radius, radius);
        sphere.material["wireframe"] = wireframe;
        this.registerTimedObject(Context.Current, sphere, duration, this.spheresCache);
        return sphere;
    }
    static linesCache = [];
    static spheresCache = [];
    static boxesCache = [];
    static registerTimedObject(context, object, duration, cache) {
        if (!this.contextPostRenderCallbacks.get(context)) {
            const cb = () => { this.onPostRender(context, this.timedObjectsBuffer, this.timesBuffer); };
            this.contextPostRenderCallbacks.set(context, cb);
            context.post_render_callbacks.push(cb);
        }
        object[$cacheSymbol] = cache;
        this.timedObjectsBuffer.push(object);
        this.timesBuffer.push(Context.Current.time.time + duration);
        context.scene.add(object);
    }
    static timedObjectsBuffer = new Array();
    static timesBuffer = new Array();
    static contextPostRenderCallbacks = new Map();
    static onPostRender(ctx, objects, times) {
        const time = ctx.time.time;
        for (let i = 0; i < objects.length; i++) {
            if (time > times[i]) {
                const obj = objects[i];
                const cache = obj[$cacheSymbol];
                cache.push(obj);
                ctx.scene.remove(obj);
                objects.splice(i, 1);
                times.splice(i, 1);
            }
        }
    }
}
//# sourceMappingURL=engine_gizmos.js.map