import * as THREE from "three";
import { Vector3, Texture, ShaderMaterial } from "three";
export declare function slerp(vec: Vector3, end: Vector3, t: number): THREE.Vector3;
export declare function lookAtInverse(obj: THREE.Object3D, target: Vector3): void;
export declare function getWorldPosition(obj: THREE.Object3D, vec?: THREE.Vector3 | null, updateParents?: boolean): THREE.Vector3;
export declare function setWorldPosition(obj: THREE.Object3D, val: THREE.Vector3): void;
export declare function setWorldPositionXYZ(obj: THREE.Object3D, x: number, y: number, z: number): void;
export declare function getWorldQuaternion(obj: THREE.Object3D, target?: THREE.Quaternion | null): THREE.Quaternion;
export declare function setWorldQuaternion(obj: THREE.Object3D, val: THREE.Quaternion): void;
export declare function setWorldQuaternionXYZW(obj: THREE.Object3D, x: number, y: number, z: number, w: number): void;
export declare function getWorldScale(obj: THREE.Object3D, vec?: THREE.Vector3 | null): THREE.Vector3;
export declare function setWorldScale(obj: THREE.Object3D, vec: THREE.Vector3): void;
export declare function forward(obj: THREE.Object3D): THREE.Vector3;
export declare function getWorldEuler(obj: THREE.Object3D): THREE.Euler;
export declare function setWorldEuler(obj: THREE.Object3D, val: THREE.Euler): void;
export declare function getWorldRotation(obj: THREE.Object3D): THREE.Vector3;
export declare function setWorldRotation(obj: THREE.Object3D, val: THREE.Vector3): void;
export declare function setWorldRotationXYZ(obj: THREE.Object3D, x: number, y: number, z: number, degrees?: boolean): void;
export declare function logHierarchy(root: THREE.Object3D | null | undefined, collapsible?: boolean): void;
export declare function isAnimationAction(obj: object): boolean;
export declare class Graphics {
    private static planeGeometry;
    private static renderer;
    private static perspectiveCam;
    private static scene;
    private static readonly vertex;
    private static readonly fragment;
    private static readonly blipMaterial;
    static createBlitMaterial(fragment: string): ShaderMaterial;
    private static readonly mesh;
    static copyTexture(texture: Texture, blitMaterial?: ShaderMaterial): THREE.Texture;
    static textureToCanvas(texture: Texture, force: boolean): HTMLCanvasElement | null;
}
/**@obsolete use Graphics.copyTexture */
export declare function copyTexture(texture: THREE.Texture): THREE.Texture;
/**@obsolete use Graphics.textureToCanvas */
export declare function textureToCanvas(texture: THREE.Texture, force?: boolean): HTMLCanvasElement | null;
