/// <reference types="webxr" />
import { Camera, Color, Material, Object3D, Vector3, Quaternion, Ray } from "three";
import { RGBAColor } from "../engine-components/js-extensions/RGBAColor";
import { CollisionDetectionMode, RigidbodyConstraints } from "./engine_physics.types";
/** used to find data registered via gltf files e.g. find lightmaps for a Renderer component that were shipped inside a gltf */
export declare type SourceIdentifier = string;
export type Constructor<T> = abstract new (...args: any[]) => T;
export type ConstructorConcrete<T> = new (...args: any[]) => T;
export type GuidsMap = {
    [key: string]: string;
};
export interface UIDProvider {
    seed: number;
    generateUUID(): string;
}
export declare interface INeedleEngineComponent extends HTMLElement {
    getAROverlayContainer(): HTMLElement;
    onEnterAR(session: XRSession, overlayContainer: HTMLElement): any;
    onExitAR(session: XRSession): any;
}
export declare interface IGameObject extends Object3D {
    guid: string | undefined;
    activeSelf: boolean;
    addNewComponent<T>(type: Constructor<T>): T | null;
    removeComponent(comp: IComponent): IComponent;
    getOrAddComponent<T>(typeName: Constructor<T> | null): T;
    getComponent<T>(type: Constructor<T>): T | null;
    getComponents<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    getComponentInChildren<T>(type: Constructor<T>): T | null;
    getComponentsInChildren<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    getComponentInParent<T>(type: Constructor<T>): T | null;
    getComponentsInParent<T>(type: Constructor<T>, arr?: T[]): Array<T>;
}
export interface IComponent {
    get isComponent(): boolean;
    gameObject: IGameObject;
    guid: string;
    enabled: boolean;
    sourceId?: SourceIdentifier;
    get name(): string;
    get layer(): number;
    get destroyed(): boolean;
    get tag(): string;
    context: any;
    get activeAndEnabled(): boolean;
    __internalNewInstanceCreated(): any;
    __internalAwake(): any;
    __internalStart(): any;
    __internalEnable(): any;
    __internalDisable(): any;
    __internalDestroy(): any;
    resolveGuids?(guidsMap: GuidsMap): void;
    awake(): any;
    onEnable(): any;
    onDisable(): any;
    onDestroy(): any;
    destroy(): any;
    /** called for properties decorated with the @validate decorator */
    onValidate?(property?: string): any;
    /** called when this.context.isPaused changes or when rendering loop changes due to changing DOM element visibility
     * e.g. when the DOM element becomes hidden or out ot view
     */
    onPausedChanged?(isPaused: boolean, wasPaused: boolean): any;
    start?(): void;
    earlyUpdate?(): void;
    update?(): void;
    lateUpdate?(): void;
    onBeforeRender?(frame: XRFrame | null): void;
    onAfterRender?(): void;
    onCollisionEnter?(col: Collision): any;
    onCollisionExit?(col: Collision): any;
    onCollisionStay?(col: Collision): any;
    onTriggerEnter?(col: ICollider): any;
    onTriggerStay?(col: ICollider): any;
    onTriggerExit?(col: ICollider): any;
    get forward(): Vector3;
    get worldPosition(): Vector3;
    get worldQuaternion(): Quaternion;
}
export declare interface ICamera extends IComponent {
    get isCamera(): boolean;
    applyClearFlagsIfIsActiveCamera(): unknown;
    buildCamera(): any;
    get cam(): Camera;
    nearClipPlane: number;
    farClipPlane: number;
    backgroundColor: RGBAColor | null;
    clearFlags: number;
    aspect: number;
    fieldOfView: number;
    screenPointToRay(x: number, y: number, ray?: Ray): Ray;
}
export declare interface ILight extends IComponent {
    intensity: number;
    color: Color;
}
export declare interface ISharedMaterials {
    [num: number]: Material;
    get length(): number;
}
export declare interface IRenderer extends IComponent {
    sharedMaterial: Material;
    get sharedMaterials(): ISharedMaterials;
}
export declare interface ICollider extends IComponent {
    get isCollider(): any;
    attachedRigidbody: IRigidbody | null;
    isTrigger: boolean;
}
export declare interface IRigidbody extends IComponent {
    constraints: RigidbodyConstraints;
    isKinematic: boolean;
    mass: number;
    drag: number;
    angularDrag: number;
    useGravity: boolean;
    collisionDetectionMode: CollisionDetectionMode;
    lockPositionX: boolean;
    lockPositionY: boolean;
    lockPositionZ: boolean;
    lockRotationX: boolean;
    lockRotationY: boolean;
    lockRotationZ: boolean;
}
export declare const $physicsKey: unique symbol;
export declare type ICollisionContext = {
    getCollider(obj: Object3D): ICollider;
};
export type Vec2 = {
    x: number;
    y: number;
};
export type Vec3 = {
    x: number;
    y: number;
    z: number;
};
export type Vec4 = {
    x: number;
    y: number;
    z: number;
    w: number;
};
export declare class ContactPoint {
    private readonly _point;
    private readonly _normal;
    readonly distance: number;
    readonly impulse: number;
    readonly friction: number;
    /** worldspace point */
    get point(): Vector3;
    /** worldspace normal */
    get normal(): Vector3;
    constructor(point: Vec3, dist: number, normal: Vec3, impulse: number, friction: number);
}
export declare class Collision {
    readonly contacts: ContactPoint[];
    constructor(obj: Object3D, otherCollider: ICollider, contacts: ContactPoint[]);
    readonly me: Object3D;
    private _collider;
    /** the collider the collision happened with */
    get collider(): ICollider;
    /** the object the collision happened with */
    private _gameObject;
    get gameObject(): Object3D;
    /** the rigidbody we hit, null if none attached */
    get rigidBody(): IRigidbody | null;
}
