/// <reference types="webxr" />
import * as THREE from 'three';
import { Input } from './engine_input';
import { Physics } from './engine_physics';
import { Time } from './engine_time';
import { NetworkConnection } from './engine_networking';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { AssetDatabase } from './engine_assetdatabase';
import { RendererData } from './engine_rendererdata';
import { Addressables } from './engine_addressables';
import { Application } from './engine_application';
import { ILightDataRegistry } from './engine_lightdata';
import { PlayerViewManager } from './engine_playerview';
import { ICamera, IComponent, ILight } from "./engine_types";
export declare const build_scene_functions: {
    [name: string]: (context: Context) => Promise<void>;
};
declare type CoroutineData = {
    comp: IComponent;
    main: Generator;
    chained?: Array<Generator>;
};
export declare class LoadingProgressArgs {
    name: string;
    progress: ProgressEvent;
    index: number;
    count: number;
}
export declare class LoadingOptions {
    progress: (args: LoadingProgressArgs) => void;
}
export declare class ContextArgs {
    name: string | undefined | null;
    alias: string | undefined | null;
    domElement: HTMLElement | null;
    renderer?: THREE.WebGLRenderer;
    hash?: string;
    constructor(domElement: HTMLElement | null);
}
export declare enum FrameEvent {
    EarlyUpdate = 0,
    Update = 1,
    LateUpdate = 2,
    OnBeforeRender = 3,
    OnAfterRender = 4,
    PrePhysicsStep = 9,
    PostPhysicsStep = 10
}
export declare enum XRSessionMode {
    ImmersiveVR = "immersive-vr",
    ImmersiveAR = "immersive-ar"
}
export declare type OnBeforeRenderCallback = (renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera, geometry: THREE.BufferGeometry, material: THREE.Material, group: THREE.Group) => void;
export declare function registerComponent(script: IComponent, context?: Context): void;
export declare class Context {
    private static _current;
    static get Current(): Context;
    static set Current(context: Context);
    name: string;
    alias: string | undefined | null;
    isManagedExternally: boolean;
    isPaused: boolean;
    runInBackground: boolean;
    /** used to append to loaded assets */
    hash?: string;
    domElement: HTMLElement;
    get resolutionScaleFactor(): number;
    /** use to scale the resolution up or down of the renderer. default is 1 */
    set resolutionScaleFactor(val: number);
    private _resolutionScaleFactor;
    private _boundingClientRectFrame;
    private _boundingClientRect;
    private _domX;
    private _domY;
    private calculateBoundingClientRect;
    get domWidth(): number;
    get domHeight(): number;
    get domX(): number;
    get domY(): number;
    get isInXR(): boolean;
    xrSessionMode: XRSessionMode | undefined;
    get isInVR(): boolean;
    get isInAR(): boolean;
    get xrSession(): XRSession | null;
    get arOverlayElement(): HTMLElement;
    /** Current event of the update cycle */
    get currentFrameEvent(): FrameEvent;
    private _currentFrameEvent;
    scene: THREE.Scene;
    renderer: THREE.WebGLRenderer;
    composer: EffectComposer | null;
    scripts: IComponent[];
    scripts_pausedChanged: IComponent[];
    scripts_earlyUpdate: IComponent[];
    scripts_update: IComponent[];
    scripts_lateUpdate: IComponent[];
    scripts_onBeforeRender: IComponent[];
    scripts_onAfterRender: IComponent[];
    scripts_WithCorroutines: IComponent[];
    coroutines: {
        [FrameEvent: number]: Array<CoroutineData>;
    };
    get mainCamera(): THREE.Camera | null;
    mainCameraComponent: ICamera | undefined;
    post_setup_callbacks: Function[];
    pre_update_callbacks: Function[];
    pre_render_callbacks: Function[];
    post_render_callbacks: Function[];
    new_scripts: IComponent[];
    new_script_start: IComponent[];
    new_scripts_pre_setup_callbacks: Function[];
    new_scripts_post_setup_callbacks: Function[];
    application: Application;
    time: Time;
    input: Input;
    physics: Physics;
    connection: NetworkConnection;
    /**
     * @deprecated AssetDataBase is deprecated
     */
    assets: AssetDatabase;
    mainLight: ILight | null;
    rendererData: RendererData;
    addressables: Addressables;
    lightmaps: ILightDataRegistry;
    players: PlayerViewManager;
    private _sizeChanged;
    private _isCreated;
    private _isVisible;
    private _stats;
    constructor(args: ContextArgs | undefined);
    private _disposeCallbacks;
    private updateSize;
    updateAspect(camera: THREE.PerspectiveCamera): void;
    onCreate(buildScene?: (context: Context, loadingOptions?: LoadingOptions) => Promise<void>, opts?: LoadingOptions): Promise<void> | null;
    onDestroy(): void;
    registerCoroutineUpdate(script: IComponent, coroutine: Generator, evt: FrameEvent): Generator;
    unregisterCoroutineUpdate(coroutine: Generator, evt: FrameEvent): void;
    stopAllCoroutinesFrom(script: IComponent): void;
    private _cameraStack;
    setCurrentCamera(cam: ICamera): void;
    removeCamera(cam?: ICamera | null): void;
    private _onBeforeRenderListeners;
    /** use this to subscribe to onBeforeRender events on threejs objects */
    addBeforeRenderListener(target: THREE.Object3D, callback: OnBeforeRenderCallback): void;
    removeBeforeRenderListener(target: THREE.Object3D, callback: OnBeforeRenderCallback): void;
    private _requireDepthTexture;
    private _requireColorTexture;
    private _renderTarget?;
    private _isRendering;
    get isRendering(): boolean;
    setRequireDepth(val: boolean): void;
    setRequireColor(val: boolean): void;
    get depthTexture(): THREE.DepthTexture | null;
    get opaqueColorTexture(): THREE.Texture | null;
    /** returns true if the dom element is visible on screen */
    get isVisibleToUser(): boolean;
    private internalOnCreate;
    private render;
    /** returns true if we should return out of the frame loop */
    private _wasPaused;
    private onHandlePaused;
    private evaluatePaused;
    private renderRequiredTextures;
    private executeCoroutines;
}
export {};
