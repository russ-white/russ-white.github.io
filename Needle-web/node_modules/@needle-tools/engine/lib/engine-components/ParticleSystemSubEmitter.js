import { Vector3, Quaternion, Matrix4 } from "three";
import { CircularBuffer } from "../engine/engine_utils";
const VECTOR_ONE = new Vector3(1, 1, 1);
const VECTOR_Z = new Vector3(0, 0, 1);
const $emitterMatrix = Symbol("emitterMatrix");
export class ParticleSubEmitter {
    system;
    particleSystem;
    subSystem;
    subParticleSystem;
    type = "NeedleParticleSubEmitter";
    //private matrix_ = new Matrix4();
    q_ = new Quaternion();
    v_ = new Vector3();
    v2_ = new Vector3();
    _emitterMatrix = new Matrix4();
    _circularBuffer;
    constructor(system, particleSystem, subSystem, subParticleSystem) {
        this.system = system;
        this.particleSystem = particleSystem;
        this.subSystem = subSystem;
        this.subParticleSystem = subParticleSystem;
        if (this.subParticleSystem && this.subParticleSystem) {
            this.subParticleSystem.onlyUsedByOther = true;
        }
        const maxMatrices = 1000;
        this._circularBuffer = new CircularBuffer(() => new Matrix4(), maxMatrices);
    }
    clone() {
        throw new Error("Method not implemented.");
    }
    initialize(particle) {
        particle.emissionState = {
            burstIndex: 0,
            burstWaveIndex: 0,
            time: 0,
            waitEmiting: 0,
            // matrix: new Matrix4(),
        };
        // particle[$emitterMatrix] = new Matrix4();
        this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld);
    }
    update(particle, delta) {
        if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles)
            return;
        if (!this.subParticleSystem || !particle.emissionState)
            return;
        // TODO: figure out how to re-use matrices
        const m = new Matrix4(); // this._circularBuffer.get();// new Matrix4();// particle[$emitterMatrix];
        m.set(1, 0, 0, particle.position.x, 0, 1, 0, particle.position.y, 0, 0, 1, particle.position.z, 0, 0, 0, 1);
        if (!this.particleSystem.worldSpace) {
            m.multiplyMatrices(this._emitterMatrix, m);
        }
        this.subParticleSystem.emit(delta, particle.emissionState, m);
    }
    frameUpdate(_delta) {
    }
    toJSON() {
    }
}
//# sourceMappingURL=ParticleSystemSubEmitter.js.map