var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import { GroundProjectedEnv as GroundProjection } from 'three/examples/jsm/objects/GroundProjectedEnv.js';
import { serializable } from "../engine/engine_serialization_decorator";
import { Watch as Watch } from "../engine/engine_utils";
export class GroundProjectedEnv extends Behaviour {
    set scale(val) {
        this._scale = val;
        this.env?.scale.setScalar(val);
    }
    get scale() {
        return this._scale;
    }
    _scale = 20;
    set radius(val) {
        this._radius = val;
        if (this.env)
            this.env.height = val;
    }
    get radius() { return this._radius; }
    _radius = 100;
    set height(val) {
        this._height = val;
        if (this.env)
            this.env.height = val;
    }
    get height() { return this._height; }
    _height = 100;
    _lastEnvironment;
    env;
    _watcher;
    onEnable() {
        // TODO: if we do this in the first frame we can not disable it again. Something buggy with the watch?!
        if (this.context.time.frameCount > 0)
            this.updateAndCreate();
    }
    start() {
        this.updateAndCreate();
    }
    onDisable() {
        this._watcher?.revoke();
        this.env?.removeFromParent();
    }
    updateAndCreate() {
        this.updateProjection();
        if (!this._watcher) {
            this._watcher = new Watch(this.context.scene, "environment");
            this._watcher.subscribeWrite(_ => {
                this.updateProjection();
            });
        }
        this._watcher.apply();
    }
    updateProjection() {
        if (!this.context.scene.environment) {
            this.env?.removeFromParent();
            return;
        }
        if (!this.env || this.context.scene.environment !== this._lastEnvironment) {
            console.log("Create/Update Ground Projection", this.context.scene.environment.name);
            this.env = new GroundProjection(this.context.scene.environment);
        }
        this._lastEnvironment = this.context.scene.environment;
        if (!this.env.parent)
            this.gameObject.add(this.env);
        this.env.scale.setScalar(this._scale);
        this.env.radius = this._radius;
        this.env.height = this._height;
        // dont make the ground projection raycastable by default
        if (this.env.isObject3D === true) {
            this.env.layers.set(2);
        }
    }
}
__decorate([
    serializable()
], GroundProjectedEnv.prototype, "scale", null);
__decorate([
    serializable()
], GroundProjectedEnv.prototype, "radius", null);
__decorate([
    serializable()
], GroundProjectedEnv.prototype, "height", null);
//# sourceMappingURL=GroundProjection.js.map