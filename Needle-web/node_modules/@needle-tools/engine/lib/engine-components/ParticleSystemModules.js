var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Matrix4, Quaternion, Vector3, Vector2, Euler } from "three";
import { Mathf } from "../engine/engine_math";
import { serializable } from "../engine/engine_serialization";
import { RGBAColor } from "./js-extensions/RGBAColor";
import { AnimationCurve } from "./AnimationCurve";
export var ParticleSystemRenderMode;
(function (ParticleSystemRenderMode) {
    ParticleSystemRenderMode[ParticleSystemRenderMode["Billboard"] = 0] = "Billboard";
    //   Stretch = 1,
    //   HorizontalBillboard = 2,
    //   VerticalBillboard = 3,
    ParticleSystemRenderMode[ParticleSystemRenderMode["Mesh"] = 4] = "Mesh";
    //   None = 5,
})(ParticleSystemRenderMode || (ParticleSystemRenderMode = {}));
export class Gradient {
    alphaKeys;
    colorKeys;
    get duration() {
        return 1;
    }
    evaluate(time, target) {
        // target.r = this.colorKeys[0].color.r;
        // target.g = this.colorKeys[0].color.g;
        // target.b = this.colorKeys[0].color.b;
        // target.alpha = this.alphaKeys[0].alpha;
        // return;
        let closestAlpha = undefined;
        let closestAlphaIndex = 0;
        let closestColor = null;
        let closestColorIndex = 0;
        for (let i = 0; i < this.alphaKeys.length; i++) {
            const key = this.alphaKeys[i];
            if (key.time < time || !closestAlpha) {
                closestAlpha = key;
                closestAlphaIndex = i;
            }
        }
        for (let i = 0; i < this.colorKeys.length; i++) {
            const key = this.colorKeys[i];
            if (key.time < time || !closestColor) {
                closestColor = key;
                closestColorIndex = i;
            }
        }
        if (closestColor) {
            const hasNextColor = closestColorIndex + 1 < this.colorKeys.length;
            if (hasNextColor) {
                const nextColor = this.colorKeys[closestColorIndex + 1];
                const t = Mathf.remap(time, closestColor.time, nextColor.time, 0, 1);
                target.r = Mathf.lerp(closestColor.color.r, nextColor.color.r, t);
                target.g = Mathf.lerp(closestColor.color.g, nextColor.color.g, t);
                target.b = Mathf.lerp(closestColor.color.b, nextColor.color.b, t);
            }
            else {
                target.r = closestColor.color.r;
                target.g = closestColor.color.g;
                target.b = closestColor.color.b;
            }
        }
        if (closestAlpha) {
            const hasNextAlpha = closestAlphaIndex + 1 < this.alphaKeys.length;
            if (hasNextAlpha) {
                const nextAlpha = this.alphaKeys[closestAlphaIndex + 1];
                const t = Mathf.remap(time, closestAlpha.time, nextAlpha.time, 0, 1);
                target.alpha = Mathf.lerp(closestAlpha.alpha, nextAlpha.alpha, t);
            }
            else {
                target.alpha = closestAlpha.alpha;
            }
        }
        return target;
    }
}
__decorate([
    serializable()
], Gradient.prototype, "alphaKeys", void 0);
__decorate([
    serializable()
], Gradient.prototype, "colorKeys", void 0);
export var ParticleSystemCurveMode;
(function (ParticleSystemCurveMode) {
    ParticleSystemCurveMode[ParticleSystemCurveMode["Constant"] = 0] = "Constant";
    ParticleSystemCurveMode[ParticleSystemCurveMode["Curve"] = 1] = "Curve";
    ParticleSystemCurveMode[ParticleSystemCurveMode["TwoCurves"] = 2] = "TwoCurves";
    ParticleSystemCurveMode[ParticleSystemCurveMode["TwoConstants"] = 3] = "TwoConstants";
})(ParticleSystemCurveMode || (ParticleSystemCurveMode = {}));
export var ParticleSystemGradientMode;
(function (ParticleSystemGradientMode) {
    ParticleSystemGradientMode[ParticleSystemGradientMode["Color"] = 0] = "Color";
    ParticleSystemGradientMode[ParticleSystemGradientMode["Gradient"] = 1] = "Gradient";
    ParticleSystemGradientMode[ParticleSystemGradientMode["TwoColors"] = 2] = "TwoColors";
    ParticleSystemGradientMode[ParticleSystemGradientMode["TwoGradients"] = 3] = "TwoGradients";
    ParticleSystemGradientMode[ParticleSystemGradientMode["RandomColor"] = 4] = "RandomColor";
})(ParticleSystemGradientMode || (ParticleSystemGradientMode = {}));
export var ParticleSystemSimulationSpace;
(function (ParticleSystemSimulationSpace) {
    ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["Local"] = 0] = "Local";
    ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["World"] = 1] = "World";
    ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["Custom"] = 2] = "Custom";
})(ParticleSystemSimulationSpace || (ParticleSystemSimulationSpace = {}));
export var ParticleSystemShapeType;
(function (ParticleSystemShapeType) {
    ParticleSystemShapeType[ParticleSystemShapeType["Sphere"] = 0] = "Sphere";
    ParticleSystemShapeType[ParticleSystemShapeType["SphereShell"] = 1] = "SphereShell";
    ParticleSystemShapeType[ParticleSystemShapeType["Hemisphere"] = 2] = "Hemisphere";
    ParticleSystemShapeType[ParticleSystemShapeType["HemisphereShell"] = 3] = "HemisphereShell";
    ParticleSystemShapeType[ParticleSystemShapeType["Cone"] = 4] = "Cone";
    ParticleSystemShapeType[ParticleSystemShapeType["Box"] = 5] = "Box";
    ParticleSystemShapeType[ParticleSystemShapeType["Mesh"] = 6] = "Mesh";
    ParticleSystemShapeType[ParticleSystemShapeType["ConeShell"] = 7] = "ConeShell";
    ParticleSystemShapeType[ParticleSystemShapeType["ConeVolume"] = 8] = "ConeVolume";
    ParticleSystemShapeType[ParticleSystemShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
    ParticleSystemShapeType[ParticleSystemShapeType["Circle"] = 10] = "Circle";
    ParticleSystemShapeType[ParticleSystemShapeType["CircleEdge"] = 11] = "CircleEdge";
    ParticleSystemShapeType[ParticleSystemShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
    ParticleSystemShapeType[ParticleSystemShapeType["MeshRenderer"] = 13] = "MeshRenderer";
    ParticleSystemShapeType[ParticleSystemShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
    ParticleSystemShapeType[ParticleSystemShapeType["BoxShell"] = 15] = "BoxShell";
    ParticleSystemShapeType[ParticleSystemShapeType["BoxEdge"] = 16] = "BoxEdge";
    ParticleSystemShapeType[ParticleSystemShapeType["Donut"] = 17] = "Donut";
    ParticleSystemShapeType[ParticleSystemShapeType["Rectangle"] = 18] = "Rectangle";
    ParticleSystemShapeType[ParticleSystemShapeType["Sprite"] = 19] = "Sprite";
    ParticleSystemShapeType[ParticleSystemShapeType["SpriteRenderer"] = 20] = "SpriteRenderer";
})(ParticleSystemShapeType || (ParticleSystemShapeType = {}));
export var ParticleSystemShapeMultiModeValue;
(function (ParticleSystemShapeMultiModeValue) {
    ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["Random"] = 0] = "Random";
    ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["Loop"] = 1] = "Loop";
    ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["PingPong"] = 2] = "PingPong";
    ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
})(ParticleSystemShapeMultiModeValue || (ParticleSystemShapeMultiModeValue = {}));
export class MinMaxCurve {
    mode;
    constant;
    constantMin;
    constantMax;
    curve;
    curveMin;
    curveMax;
    curveMultiplier;
    evaluate(t01, lerpFactor) {
        const t = lerpFactor === undefined ? Math.random() : lerpFactor;
        switch (this.mode) {
            case ParticleSystemCurveMode.Constant:
                return this.constant;
            case ParticleSystemCurveMode.Curve:
                t01 = Mathf.clamp01(t01);
                return this.curve.evaluate(t01) * this.curveMultiplier;
            case ParticleSystemCurveMode.TwoCurves:
                const t1 = t01 * this.curveMin.duration;
                const t2 = t01 * this.curveMax.duration;
                return Mathf.lerp(this.curveMin.evaluate(t1), this.curveMax.evaluate(t2), t % 1) * this.curveMultiplier;
            case ParticleSystemCurveMode.TwoConstants:
                return Mathf.lerp(this.constantMin, this.constantMax, t % 1);
            default:
                this.curveMax.evaluate(t01) * this.curveMultiplier;
                break;
        }
        return 0;
    }
}
__decorate([
    serializable()
], MinMaxCurve.prototype, "mode", void 0);
__decorate([
    serializable()
], MinMaxCurve.prototype, "constant", void 0);
__decorate([
    serializable()
], MinMaxCurve.prototype, "constantMin", void 0);
__decorate([
    serializable()
], MinMaxCurve.prototype, "constantMax", void 0);
__decorate([
    serializable(AnimationCurve)
], MinMaxCurve.prototype, "curve", void 0);
__decorate([
    serializable(AnimationCurve)
], MinMaxCurve.prototype, "curveMin", void 0);
__decorate([
    serializable(AnimationCurve)
], MinMaxCurve.prototype, "curveMax", void 0);
__decorate([
    serializable()
], MinMaxCurve.prototype, "curveMultiplier", void 0);
export class MinMaxGradient {
    mode;
    color;
    colorMin;
    colorMax;
    gradient;
    gradientMin;
    gradientMax;
    static _temp = new RGBAColor(0, 0, 0, 1);
    static _temp2 = new RGBAColor(0, 0, 0, 1);
    evaluate(t01, lerpFactor) {
        const t = lerpFactor === undefined ? Math.random() : lerpFactor;
        switch (this.mode) {
            case ParticleSystemGradientMode.Color:
                return this.color;
            case ParticleSystemGradientMode.Gradient:
                this.gradient.evaluate(t01, MinMaxGradient._temp);
                return MinMaxGradient._temp;
            case ParticleSystemGradientMode.TwoColors:
                const col1 = MinMaxGradient._temp.lerpColors(this.colorMin, this.colorMax, t);
                return col1;
            case ParticleSystemGradientMode.TwoGradients:
                this.gradientMin.evaluate(t01, MinMaxGradient._temp);
                this.gradientMax.evaluate(t01, MinMaxGradient._temp2);
                return MinMaxGradient._temp.lerp(MinMaxGradient._temp2, t);
        }
        // console.warn("Not implemented", ParticleSystemGradientMode[this.mode]);
        MinMaxGradient._temp.set(0xff00ff);
        MinMaxGradient._temp.alpha = 1;
        return MinMaxGradient._temp;
    }
}
__decorate([
    serializable(RGBAColor)
], MinMaxGradient.prototype, "color", void 0);
__decorate([
    serializable(RGBAColor)
], MinMaxGradient.prototype, "colorMin", void 0);
__decorate([
    serializable(RGBAColor)
], MinMaxGradient.prototype, "colorMax", void 0);
__decorate([
    serializable(Gradient)
], MinMaxGradient.prototype, "gradient", void 0);
__decorate([
    serializable(Gradient)
], MinMaxGradient.prototype, "gradientMin", void 0);
__decorate([
    serializable(Gradient)
], MinMaxGradient.prototype, "gradientMax", void 0);
export class MainModule {
    cullingMode;
    duration;
    emitterVelocityMode;
    flipRotation;
    gravityModifier;
    gravityModifierMultiplier;
    loop;
    maxParticles;
    playOnAwake;
    prewarm;
    ringBufferLoopRange;
    ringBufferMode;
    scalingMode;
    simulationSpace;
    simulationSpeed;
    startColor;
    startDelay;
    startDelayMultiplier;
    startLifetime;
    startLifetimeMultiplier;
    startRotation;
    startRotationMultiplier;
    startRotation3D;
    startRotationX;
    startRotationXMultiplier;
    startRotationY;
    startRotationYMultiplier;
    startRotationZ;
    startRotationZMultiplier;
    startSize;
    startSize3D;
    startSizeMultiplier;
    startSizeX;
    startSizeXMultiplier;
    startSizeY;
    startSizeYMultiplier;
    startSizeZ;
    startSizeZMultiplier;
    startSpeed;
    startSpeedMultiplier;
    stopAction;
    useUnscaledTime;
}
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "gravityModifier", void 0);
__decorate([
    serializable(MinMaxGradient)
], MainModule.prototype, "startColor", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startDelay", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startLifetime", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startRotation", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startRotationX", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startRotationY", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startRotationZ", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startSize", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startSizeX", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startSizeY", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startSizeZ", void 0);
__decorate([
    serializable(MinMaxCurve)
], MainModule.prototype, "startSpeed", void 0);
export class ParticleBurst {
    cycleCount;
    maxCount;
    minCount;
    probability;
    repeatInterval;
    time;
    count;
    _performed = 0;
    reset() {
        this._performed = 0;
    }
    run(time) {
        if (time <= this.time) {
            this.reset();
            return 0;
        }
        let amount = 0;
        if (this.cycleCount === 0 || this._performed < this.cycleCount) {
            const nextTime = this.time + this.repeatInterval * this._performed;
            if (time >= nextTime) {
                this._performed += 1;
                if (Math.random() < this.probability) {
                    switch (this.count.mode) {
                        case ParticleSystemCurveMode.Constant:
                            amount = this.count.constant;
                            break;
                        case ParticleSystemCurveMode.TwoConstants:
                            amount = Mathf.lerp(this.count.constantMin, this.count.constantMax, Math.random());
                            break;
                        case ParticleSystemCurveMode.Curve:
                            amount = this.count.curve.evaluate(Math.random());
                            break;
                        case ParticleSystemCurveMode.TwoCurves:
                            const t = Math.random();
                            amount = Mathf.lerp(this.count.curveMin.evaluate(t), this.count.curveMax.evaluate(t), Math.random());
                            break;
                    }
                }
            }
        }
        return amount;
    }
}
export class EmissionModule {
    enabled;
    get burstCount() {
        return this.bursts?.length ?? 0;
    }
    bursts;
    rateOverTime;
    rateOverTimeMultiplier;
    rateOverDistance;
    rateOverDistanceMultiplier;
    /** set from system */
    system;
    reset() {
        this.bursts?.forEach(b => b.reset());
    }
    getBurst() {
        let amount = 0;
        if (this.burstCount > 0) {
            for (let i = 0; i < this.burstCount; i++) {
                const burst = this.bursts[i];
                if (burst.time >= this.system.time) {
                    burst.reset();
                }
                amount += Math.round(burst.run(this.system.time));
            }
        }
        return amount;
    }
}
__decorate([
    serializable()
], EmissionModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], EmissionModule.prototype, "bursts", void 0);
__decorate([
    serializable(MinMaxCurve)
], EmissionModule.prototype, "rateOverTime", void 0);
__decorate([
    serializable()
], EmissionModule.prototype, "rateOverTimeMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], EmissionModule.prototype, "rateOverDistance", void 0);
__decorate([
    serializable()
], EmissionModule.prototype, "rateOverDistanceMultiplier", void 0);
export class ColorOverLifetimeModule {
    enabled;
    color;
}
__decorate([
    serializable(MinMaxGradient)
], ColorOverLifetimeModule.prototype, "color", void 0);
export class SizeOverLifetimeModule {
    enabled;
    separateAxes;
    size;
    sizeMultiplier;
    x;
    xMultiplier;
    y;
    yMultiplier;
    z;
    zMultiplier;
    _time = 0;
    _temp = new Vector3();
    evaluate(t01, target, lerpFactor) {
        if (!target)
            target = this._temp;
        if (!this.enabled) {
            target.x = target.y = target.z = 1;
            return target;
        }
        if (!this.separateAxes) {
            const scale = this.size.evaluate(t01, lerpFactor) * this.sizeMultiplier;
            target.x = scale;
            // target.y = scale;
            // target.z = scale;
        }
        else {
            target.x = this.x.evaluate(t01, lerpFactor) * this.xMultiplier;
            target.y = this.y.evaluate(t01, lerpFactor) * this.yMultiplier;
            target.z = this.z.evaluate(t01, lerpFactor) * this.zMultiplier;
        }
        return target;
    }
}
__decorate([
    serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "size", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "x", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "y", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeOverLifetimeModule.prototype, "z", void 0);
export class ShapeModule {
    get type() {
        return ParticleSystemShapeType[this.shapeType];
    }
    initialize(particle) {
        this.getPosition();
        particle.position.copy(this._vector);
    }
    toJSON() {
        return this;
    }
    clone() {
        return new ShapeModule();
    }
    shapeType = ParticleSystemShapeType.Box;
    enabled = true;
    alignToDirection = false;
    angle = 0;
    arc = 360;
    arcSpread;
    arcSpeedMultiplier;
    arcMode;
    boxThickness;
    position;
    rotation;
    _rotation = new Euler();
    scale;
    radius;
    radiusThickness;
    sphericalDirectionAmount;
    randomDirectionAmount;
    randomPositionAmount;
    system;
    _space;
    _worldSpaceMatrix = new Matrix4();
    _worldSpaceMatrixInverse = new Matrix4();
    constructor() {
        // console.log(this);
    }
    update(system, _context, simulationSpace, obj) {
        this.system = system;
        this._space = simulationSpace;
        if (simulationSpace === ParticleSystemSimulationSpace.World) {
            this._worldSpaceMatrix.copy(obj.matrixWorld);
            // set scale to 1
            this._worldSpaceMatrix.elements[0] = 1;
            this._worldSpaceMatrix.elements[5] = 1;
            this._worldSpaceMatrix.elements[10] = 1;
            this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert();
        }
    }
    /** nebula implementations: */
    /** initializer implementation */
    _vector = new Vector3(0, 0, 0);
    _temp = new Vector3(0, 0, 0);
    /** called by nebula on initialize */
    get vector() {
        return this._vector;
    }
    getPosition() {
        if (!this.enabled) {
            this._vector.set(0, 0, 0);
            return;
        }
        const pos = this._temp.copy(this.position);
        const isWorldSpace = this._space === ParticleSystemSimulationSpace.World;
        if (isWorldSpace) {
            pos.applyQuaternion(this.system.worldQuaternion);
        }
        const isRotated = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0;
        if (isRotated) {
            this._rotation.x = Mathf.toRadians(this.rotation.x);
            this._rotation.y = -Mathf.toRadians(this.rotation.y);
            this._rotation.z = -Mathf.toRadians(this.rotation.z);
        }
        let radius = this.radius;
        if (isWorldSpace)
            radius *= this.system.worldScale.x;
        switch (this.shapeType) {
            case ParticleSystemShapeType.Box:
                this._vector.x = Math.random() * this.scale.x - this.scale.x / 2;
                this._vector.y = Math.random() * this.scale.y - this.scale.y / 2;
                this._vector.z = Math.random() * this.scale.z - this.scale.z / 2;
                this._vector.add(pos);
                break;
            case ParticleSystemShapeType.Cone:
                this.randomConePoint(this.position, this.angle, radius, this.radiusThickness, this.arc, this.arcMode, this._vector);
                break;
            case ParticleSystemShapeType.Sphere:
                this.randomSpherePoint(this.position, radius, this.radiusThickness, this.arc, this._vector);
                this._vector.x *= this.scale.x;
                this._vector.y *= this.scale.y;
                this._vector.z *= this.scale.z;
                break;
            case ParticleSystemShapeType.Circle:
                this.randomSpherePoint(this.position, radius, this.radiusThickness, this.arc, this._vector);
                this._vector.x *= this.scale.x;
                this._vector.y *= this.scale.y;
                this._vector.z *= 0;
                break;
            default:
                this._vector.set(0, 0, 0);
                break;
            // case ParticleSystemShapeType.Hemisphere:
            //     randomSpherePoint(this.position.x, this.position.y, this.position.z, this.radius, this.radiusThickness, 180, this._vector);
            //     break;
        }
        this.randomizePosition(this._vector, this.randomPositionAmount);
        if (isRotated)
            this._vector.applyEuler(this._rotation);
        if (this._space === ParticleSystemSimulationSpace.World) {
            this._vector.add(this.system.worldPos);
        }
    }
    _dir = new Vector3();
    getDirection(position) {
        if (!this.enabled) {
            this._dir.set(0, 0, 1);
            return this._dir;
        }
        switch (this.shapeType) {
            case ParticleSystemShapeType.Box:
                this._dir.set(0, 0, 1);
                break;
            case ParticleSystemShapeType.Cone:
                this._dir.set(0, 0, 1);
                // apply cone angle
                // this._dir.applyAxisAngle(new Vector3(0, 1, 0), Mathf.toRadians(this.angle));
                break;
            case ParticleSystemShapeType.Circle:
            case ParticleSystemShapeType.Sphere:
                const rx = position.x;
                const ry = position.y;
                const rz = position.z;
                this._dir.set(rx, ry, rz).sub(this.position);
                break;
            default:
                this._dir.set(0, 0, 1);
                break;
        }
        if (this._space === ParticleSystemSimulationSpace.World) {
            this._dir.applyMatrix4(this._worldSpaceMatrixInverse);
        }
        this._dir.normalize();
        this.spherizeDirection(this._dir, this.sphericalDirectionAmount);
        this.randomizeDirection(this._dir, this.randomDirectionAmount);
        // Gizmos.DrawDirection(position, this._dir, 0xff0000, .5);
        return this._dir;
    }
    static _randomQuat = new Quaternion();
    static _tempVec = new Vector3();
    randomizePosition(pos, amount) {
        if (amount <= 0)
            return;
        const rp = ShapeModule._tempVec;
        rp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
        rp.x *= amount * this.scale.x;
        rp.y *= amount * this.scale.y;
        rp.z *= amount * this.scale.z;
        pos.add(rp);
    }
    randomizeDirection(direction, amount) {
        if (amount === 0)
            return;
        const randomQuat = ShapeModule._randomQuat;
        const tempVec = ShapeModule._tempVec;
        tempVec.set(Math.random() - .5, Math.random() - .5, Math.random() - .5).normalize();
        randomQuat.setFromAxisAngle(tempVec, amount * Math.random() * Math.PI);
        direction.applyQuaternion(randomQuat);
    }
    spherizeDirection(dir, amount) {
        if (amount === 0)
            return;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(1 - Math.random() * 2);
        const x = Math.sin(phi) * Math.cos(theta);
        const y = Math.sin(phi) * Math.sin(theta);
        const z = Math.cos(phi);
        const v = new Vector3(x, y, z);
        dir.lerp(v, amount);
    }
    randomSpherePoint(pos, radius, thickness, arc, vec) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u * (arc / 360);
        const phi = Math.acos(2 * v - 1);
        const r = Mathf.lerp(1, 1 - (Math.pow(1 - Math.random(), Math.PI)), thickness) * (radius);
        const x = pos.x + (-r * Math.sin(phi) * Math.cos(theta));
        const y = pos.y + (r * Math.sin(phi) * Math.sin(theta));
        const z = pos.z + (r * Math.cos(phi));
        vec.x = x;
        vec.y = y;
        vec.z = z;
    }
    _loopTime = 0;
    _loopDirection = 1;
    randomConePoint(pos, _angle, radius, thickness, arc, arcMode, vec) {
        let u = 0;
        let v = 0;
        switch (arcMode) {
            case ParticleSystemShapeMultiModeValue.Random:
                u = Math.random();
                v = Math.random();
                break;
            case ParticleSystemShapeMultiModeValue.PingPong:
                if (this._loopTime > 1)
                    this._loopDirection = -1;
                if (this._loopTime < 0)
                    this._loopDirection = 1;
            // continue with loop 
            case ParticleSystemShapeMultiModeValue.Loop:
                u = .5;
                v = Math.random();
                this._loopTime += this.system.deltaTime * this._loopDirection;
                break;
        }
        let theta = 2 * Math.PI * u * (arc / 360);
        switch (arcMode) {
            case ParticleSystemShapeMultiModeValue.PingPong:
            case ParticleSystemShapeMultiModeValue.Loop:
                theta += Math.PI + .5;
                theta += this._loopTime * Math.PI * 2;
                theta %= Mathf.toRadians(arc);
                break;
        }
        const phi = Math.acos(2 * v - 1);
        const r = Mathf.lerp(1, 1 - (Math.pow(1 - Math.random(), Math.PI)), thickness) * radius;
        const x = pos.x + (-r * Math.sin(phi) * Math.cos(theta));
        const y = pos.y + (r * Math.sin(phi) * Math.sin(theta));
        const z = pos.z;
        vec.x = x * this.scale.x;
        vec.y = y * this.scale.y;
        vec.z = z * this.scale.z;
    }
}
__decorate([
    serializable()
], ShapeModule.prototype, "shapeType", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "alignToDirection", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "angle", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "arc", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "arcSpread", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "arcSpeedMultiplier", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "arcMode", void 0);
__decorate([
    serializable(Vector3)
], ShapeModule.prototype, "boxThickness", void 0);
__decorate([
    serializable(Vector3)
], ShapeModule.prototype, "position", void 0);
__decorate([
    serializable(Vector3)
], ShapeModule.prototype, "rotation", void 0);
__decorate([
    serializable(Vector3)
], ShapeModule.prototype, "scale", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "radius", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "radiusThickness", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "sphericalDirectionAmount", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "randomDirectionAmount", void 0);
__decorate([
    serializable()
], ShapeModule.prototype, "randomPositionAmount", void 0);
import { createNoise4D } from 'simplex-noise';
export class NoiseModule {
    damping;
    enabled;
    frequency;
    octaveCount;
    octaveMultiplier;
    octaveScale;
    positionAmount;
    quality;
    remap;
    remapEnabled;
    remapMultiplier;
    remapX;
    remapXMultiplier;
    remapY;
    remapYMultiplier;
    remapZ;
    remapZMultiplier;
    scrollSpeedMultiplier;
    separateAxes;
    strengthMultiplier;
    strengthX;
    strengthXMultiplier;
    strengthY;
    strengthYMultiplier;
    strengthZ;
    strengthZMultiplier;
    _noise;
    _time = 0;
    update(context) {
        this._time += context.time.deltaTime * this.scrollSpeedMultiplier;
    }
    /** nebula implementations: */
    _temp = new Vector3();
    apply(_index, pos, vel, _deltaTime, age, life) {
        if (!this.enabled)
            return;
        if (!this._noise) {
            this._noise = createNoise4D(() => 0);
        }
        const temp = this._temp.set(pos.x, pos.y, pos.z).multiplyScalar(this.frequency);
        const nx = this._noise(temp.x, temp.y, temp.z, this._time);
        const ny = this._noise(temp.x, temp.y, temp.z, this._time + 1000 * this.frequency);
        const nz = this._noise(temp.x, temp.y, temp.z, this._time + 2000 * this.frequency);
        this._temp.set(nx, ny, nz).normalize();
        const t = age / life;
        let strengthFactor = this.positionAmount.evaluate(t);
        if (!this.separateAxes) {
            if (this.strengthX) {
                strengthFactor *= this.strengthX.evaluate(t) * 1.5;
            }
            // strengthFactor *= this.strengthMultiplier;
            // strengthFactor *= deltaTime;
            this._temp.multiplyScalar(strengthFactor);
        }
        else {
            this._temp.x *= strengthFactor * this.strengthXMultiplier;
            this._temp.y *= strengthFactor * this.strengthYMultiplier;
            this._temp.z *= strengthFactor * this.strengthZMultiplier;
        }
        // this._temp.setLength(strengthFactor * deltaTime);
        vel.x += this._temp.x;
        vel.y += this._temp.y;
        vel.z += this._temp.z;
    }
}
__decorate([
    serializable()
], NoiseModule.prototype, "damping", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "frequency", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "octaveCount", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "octaveMultiplier", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "octaveScale", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "positionAmount", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "quality", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "remap", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "remapEnabled", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "remapMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "remapX", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "remapXMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "remapY", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "remapYMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "remapZ", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "remapZMultiplier", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "scrollSpeedMultiplier", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "separateAxes", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "strengthMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthX", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "strengthXMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthY", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "strengthYMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], NoiseModule.prototype, "strengthZ", void 0);
__decorate([
    serializable()
], NoiseModule.prototype, "strengthZMultiplier", void 0);
export var ParticleSystemTrailMode;
(function (ParticleSystemTrailMode) {
    ParticleSystemTrailMode[ParticleSystemTrailMode["PerParticle"] = 0] = "PerParticle";
    ParticleSystemTrailMode[ParticleSystemTrailMode["Ribbon"] = 1] = "Ribbon";
})(ParticleSystemTrailMode || (ParticleSystemTrailMode = {}));
export var ParticleSystemTrailTextureMode;
(function (ParticleSystemTrailTextureMode) {
    ParticleSystemTrailTextureMode[ParticleSystemTrailTextureMode["Stretch"] = 0] = "Stretch";
    ParticleSystemTrailTextureMode[ParticleSystemTrailTextureMode["Tile"] = 1] = "Tile";
    ParticleSystemTrailTextureMode[ParticleSystemTrailTextureMode["DistributePerSegment"] = 2] = "DistributePerSegment";
    ParticleSystemTrailTextureMode[ParticleSystemTrailTextureMode["RepeatPerSegment"] = 3] = "RepeatPerSegment";
})(ParticleSystemTrailTextureMode || (ParticleSystemTrailTextureMode = {}));
export class TrailModule {
    enabled;
    attachRibbonToTransform = false;
    colorOverLifetime;
    colorOverTrail;
    dieWithParticles = true;
    inheritParticleColor = true;
    lifetime;
    lifetimeMultiplier;
    minVertexDistance = .2;
    mode = ParticleSystemTrailMode.PerParticle;
    ratio = 1;
    ribbonCount = 1;
    shadowBias = 0;
    sizeAffectsLifetime = false;
    sizeAffectsWidth = false;
    splitSubEmitterRibbons = false;
    textureMode = ParticleSystemTrailTextureMode.Stretch;
    widthOverTrail;
    widthOverTrailMultiplier;
    worldSpace = false;
    getWidth(size, _life01, pos01) {
        let res = this.widthOverTrail.evaluate(pos01);
        if (pos01 === 0)
            res = size;
        size *= res;
        return size;
    }
    getColor(color, life01, pos01) {
        const overTrail = this.colorOverTrail.evaluate(pos01);
        const overLife = this.colorOverLifetime.evaluate(life01);
        color.x *= overTrail.r * overLife.r;
        color.y *= overTrail.g * overLife.g;
        color.z *= overTrail.b * overLife.b;
        color.w *= overTrail.alpha * overLife.alpha;
    }
}
__decorate([
    serializable()
], TrailModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "attachRibbonToTransform", void 0);
__decorate([
    serializable(MinMaxGradient)
], TrailModule.prototype, "colorOverLifetime", void 0);
__decorate([
    serializable(MinMaxGradient)
], TrailModule.prototype, "colorOverTrail", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "dieWithParticles", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "inheritParticleColor", void 0);
__decorate([
    serializable(MinMaxCurve)
], TrailModule.prototype, "lifetime", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "lifetimeMultiplier", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "minVertexDistance", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "mode", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "ratio", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "ribbonCount", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "shadowBias", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "sizeAffectsLifetime", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "sizeAffectsWidth", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "splitSubEmitterRibbons", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "textureMode", void 0);
__decorate([
    serializable(MinMaxCurve)
], TrailModule.prototype, "widthOverTrail", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "widthOverTrailMultiplier", void 0);
__decorate([
    serializable()
], TrailModule.prototype, "worldSpace", void 0);
export class VelocityOverLifetimeModule {
    enabled;
    /* orbital settings */
    space = ParticleSystemSimulationSpace.Local;
    speedModifier;
    speedModifierMultiplier;
    x;
    xMultiplier;
    y;
    yMultiplier;
    z;
    zMultiplier;
    _system;
    // private _worldRotation: Quaternion = new Quaternion();
    update(system) {
        this._system = system;
    }
    _temp = new Vector3();
    apply(_index, _pos, vel, _dt, age, life) {
        if (!this.enabled)
            return;
        const t = age / life;
        const speed = this.speedModifier.evaluate(t) * this.speedModifierMultiplier;
        const x = this.x.evaluate(t);
        const y = this.y.evaluate(t);
        const z = this.z.evaluate(t);
        this._temp.set(-x, y, z);
        if (this._system) {
            if (this.space === ParticleSystemSimulationSpace.World) {
                this._temp.applyQuaternion(this._system.worldQuaternionInverted);
            }
            if (this._system.main.simulationSpace === ParticleSystemSimulationSpace.World) {
                this._temp.applyQuaternion(this._system.worldQuaternion);
            }
        }
        vel.x += this._temp.x;
        vel.y += this._temp.y;
        vel.z += this._temp.z;
        vel.x *= speed;
        vel.y *= speed;
        vel.z *= speed;
    }
}
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "space", void 0);
__decorate([
    serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "speedModifier", void 0);
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "speedModifierMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "x", void 0);
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "xMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "y", void 0);
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "yMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], VelocityOverLifetimeModule.prototype, "z", void 0);
__decorate([
    serializable()
], VelocityOverLifetimeModule.prototype, "zMultiplier", void 0);
var ParticleSystemAnimationTimeMode;
(function (ParticleSystemAnimationTimeMode) {
    ParticleSystemAnimationTimeMode[ParticleSystemAnimationTimeMode["Lifetime"] = 0] = "Lifetime";
    ParticleSystemAnimationTimeMode[ParticleSystemAnimationTimeMode["Speed"] = 1] = "Speed";
    ParticleSystemAnimationTimeMode[ParticleSystemAnimationTimeMode["FPS"] = 2] = "FPS";
})(ParticleSystemAnimationTimeMode || (ParticleSystemAnimationTimeMode = {}));
var ParticleSystemAnimationMode;
(function (ParticleSystemAnimationMode) {
    ParticleSystemAnimationMode[ParticleSystemAnimationMode["Grid"] = 0] = "Grid";
    ParticleSystemAnimationMode[ParticleSystemAnimationMode["Sprites"] = 1] = "Sprites";
})(ParticleSystemAnimationMode || (ParticleSystemAnimationMode = {}));
var ParticleSystemAnimationRowMode;
(function (ParticleSystemAnimationRowMode) {
    ParticleSystemAnimationRowMode[ParticleSystemAnimationRowMode["Custom"] = 0] = "Custom";
    ParticleSystemAnimationRowMode[ParticleSystemAnimationRowMode["Random"] = 1] = "Random";
    ParticleSystemAnimationRowMode[ParticleSystemAnimationRowMode["MeshIndex"] = 2] = "MeshIndex";
})(ParticleSystemAnimationRowMode || (ParticleSystemAnimationRowMode = {}));
var ParticleSystemAnimationType;
(function (ParticleSystemAnimationType) {
    ParticleSystemAnimationType[ParticleSystemAnimationType["WholeSheet"] = 0] = "WholeSheet";
    ParticleSystemAnimationType[ParticleSystemAnimationType["SingleRow"] = 1] = "SingleRow";
})(ParticleSystemAnimationType || (ParticleSystemAnimationType = {}));
export class TextureSheetAnimationModule {
    animation;
    enabled;
    cycleCount;
    frameOverTime;
    frameOverTimeMultiplier;
    numTilesX;
    numTilesY;
    startFrame;
    startFrameMultiplier;
    rowMode;
    rowIndex;
    spriteCount;
    timeMode;
    sampleOnceAtStart() {
        if (this.timeMode === ParticleSystemAnimationTimeMode.Lifetime) {
            switch (this.frameOverTime.mode) {
                case ParticleSystemCurveMode.Constant:
                case ParticleSystemCurveMode.TwoConstants:
                    return true;
            }
        }
        return false;
    }
    getStartIndex() {
        if (this.sampleOnceAtStart()) {
            return this.frameOverTime.evaluate(Math.random());
        }
        return 0;
    }
    evaluate(t01) {
        if (this.sampleOnceAtStart()) {
            return undefined;
        }
        return this.getIndex(t01);
    }
    getIndex(t01) {
        const tiles = this.numTilesX * this.numTilesY;
        // let pos = t01 * this.cycleCount;
        let index = this.frameOverTime.evaluate(t01 % 1);
        index *= this.frameOverTimeMultiplier;
        index *= tiles;
        index = index % tiles;
        index = Math.floor(index);
        // console.log(index);
        return index;
    }
}
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "animation", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "cycleCount", void 0);
__decorate([
    serializable(MinMaxCurve)
], TextureSheetAnimationModule.prototype, "frameOverTime", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "frameOverTimeMultiplier", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "numTilesX", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "numTilesY", void 0);
__decorate([
    serializable(MinMaxCurve)
], TextureSheetAnimationModule.prototype, "startFrame", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "startFrameMultiplier", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "rowMode", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "rowIndex", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "spriteCount", void 0);
__decorate([
    serializable()
], TextureSheetAnimationModule.prototype, "timeMode", void 0);
export class RotationOverLifetimeModule {
    enabled;
    separateAxes;
    x;
    xMultiplier;
    y;
    yMultiplier;
    z;
    zMultiplier;
    evaluate(t01) {
        if (!this.enabled)
            return 0;
        if (!this.separateAxes) {
            const rot = this.z.evaluate(t01) * -1;
            return rot;
        }
        return 0;
    }
}
__decorate([
    serializable()
], RotationOverLifetimeModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], RotationOverLifetimeModule.prototype, "separateAxes", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "x", void 0);
__decorate([
    serializable()
], RotationOverLifetimeModule.prototype, "xMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "y", void 0);
__decorate([
    serializable()
], RotationOverLifetimeModule.prototype, "yMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationOverLifetimeModule.prototype, "z", void 0);
__decorate([
    serializable()
], RotationOverLifetimeModule.prototype, "zMultiplier", void 0);
export class RotationBySpeedModule {
    enabled;
    range;
    separateAxes;
    x;
    xMultiplier;
    y;
    yMultiplier;
    z;
    zMultiplier;
    evaluate(_t01, speed) {
        if (!this.enabled)
            return 0;
        if (!this.separateAxes) {
            const t = Mathf.lerp(this.range.x, this.range.y, speed);
            const rot = this.z.evaluate(t) * -1;
            return rot;
        }
        return 0;
    }
}
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "range", void 0);
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "separateAxes", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "x", void 0);
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "xMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "y", void 0);
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "yMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], RotationBySpeedModule.prototype, "z", void 0);
__decorate([
    serializable()
], RotationBySpeedModule.prototype, "zMultiplier", void 0);
export class LimitVelocityOverLifetimeModule {
    enabled;
    dampen;
    drag;
    dragMultiplier;
    limit;
    limitMultiplier;
    separateAxes;
    limitX;
    limitXMultiplier;
    limitY;
    limitYMultiplier;
    limitZ;
    limitZMultiplier;
    multiplyDragByParticleSize = false;
    multiplyDragByParticleVelocity = false;
    space;
    _temp = new Vector3();
    _temp2 = new Vector3();
    apply(_position, baseVelocity, currentVelocity, _size, t01, _dt, _scale) {
        if (!this.enabled)
            return;
        // if (this.separateAxes) {
        //     // const maxX = this.limitX.evaluate(t01) * this.limitXMultiplier;
        //     // const maxY = this.limitY.evaluate(t01) * this.limitYMultiplier;
        //     // const maxZ = this.limitZ.evaluate(t01) * this.limitZMultiplier;
        // }
        // else 
        {
            const max = this.limit.evaluate(t01) * this.limitMultiplier;
            const speed = baseVelocity.length();
            if (speed > max) {
                this._temp.copy(baseVelocity).normalize().multiplyScalar(max);
                let t = this.dampen * .5;
                // t *= scale;
                baseVelocity.x = Mathf.lerp(baseVelocity.x, this._temp.x, t);
                baseVelocity.y = Mathf.lerp(baseVelocity.y, this._temp.y, t);
                baseVelocity.z = Mathf.lerp(baseVelocity.z, this._temp.z, t);
                // this._temp2.set(0, 0, 0);
                currentVelocity.x = Mathf.lerp(currentVelocity.x, this._temp.x, t);
                currentVelocity.y = Mathf.lerp(currentVelocity.y, this._temp.y, t);
                currentVelocity.z = Mathf.lerp(currentVelocity.z, this._temp.z, t);
            }
            // vel.multiplyScalar(dragFactor);
        }
        // vel.x *= 0.3;
        // vel.y *= 0.3;
        // vel.z *= 0.3;
    }
}
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "enabled", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "dampen", void 0);
__decorate([
    serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "drag", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "dragMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limit", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitMultiplier", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "separateAxes", void 0);
__decorate([
    serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitX", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitXMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitY", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitYMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], LimitVelocityOverLifetimeModule.prototype, "limitZ", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "limitZMultiplier", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "multiplyDragByParticleSize", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "multiplyDragByParticleVelocity", void 0);
__decorate([
    serializable()
], LimitVelocityOverLifetimeModule.prototype, "space", void 0);
export var ParticleSystemInheritVelocityMode;
(function (ParticleSystemInheritVelocityMode) {
    ParticleSystemInheritVelocityMode[ParticleSystemInheritVelocityMode["Initial"] = 0] = "Initial";
    ParticleSystemInheritVelocityMode[ParticleSystemInheritVelocityMode["Current"] = 1] = "Current";
})(ParticleSystemInheritVelocityMode || (ParticleSystemInheritVelocityMode = {}));
export class InheritVelocityModule {
    enabled;
    curve;
    curveMultiplier;
    mode;
    system;
    _lastWorldPosition;
    _velocity = new Vector3();
    _temp = new Vector3();
    update(_context) {
        if (!this.enabled)
            return;
        if (this.system.worldspace === false)
            return;
        if (this._lastWorldPosition) {
            this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime);
            this._lastWorldPosition.copy(this.system.worldPos);
        }
        else {
            this._velocity.set(0, 0, 0);
            this._lastWorldPosition = this.system.worldPos.clone();
        }
    }
    // TODO: make work for subsystems
    applyInitial(vel) {
        if (!this.enabled)
            return;
        if (this.system.worldspace === false)
            return;
        if (this.mode === ParticleSystemInheritVelocityMode.Initial) {
            const factor = this.curve.evaluate(Math.random(), Math.random());
            this._temp.copy(this._velocity).multiplyScalar(factor);
            vel.add(this._temp);
        }
    }
    applyCurrent(vel, t01, lerpFactor) {
        if (!this.enabled)
            return;
        if (this.system.worldspace === false)
            return;
        if (this.mode === ParticleSystemInheritVelocityMode.Current) {
            const factor = this.curve.evaluate(t01, lerpFactor);
            this._temp.copy(this._velocity).multiplyScalar(factor);
            vel.add(this._temp);
        }
    }
}
__decorate([
    serializable()
], InheritVelocityModule.prototype, "enabled", void 0);
__decorate([
    serializable(MinMaxCurve)
], InheritVelocityModule.prototype, "curve", void 0);
__decorate([
    serializable()
], InheritVelocityModule.prototype, "curveMultiplier", void 0);
__decorate([
    serializable()
], InheritVelocityModule.prototype, "mode", void 0);
export class SizeBySpeedModule {
    enabled;
    range;
    separateAxes;
    size;
    sizeMultiplier;
    x;
    xMultiplier;
    y;
    yMultiplier;
    z;
    zMultiplier;
    evaluate(vel, _t01, lerpFactor, size) {
        const speed = vel.length();
        const x = Mathf.remap(speed, this.range.x, this.range.y, 0, 1);
        const factor = this.size.evaluate(x, lerpFactor);
        // return size;
        return size * factor;
    }
}
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "enabled", void 0);
__decorate([
    serializable(Vector2)
], SizeBySpeedModule.prototype, "range", void 0);
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "separateAxes", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "size", void 0);
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "sizeMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "x", void 0);
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "xMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "y", void 0);
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "yMultiplier", void 0);
__decorate([
    serializable(MinMaxCurve)
], SizeBySpeedModule.prototype, "z", void 0);
__decorate([
    serializable()
], SizeBySpeedModule.prototype, "zMultiplier", void 0);
export class ColorBySpeedModule {
    enabled;
    range;
    color;
    evaluate(vel, lerpFactor, color) {
        const speed = vel.length();
        const x = Mathf.remap(speed, this.range.x, this.range.y, 0, 1);
        const res = this.color.evaluate(x, lerpFactor);
        color.x *= res.r;
        color.y *= res.g;
        color.z *= res.b;
        color.w *= res.alpha;
    }
}
__decorate([
    serializable()
], ColorBySpeedModule.prototype, "enabled", void 0);
__decorate([
    serializable(Vector2)
], ColorBySpeedModule.prototype, "range", void 0);
__decorate([
    serializable(MinMaxGradient)
], ColorBySpeedModule.prototype, "color", void 0);
//# sourceMappingURL=ParticleSystemModules.js.map