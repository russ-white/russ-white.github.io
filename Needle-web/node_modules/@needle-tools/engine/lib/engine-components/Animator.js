var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import { getParam } from "../engine/engine_utils";
import { AnimatorController } from "./AnimatorController";
import { serializable } from "../engine/engine_serialization_decorator";
import { Mathf } from "../engine/engine_math";
const debug = getParam("debuganimator");
export class Animator extends Behaviour {
    applyRootMotion = false;
    hasRootMotion = false;
    keepAnimatorControllerStateOnDisable = false;
    // set from needle animator extension
    set runtimeAnimatorController(val) {
        if (this._animatorController && this._animatorController.model === val) {
            return;
        }
        if (val) {
            if (!(val instanceof AnimatorController)) {
                if (debug)
                    console.log("Assign animator controller", val, this);
                this._animatorController = new AnimatorController(val);
            }
            else
                this._animatorController = val;
        }
        else
            this._animatorController = null;
    }
    get runtimeAnimatorController() {
        return this._animatorController;
    }
    Play(name, layer = -1, normalizedTime = Number.NEGATIVE_INFINITY, transitionDurationInSec = 0) {
        this.runtimeAnimatorController?.Play(name, layer, normalizedTime, transitionDurationInSec);
    }
    Reset() {
        this._animatorController?.Reset();
    }
    SetBool(name, value) {
        this.runtimeAnimatorController?.SetBool(name, value);
    }
    GetBool(name) {
        return this.runtimeAnimatorController?.GetBool(name) ?? false;
    }
    SetFloat(name, val) {
        this.runtimeAnimatorController?.SetFloat(name, val);
    }
    GetFloat(name) {
        return this.runtimeAnimatorController?.GetFloat(name) ?? -1;
    }
    SetInteger(name, val) {
        this.runtimeAnimatorController?.SetInteger(name, val);
    }
    GetInteger(name) {
        return this.runtimeAnimatorController?.GetInteger(name) ?? -1;
    }
    SetTrigger(name) {
        this.runtimeAnimatorController?.SetTrigger(name);
    }
    ResetTrigger(name) {
        this.runtimeAnimatorController?.ResetTrigger(name);
    }
    IsInTransition() {
        return this.runtimeAnimatorController?.IsInTransition() ?? false;
    }
    SetSpeed(speed) {
        if (speed === this.speed)
            return;
        this.speed = speed;
        this._animatorController?.SetSpeed(speed);
    }
    set minMaxSpeed(minMax) {
        this.speed = Mathf.lerp(minMax.x, minMax.y, Math.random());
    }
    set minMaxOffsetNormalized(minMax) {
        this.normalizedStartOffset = Mathf.lerp(minMax.x, minMax.y, Math.random());
        if (this.runtimeAnimatorController)
            this.runtimeAnimatorController.normalizedStartOffset = this.normalizedStartOffset;
    }
    // set speed(val: number) {
    //     // console.trace(val);
    //     this.SetSpeed(val)
    // }
    speed = 1;
    normalizedStartOffset = 0;
    _animatorController = null;
    awake() {
        if (debug)
            console.log("ANIMATOR", this.name, this);
        if (!this.gameObject)
            return;
        if (this.runtimeAnimatorController) {
            const clone = this.runtimeAnimatorController.clone();
            console.assert(this.runtimeAnimatorController !== clone);
            this.runtimeAnimatorController = clone;
            console.assert(this.runtimeAnimatorController === clone);
            this.runtimeAnimatorController.bind(this);
            this.runtimeAnimatorController.SetSpeed(this.speed);
            this.runtimeAnimatorController.normalizedStartOffset = this.normalizedStartOffset;
        }
    }
    onDisable() {
        if (!this.keepAnimatorControllerStateOnDisable)
            this._animatorController?.Reset();
    }
    onBeforeRender() {
        if (this._animatorController) {
            this._animatorController.update();
        }
    }
}
__decorate([
    serializable()
], Animator.prototype, "applyRootMotion", void 0);
__decorate([
    serializable()
], Animator.prototype, "hasRootMotion", void 0);
__decorate([
    serializable()
], Animator.prototype, "keepAnimatorControllerStateOnDisable", void 0);
__decorate([
    serializable()
], Animator.prototype, "runtimeAnimatorController", null);
//# sourceMappingURL=Animator.js.map