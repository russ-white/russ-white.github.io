var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import * as THREE from "three";
import { serializable, serializeable } from "../engine/engine_serialization_decorator";
import { Material, NearestFilter, Texture, Vector2 } from "three";
import { RGBAColor } from "./js-extensions/RGBAColor";
import { getParam } from "../engine/engine_utils";
const debug = getParam("debugspriterenderer");
class SpriteUtils {
    static cache = {};
    static getOrCreateGeometry(sprite) {
        if (sprite._geometry)
            return sprite._geometry;
        if (sprite.guid) {
            if (SpriteUtils.cache[sprite.guid]) {
                if (debug)
                    console.log("Take cached geometry for sprite", sprite.guid);
                return SpriteUtils.cache[sprite.guid];
            }
        }
        const geo = new THREE.BufferGeometry();
        sprite._geometry = geo;
        const vertices = new Float32Array(sprite.triangles.length * 3);
        const uvs = new Float32Array(sprite.triangles.length * 2);
        for (let i = 0; i < sprite.triangles.length; i += 1) {
            const index = sprite.triangles[i];
            vertices[i * 3] = -sprite.vertices[index].x;
            vertices[i * 3 + 1] = sprite.vertices[index].y;
            vertices[i * 3 + 2] = 0;
            const uv = sprite.uv[index];
            uvs[i * 2] = uv.x;
            uvs[i * 2 + 1] = 1 - uv.y;
        }
        geo.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
        geo.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));
        if (sprite.guid)
            this.cache[sprite.guid] = geo;
        if (debug)
            console.log("Built sprite geometry", sprite, geo);
        return geo;
    }
}
/// <summary>
///   <para>SpriteRenderer draw mode.</para>
/// </summary>
export var SpriteDrawMode;
(function (SpriteDrawMode) {
    /// <summary>
    ///   <para>Displays the full sprite.</para>
    /// </summary>
    SpriteDrawMode[SpriteDrawMode["Simple"] = 0] = "Simple";
    /// <summary>
    ///   <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will scale.</para>
    /// </summary>
    SpriteDrawMode[SpriteDrawMode["Sliced"] = 1] = "Sliced";
    /// <summary>
    ///   <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will tile.</para>
    /// </summary>
    SpriteDrawMode[SpriteDrawMode["Tiled"] = 2] = "Tiled";
})(SpriteDrawMode || (SpriteDrawMode = {}));
class Vec2 {
    x;
    y;
}
export class Sprite {
    guid;
    texture;
    triangles;
    uv;
    vertices;
    _geometry;
}
__decorate([
    serializable()
], Sprite.prototype, "guid", void 0);
__decorate([
    serializable(Texture)
], Sprite.prototype, "texture", void 0);
__decorate([
    serializeable()
], Sprite.prototype, "triangles", void 0);
__decorate([
    serializeable()
], Sprite.prototype, "uv", void 0);
__decorate([
    serializeable()
], Sprite.prototype, "vertices", void 0);
class Slice {
    name;
    offset;
    size;
}
__decorate([
    serializable()
], Slice.prototype, "name", void 0);
__decorate([
    serializable(Vector2)
], Slice.prototype, "offset", void 0);
__decorate([
    serializable(Vector2)
], Slice.prototype, "size", void 0);
const $spriteTexOwner = Symbol("spriteOwner");
export class SpriteSheet {
    sprite;
    index = 0;
    slices;
    update() {
        const index = this.index;
        if (index < 0 || index >= this.slices.length)
            return;
        const slice = this.slices[index];
        let tex = this.sprite?.texture;
        if (!tex)
            return;
        tex.encoding = THREE.sRGBEncoding;
        tex.offset.set(slice.offset.x, slice.offset.y);
        // aniso > 1 makes the texture blurry
        if (tex.minFilter == NearestFilter && tex.magFilter == NearestFilter)
            tex.anisotropy = 1;
        // tex.repeat.set(slice.size.x, -slice.size.y);
        tex.needsUpdate = true;
    }
}
__decorate([
    serializable(Sprite)
], SpriteSheet.prototype, "sprite", void 0);
__decorate([
    serializable()
], SpriteSheet.prototype, "index", void 0);
__decorate([
    serializable(Slice)
], SpriteSheet.prototype, "slices", void 0);
export class SpriteRenderer extends Behaviour {
    drawMode = SpriteDrawMode.Simple;
    size = { x: 1, y: 1 };
    color;
    sharedMaterial;
    get sprite() {
        return this._spriteSheet;
    }
    set sprite(value) {
        if (value === this._spriteSheet)
            return;
        if (typeof value === "number") {
            const index = Math.floor(value);
            ;
            if (index === value)
                this.spriteIndex = index;
            return;
        }
        else {
            this._spriteSheet = value;
            this.updateSprite();
        }
    }
    set spriteIndex(value) {
        if (!this._spriteSheet)
            return;
        this._spriteSheet.index = value;
        this._spriteSheet.update();
    }
    get spriteIndex() {
        return this._spriteSheet?.index ?? 0;
    }
    get spriteFrames() {
        return this._spriteSheet?.slices.length ?? 0;
    }
    _spriteSheet;
    _currentSprite;
    awake() {
        this._currentSprite = undefined;
        if (debug) {
            console.log("Awake", this.name, this, this.sprite?.sprite?.texture);
            if (this.sprite?.sprite?.texture)
                console.log(this.sprite.sprite.texture.minFilter.toString(), this.sprite.sprite.texture.magFilter.toString());
        }
    }
    start() {
        if (!this._currentSprite)
            this.updateSprite();
        else if (this.gameObject)
            this.gameObject.add(this._currentSprite);
    }
    // frame : number = 0;
    // update(){
    //     // const frameRate = 12;
    //     // this.frame += frameRate * this.context.time.deltaTime;
    //     // if(this.frame >= this.spriteFrames)
    //     //     this.frame = 0;
    //     // this.spriteIndex = Math.floor(this.frame);
    //     // console.log(this.spriteIndex);
    // }
    updateSprite() {
        if (!this.__didAwake)
            return;
        if (!this.sprite?.sprite)
            return;
        const sprite = this.sprite.sprite;
        if (!this._currentSprite) {
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            if (!mat)
                return;
            if (this.color) {
                if (!mat["color"])
                    mat["color"] = new THREE.Color();
                mat["color"].copy(this.color);
                mat["opacity"] = this.color.alpha;
            }
            mat.alphaTest = 0.5;
            if (sprite.texture && !mat.wireframe) {
                let tex = sprite.texture;
                // the sprite renderer modifies the textue offset 
                // so we need to clone the texture 
                // if the same texture is used multiple times
                if (tex[$spriteTexOwner] !== undefined && tex[$spriteTexOwner] !== this && this.spriteFrames > 1) {
                    tex = sprite.texture = tex.clone();
                }
                tex[$spriteTexOwner] = this;
                mat["map"] = tex;
            }
            this.sharedMaterial = mat;
            this._currentSprite = new THREE.Mesh(SpriteUtils.getOrCreateGeometry(sprite), mat);
        }
        else {
            this._currentSprite.geometry = SpriteUtils.getOrCreateGeometry(sprite);
            this._currentSprite.material["map"] = sprite.texture;
        }
        if (this._currentSprite.parent !== this.gameObject) {
            if (this.drawMode === SpriteDrawMode.Tiled)
                this._currentSprite.scale.set(this.size.x, this.size.y, 1);
            if (this.gameObject)
                this.gameObject.add(this._currentSprite);
        }
        this._spriteSheet?.update();
    }
}
__decorate([
    serializable()
], SpriteRenderer.prototype, "drawMode", void 0);
__decorate([
    serializable(RGBAColor)
], SpriteRenderer.prototype, "color", void 0);
__decorate([
    serializable(Material)
], SpriteRenderer.prototype, "sharedMaterial", void 0);
__decorate([
    serializable(SpriteSheet)
], SpriteRenderer.prototype, "sprite", null);
//# sourceMappingURL=SpriteRenderer.js.map