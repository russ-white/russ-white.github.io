var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
// import { Camera } from "./Camera";
import { OrbitControls as ThreeOrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { LookAtConstraint } from "./LookAtConstraint";
import * as THREE from "three";
import { getWorldPosition, slerp } from "../engine/engine_three_utils";
import { RaycastOptions } from "../engine/engine_physics";
import { serializable } from "../engine/engine_serialization_decorator";
import { Camera } from "./Camera";
import { getParam, isMobileDevice } from "../engine/engine_utils";
const freeCam = getParam("freecam");
const disabledKeys = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
let defaultKeys = undefined;
export class OrbitControls extends Behaviour {
    get controls() {
        return this._controls;
    }
    get controllerObject() {
        return this._cameraObject;
    }
    onStartInteraction(func) {
        this.controls?.addEventListener("start", func);
    }
    autoRotate = false;
    autoRotateSpeed = 1.0;
    enableKeys = true;
    enableDamping = true;
    dampingFactor = 0.1;
    enableZoom = true;
    minZoom = 0;
    maxZoom = Infinity;
    enablePan = true;
    lookAtConstraint = null;
    lookAtConstraint01 = 1;
    middleClickToFocus = true;
    doubleClickToFocus = true;
    // remove once slerp works correctly
    useSlerp = true;
    debugLog = false;
    targetLerpSpeed = 5;
    _lookTargetPosition;
    _controls = null;
    _cameraObject = null;
    _lerpToTargetPosition = false;
    _lerpCameraToTarget = false;
    _cameraTargetPosition = null;
    _inputs = 0;
    _enableTime = 0; // use to disable double click when double clicking on UI
    _startedListeningToKeyEvents = false;
    awake() {
        this._lookTargetPosition = new THREE.Vector3();
        this._startedListeningToKeyEvents = false;
    }
    onEnable() {
        this._enableTime = this.context.time.time;
        const camGo = GameObject.getComponent(this.gameObject, Camera);
        const cam = camGo?.cam;
        if (!this._controls) {
            console.assert(cam !== null && cam !== undefined, "Missing camera", this);
            if (cam)
                this._cameraObject = cam;
            this._controls = new ThreeOrbitControls(cam, this.context.renderer.domElement);
            if (defaultKeys === undefined)
                defaultKeys = { ...this._controls.keys };
        }
        if (this._controls) {
            if (freeCam) {
                this.enablePan = true;
                this.enableZoom = true;
                this.middleClickToFocus = true;
                if (isMobileDevice())
                    this.doubleClickToFocus = true;
            }
            this._controls.enableDamping = this.enableDamping;
            this._controls.keys = this.enableKeys ? defaultKeys : disabledKeys;
            this._controls.autoRotate = this.autoRotate;
            this._controls.autoRotateSpeed = this.autoRotateSpeed;
            this._controls.enableZoom = this.enableZoom;
            if (cam?.type === "PerspectiveCamera") {
                if (freeCam) {
                    // dont set limits
                }
                else {
                    this._controls.minDistance = this.minZoom;
                    this._controls.maxDistance = this.maxZoom;
                }
            }
            else {
                if (freeCam) {
                    // dont set limits
                }
                else {
                    this._controls.minZoom = this.minZoom;
                    this._controls.maxZoom = this.maxZoom;
                }
            }
            this._controls.dampingFactor = this.dampingFactor;
            this._controls.enablePan = this.enablePan;
            if (!this._startedListeningToKeyEvents) {
                this._startedListeningToKeyEvents = true;
                this._controls.listenToKeyEvents(window.document.body);
            }
        }
    }
    onDisable() {
        if (this._controls) {
            this._controls.enabled = false;
            this._controls.autoRotate = false;
            // this._controls.reset();
        }
    }
    onDestroy() {
        this._controls?.dispose();
    }
    start() {
        if (this._controls) {
            const camGo = GameObject.getComponent(this.gameObject, Camera);
            if (camGo && !this.setFromTargetPosition()) {
                if (this.debugLog)
                    console.log("NO TARGET");
                const forward = new THREE.Vector3(0, 0, -1).applyMatrix4(camGo.cam.matrixWorld);
                this.setTarget(forward, true);
            }
        }
        this.startCoroutine(this.startRaycastDelayed());
    }
    // we need to wait one frame (when starting the scene for the very first time)
    *startRaycastDelayed() {
        yield;
        if (!this.setFromTargetPosition()) {
            const opts = new RaycastOptions();
            // center of the screen:
            opts.screenPoint = new THREE.Vector2(0, 0);
            opts.lineThreshold = 0.1;
            const hits = this.context.physics.raycast(opts);
            if (hits.length > 0) {
                this.setTarget(hits[0].point, true);
            }
        }
    }
    onBeforeRender() {
        if (!this._controls)
            return;
        if (this.context.input.getPointerDown(0) || this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2)) {
            this._inputs += 1;
        }
        if (this._inputs > 0) {
            this.autoRotate = false;
            this._controls.autoRotate = false;
            this._lerpCameraToTarget = false;
            this._lerpToTargetPosition = false;
        }
        this._inputs = 0;
        // if (this.context.input.getPointerLongPress(0) && this.context.time.frameCount % 20 === 0) console.log("LP", this.context.alias);
        let focusAtPointer = (this.middleClickToFocus && this.context.input.getPointerClicked(1));
        focusAtPointer ||= (this.doubleClickToFocus && this.context.input.getPointerDoubleClicked(0) && this.context.time.time - this._enableTime > .3);
        if (focusAtPointer) {
            this.setTargetFromRaycast();
        }
        else if (this.context.input.getPointerDown(0) || this.context.input.mouseWheelChanged) {
            this._lerpToTargetPosition = false;
            this._lerpCameraToTarget = false;
        }
        if (this._lerpToTargetPosition || this._lerpCameraToTarget) {
            const step = this.context.time.deltaTime * this.targetLerpSpeed;
            // confusing naming ahead:
            // _targetObject: the target where the camera moves to
            // targetPosition: the target where the look target moves to
            // lerp the camera
            if (this._lerpCameraToTarget && this._cameraTargetPosition && this._cameraObject) {
                // setWorldPosition(this._cameraObject, this._cameraTargetPosition);
                if (this.useSlerp) {
                    const position = this._cameraObject?.position;
                    slerp(position, this._cameraTargetPosition, step);
                }
                else {
                    this._cameraObject?.position.lerp(this._cameraTargetPosition, step);
                }
                if (this._cameraObject.position.distanceTo(this._cameraTargetPosition) < .0001) {
                    this._lerpCameraToTarget = false;
                }
            }
            // lerp the look target
            if (this._lerpToTargetPosition) {
                this.lerpTarget(this._lookTargetPosition, step);
                if (this._lookTargetPosition.distanceTo(this._controls.target) < .00001) {
                    this._lerpToTargetPosition = false;
                }
            }
        }
        if (!freeCam && this.lookAtConstraint?.locked)
            this.setFromTargetPosition(0, this.lookAtConstraint01);
        if (this._controls && !this.context.isInXR) {
            if (this.debugLog)
                this._controls.domElement = this.context.renderer.domElement;
            this._controls.enabled = true;
            this._controls.update();
        }
    }
    setCameraTarget(position, immediate = false) {
        if (!position)
            this._lerpCameraToTarget = false;
        else {
            this._lerpCameraToTarget = true;
            this._cameraTargetPosition = position.clone();
            if (immediate && this._cameraTargetPosition) {
                this.controllerObject?.position.copy(this._cameraTargetPosition);
            }
        }
    }
    setFromTargetPosition(index = 0, t = 1) {
        if (!this._controls)
            return false;
        const sources = this.lookAtConstraint?.sources;
        if (sources && sources.length > 0) {
            const target = sources[index];
            if (target) {
                target.getWorldPosition(this._lookTargetPosition);
                this.lerpTarget(this._lookTargetPosition, t);
                return true;
            }
        }
        return false;
    }
    setTarget(position = null, immediate = false) {
        if (!this._controls)
            return;
        if (position !== null)
            this._lookTargetPosition.copy(position);
        if (immediate)
            this._controls.target.copy(this._lookTargetPosition);
        else
            this._lerpToTargetPosition = true;
    }
    lerpTarget(position, delta) {
        if (!this._controls)
            return;
        this._controls.target.lerp(position, delta);
    }
    distanceToTarget(position) {
        if (!this._controls)
            return -1;
        return this._controls.target.distanceTo(position);
    }
    setTargetFromRaycast() {
        if (!this.controls)
            return;
        const rc = this.context.physics.raycast();
        for (const hit of rc) {
            if (hit.distance > 0 && GameObject.isActiveInHierarchy(hit.object)) {
                // if (hit.object && hit.object.parent) {
                //     const par: any = hit.object.parent;
                //     if (par.isUI) continue;
                // }
                // console.log("Set target", this.targetPosition, hit.object.name, hit.object);
                this._lookTargetPosition.copy(hit.point);
                this._lerpToTargetPosition = true;
                this._cameraTargetPosition = null;
                if (this.context.mainCamera) {
                    this._lerpCameraToTarget = true;
                    const pos = getWorldPosition(this.context.mainCamera);
                    this._cameraTargetPosition = pos.clone().sub(this.controls.target).add(this._lookTargetPosition);
                    this._cameraObject?.parent?.worldToLocal(this._cameraTargetPosition);
                }
                break;
            }
        }
    }
}
__decorate([
    serializable(LookAtConstraint)
], OrbitControls.prototype, "lookAtConstraint", void 0);
//# sourceMappingURL=OrbitControls.js.map