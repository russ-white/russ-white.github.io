var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { getParam } from "../engine/engine_utils";
import { Behaviour } from "../engine-components/Component";
import { AssetReference } from "../engine/engine_addressables";
import { serializable } from "../engine/engine_serialization_decorator";
import { InstantiateIdProvider } from "../engine/engine_networking_instantiate";
import { InstantiateOptions } from "../engine/engine_gameobject";
const debug = getParam("debugnestedgltf");
export class NestedGltf extends Behaviour {
    filePath;
    _isLoadingOrDoneLoading = false;
    listenToProgress(evt) {
        this.filePath?.beginListenDownload(evt);
    }
    preload() {
        this.filePath?.preload();
    }
    async start() {
        if (this._isLoadingOrDoneLoading)
            return;
        if (debug)
            console.log(this, this.guid);
        const parent = this.gameObject.parent;
        if (parent) {
            this._isLoadingOrDoneLoading = true;
            const opts = new InstantiateOptions();
            // we need to provide stable guids for creating nested gltfs
            opts.idProvider = new InstantiateIdProvider(this.hash(this.guid));
            opts.parent = parent;
            this.gameObject.updateMatrix();
            const matrix = this.gameObject.matrix;
            if (debug)
                console.log("Load nested:", this.filePath?.uri ?? this.filePath, this.gameObject.position);
            const res = await this.filePath?.instantiate?.call(this.filePath, opts);
            if (res) {
                res.matrixAutoUpdate = false;
                res.matrix.identity();
                res.applyMatrix4(matrix);
                res.matrixAutoUpdate = true;
                res.layers.disableAll();
                res.layers.set(this.layer);
            }
            this.destroy();
            if (debug)
                console.log("Nested loading done:", this.filePath?.uri ?? this.filePath, res);
        }
    }
    hash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        return hash;
    }
}
__decorate([
    serializable(AssetReference)
], NestedGltf.prototype, "filePath", void 0);
//# sourceMappingURL=NestedGltf.js.map