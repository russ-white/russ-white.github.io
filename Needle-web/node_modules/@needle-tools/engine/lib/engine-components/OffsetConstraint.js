var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import * as utils from "./../engine/engine_three_utils";
import { Quaternion, Euler, Vector3, Plane } from "three";
import { serializable } from "../engine/engine_serialization_decorator";
export class OffsetConstraint extends Behaviour {
    referenceSpace;
    from;
    affectPosition = false;
    affectRotation = false;
    alignLookDirection = false;
    levelLookDirection = false;
    levelPosition = false;
    positionOffset = new Vector3(0, 0, 0);
    rotationOffset = new Vector3(0, 0, 0);
    offset = new Vector3(0, 0, 0);
    update() {
        if (!this.from)
            return;
        var pos = utils.getWorldPosition(this.from);
        var rot = utils.getWorldQuaternion(this.from);
        this.offset.copy(this.positionOffset);
        const l = this.offset.length();
        if (this.referenceSpace)
            this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(l);
        pos.add(this.offset);
        if (this.levelPosition && this.referenceSpace) {
            const plane = new Plane(this.gameObject.up, 0);
            const refSpacePoint = utils.getWorldPosition(this.referenceSpace);
            plane.setFromNormalAndCoplanarPoint(this.gameObject.up, refSpacePoint);
            const v2 = new Vector3(0, 0, 0);
            plane.projectPoint(pos, v2);
            pos.copy(v2);
        }
        if (this.affectPosition)
            utils.setWorldPosition(this.gameObject, pos);
        const euler = new Euler(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z);
        const quat = new Quaternion().setFromEuler(euler);
        if (this.affectRotation)
            utils.setWorldQuaternion(this.gameObject, rot.multiply(quat));
        let lookDirection = new Vector3();
        this.from.getWorldDirection(lookDirection).multiplyScalar(50);
        if (this.levelLookDirection)
            lookDirection.y = 0;
        if (this.alignLookDirection)
            this.gameObject.lookAt(lookDirection);
    }
}
__decorate([
    serializable(GameObject)
], OffsetConstraint.prototype, "referenceSpace", void 0);
__decorate([
    serializable(GameObject)
], OffsetConstraint.prototype, "from", void 0);
__decorate([
    serializable(Vector3)
], OffsetConstraint.prototype, "positionOffset", void 0);
__decorate([
    serializable(Vector3)
], OffsetConstraint.prototype, "rotationOffset", void 0);
//# sourceMappingURL=OffsetConstraint.js.map