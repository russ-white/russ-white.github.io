var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import * as THREE from "three";
// import { RendererCustomShader } from "./RendererCustomShader";
import { RendererLightmap } from "./RendererLightmap";
import { FrameEvent } from "../engine/engine_setup";
import { getParam } from "../engine/engine_utils";
import { serializable } from "../engine/engine_serialization_decorator";
import { AxesHelper, Object3D, Vector4 } from "three";
import { NEEDLE_render_objects } from "../engine/extensions/NEEDLE_render_objects";
import { NEEDLE_progressive } from "../engine/extensions/NEEDLE_progressive";
import { NEED_UPDATE_INSTANCE_KEY } from "../engine/engine_instancing";
import { debug, ReflectionProbe } from "./ReflectionProbe";
import { setCustomVisibility } from "../engine/js-extensions/Layers";
// for staying compatible with old code
export { InstancingUtil } from "../engine/engine_instancing";
const suppressInstancing = getParam("noInstancing");
const debugLightmap = getParam("debuglightmaps") ? true : false;
const debugInstancing = getParam("debuginstancing");
const debugProgressiveLoading = getParam("debugprogressive");
const suppressProgressiveLoading = getParam("noprogressive");
export var ReflectionProbeUsage;
(function (ReflectionProbeUsage) {
    ReflectionProbeUsage[ReflectionProbeUsage["Off"] = 0] = "Off";
    ReflectionProbeUsage[ReflectionProbeUsage["BlendProbes"] = 1] = "BlendProbes";
    ReflectionProbeUsage[ReflectionProbeUsage["BlendProbesAndSkybox"] = 2] = "BlendProbesAndSkybox";
    ReflectionProbeUsage[ReflectionProbeUsage["Simple"] = 3] = "Simple";
})(ReflectionProbeUsage || (ReflectionProbeUsage = {}));
export class FieldWithDefault {
    path = null;
    asset = null;
    default;
}
export var RenderState;
(function (RenderState) {
    RenderState[RenderState["Both"] = 0] = "Both";
    RenderState[RenderState["Back"] = 1] = "Back";
    RenderState[RenderState["Front"] = 2] = "Front";
})(RenderState || (RenderState = {}));
// support sharedMaterials[index] assigning materials directly to the objects
class SharedMaterialArray {
    _renderer;
    _targets = [];
    is(renderer) {
        return this._renderer === renderer;
    }
    constructor(renderer) {
        this._renderer = renderer;
        const setMaterial = this.setMaterial.bind(this);
        const getMaterial = this.getMaterial.bind(this);
        const go = renderer.gameObject;
        this._targets = [];
        if (go) {
            switch (go.type) {
                case "Group":
                    this._targets = [...go.children];
                    break;
                case "SkinnedMesh":
                case "Mesh":
                    this._targets.push(go);
                    break;
            }
        }
        // this lets us override the javascript indexer, only works in ES6 tho
        // but like that we can use sharedMaterials[index] and it will be assigned to the object directly
        return new Proxy(this, {
            get(target, key) {
                if (typeof key === "string") {
                    const index = parseInt(key);
                    if (!isNaN(index)) {
                        return getMaterial(index);
                    }
                }
                return target[key];
            },
            set(target, key, value) {
                if (typeof key === "string")
                    setMaterial(value, Number.parseInt(key));
                // console.log(target, key, value);
                return Reflect.set(target, key, value);
            }
        });
    }
    get length() {
        return this._targets.length;
    }
    setMaterial(mat, index) {
        if (index < 0 || index >= this._targets.length)
            return;
        const target = this._targets[index];
        if (!target || target["material"] === undefined)
            return;
        target["material"] = mat;
    }
    getMaterial(index) {
        if (index < 0)
            return null;
        const obj = this._targets;
        if (index >= obj.length)
            return null;
        const target = obj[index];
        if (!target)
            return null;
        return target["material"];
    }
}
export class Renderer extends Behaviour {
    /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
     *
     * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
    static setVisible(obj, visible) {
        setCustomVisibility(obj, visible);
    }
    receiveShadows = false;
    shadowCastingMode = ShadowCastingMode.Off;
    lightmapIndex = -1;
    lightmapScaleOffset = new THREE.Vector4(1, 1, 0, 0);
    enableInstancing = undefined;
    renderOrder = undefined;
    allowOcclusionWhenDynamic = true;
    probeAnchor;
    reflectionProbeUsage = ReflectionProbeUsage.Off;
    // custom shader
    // get materialProperties(): Array<MaterialProperties> | undefined {
    //     return this._materialProperties;
    // }
    // set materialProperties(value: Array<MaterialProperties> | undefined) {
    //     this._materialProperties = value;
    // }
    // private customShaderHandler: RendererCustomShader | undefined = undefined;
    // private _materialProperties: Array<MaterialProperties> | undefined = undefined;
    _lightmaps;
    get sharedMesh() {
        if (this.gameObject.type === "Mesh") {
            return this.gameObject;
        }
        else if (this.gameObject.type === "SkinnesMesh") {
            return this.gameObject;
        }
        else if (this.gameObject.type === "Group") {
            return this.gameObject.children[0];
        }
        return undefined;
    }
    get sharedMaterial() {
        return this.sharedMaterials[0];
    }
    set sharedMaterial(mat) {
        this.sharedMaterials[0] = mat;
    }
    /**@deprecated please use sharedMaterial */
    get material() {
        return this.sharedMaterials[0];
    }
    /**@deprecated please use sharedMaterial */
    set material(mat) {
        this.sharedMaterials[0] = mat;
    }
    _sharedMaterials;
    get sharedMaterials() {
        if (!this._sharedMaterials || !this._sharedMaterials.is(this))
            this._sharedMaterials = new SharedMaterialArray(this);
        return this._sharedMaterials;
    }
    static get shouldSuppressInstancing() {
        return suppressInstancing;
    }
    _lightmapTextureOverride = undefined;
    get lightmap() {
        if (this._lightmaps?.length) {
            return this._lightmaps[0].lightmap;
        }
        return null;
    }
    set lightmap(tex) {
        this._lightmapTextureOverride = tex;
        // set undefined to return to default
        if (tex === undefined) {
            tex = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
        }
        if (this._lightmaps?.length) {
            for (const lm of this._lightmaps) {
                lm.lightmap = tex;
            }
        }
    }
    get hasLightmap() {
        const lm = this.lightmap;
        return lm !== null && lm !== undefined;
    }
    allowProgressiveLoading = true;
    awake() {
        this.clearInstancingState();
        if (this.probeAnchor && debug)
            this.probeAnchor.add(new AxesHelper(.2));
        this._reflectionProbe = null;
        const type = this.gameObject.type;
        if (this.isMultiMaterialObject(this.gameObject)) {
            for (const child of this.gameObject.children) {
                this.context.addBeforeRenderListener(child, this.onBeforeRenderThree.bind(this));
                child.layers.mask = this.gameObject.layers.mask;
            }
            if (this.renderOrder !== undefined) {
                // Objects can have nested renderers (e.g. contain 2 meshes and then again another group)
                // or perhaps just regular child objects that have their own renderer component (?)
                let index = 0;
                for (let i = 0; i < this.gameObject.children.length; i++) {
                    const ch = this.gameObject.children[i];
                    // ignore nested groups or objects that have their own renderer (aka their own render order settings)
                    if (ch.type !== "Mesh" || GameObject.getComponent(ch, Renderer))
                        continue;
                    if (this.renderOrder.length <= index) {
                        console.error("Incorrect element count", this);
                        break;
                    }
                    ch.renderOrder = this.renderOrder[index];
                    index += 1;
                }
            }
        }
        // TODO: custom shader with sub materials
        else if (this.isMeshOrSkinnedMesh(this.gameObject)) {
            this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree.bind(this));
            if (this.renderOrder !== undefined && this.renderOrder.length > 0)
                this.gameObject.renderOrder = this.renderOrder[0];
        }
        if (this.lightmapIndex >= 0) {
            // use the override lightmap if its not undefined
            const tex = this._lightmapTextureOverride !== undefined
                ? this._lightmapTextureOverride
                : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
            if (tex) {
                // tex.encoding = THREE.LinearEncoding;
                this._lightmaps = [];
                if (type === "Mesh") {
                    if (!this.gameObject["material"]?.isMeshBasicMaterial === true) {
                        const rm = new RendererLightmap(this.gameObject, this.context); // GameObject.addNewComponent(this.gameObject, RendererLightmap);
                        this._lightmaps.push(rm);
                        rm.init(this.lightmapIndex, this.lightmapScaleOffset, tex, debugLightmap);
                    }
                }
                // for multi materials we need to loop through children 
                // and then we add a lightmap renderer component to each of them
                else if (this.isMultiMaterialObject(this.gameObject)) {
                    for (const child of this.gameObject.children) {
                        if (!child["material"]?.isMeshBasicMaterial) {
                            const rm = new RendererLightmap(child, this.context);
                            this._lightmaps.push(rm);
                            rm.init(this.lightmapIndex, this.lightmapScaleOffset, tex, debugLightmap);
                            // onBeforeRender is not called when the renderer is on a group
                            // this is an issue we probably also need to handle for custom shaders
                            // and need a better solution, but for now this fixes lightmaps for multimaterial objects
                            rm.bindOnBeforeRender();
                        }
                    }
                }
            }
        }
    }
    _isInstancingEnabled = false;
    handles = undefined;
    prevLayers = undefined;
    clearInstancingState() {
        this._isInstancingEnabled = false;
        this.handles = undefined;
        this.prevLayers = undefined;
    }
    setInstancingEnabled(enabled) {
        if (this._isInstancingEnabled === enabled)
            return enabled && (this.handles === undefined || this.handles != null && this.handles.length > 0);
        this._isInstancingEnabled = enabled;
        if (enabled) {
            // if handles is undefined we
            if (this.handles === undefined) {
                this.handles = instancing.setup(this.gameObject, this.context, null, { rend: this, foundMeshes: 0 });
                if (this.handles) {
                    // const disableSelf = this.gameObject.type === "Mesh" || this.gameObject.children?.length === this.handles.length;
                    // this.gameObject.visible = !disableSelf;
                    // this.gameObject.type = "Object3D";
                    // this.gameObject.material = null;
                    // console.log("Using instancing", this.gameObject.visible);
                    // this.gameObject.onBeforeRender = () => console.log("SHOULD NOT BE CALLED");
                    GameObject.markAsInstancedRendered(this.gameObject, true);
                    return true;
                }
            }
            else if (this.handles !== null) {
                for (const handler of this.handles) {
                    handler.updateInstanceMatrix(true);
                    handler.add();
                }
                // this.gameObject.type = "Object3D";
                // this.gameObject.visible = false;
                GameObject.markAsInstancedRendered(this.gameObject, true);
                return true;
            }
        }
        else {
            if (this.handles) {
                for (const handler of this.handles) {
                    handler.remove();
                }
            }
            // this.gameObject.visible = true;
            return true;
        }
        return false;
    }
    start() {
        if (this.enableInstancing && !suppressInstancing) {
            this.setInstancingEnabled(true);
        }
        this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic;
        if (this.isMultiMaterialObject(this.gameObject)) {
            for (let i = 0; i < this.gameObject.children.length; i++) {
                const ch = this.gameObject.children[i];
                ch.frustumCulled = this.allowOcclusionWhenDynamic;
            }
        }
    }
    onEnable() {
        this.setVisibility(true);
        if (this._isInstancingEnabled) {
            this.setInstancingEnabled(true);
        }
        else if (this.enabled) {
            // this.gameObject.visible = true;
            this.applyStencil();
        }
        this.updateReflectionProbe();
    }
    onDisable() {
        this.setVisibility(false);
        if (this.handles && this.handles.length > 0) {
            this.setInstancingEnabled(false);
        }
    }
    onDestroy() {
        this.handles = null;
    }
    applyStencil() {
        NEEDLE_render_objects.applyStencil(this);
    }
    static envmap = null;
    onBeforeRender() {
        if (!this.gameObject) {
            return;
        }
        Renderer.envmap = this.scene.environment;
        const needsUpdate = this.gameObject[NEED_UPDATE_INSTANCE_KEY] === true || this.gameObject.matrixWorldNeedsUpdate;
        if (this.isMultiMaterialObject(this.gameObject) && this.gameObject.children?.length > 0) {
            for (const ch of this.gameObject.children) {
                this.applySettings(ch);
            }
        }
        else {
            this.applySettings(this.gameObject);
        }
        if (needsUpdate) {
            delete this.gameObject[NEED_UPDATE_INSTANCE_KEY];
            if (this.handles) {
                const remove = false; // Math.random() < .01;
                for (let i = this.handles.length - 1; i >= 0; i--) {
                    const h = this.handles[i];
                    if (remove) {
                        h.remove();
                        this.handles.splice(i, 1);
                    }
                    else
                        h.updateInstanceMatrix();
                }
                this.gameObject.matrixWorldNeedsUpdate = false;
            }
        }
        if (this.handles && this.handles.length <= 0) {
            GameObject.markAsInstancedRendered(this.gameObject, false);
        }
        if (this._isInstancingEnabled && this.handles) {
            for (let i = 0; i < this.handles.length; i++) {
                const handle = this.handles[i];
                if (!this.prevLayers)
                    this.prevLayers = [];
                const layer = handle.object.layers.mask;
                if (i >= this.prevLayers.length)
                    this.prevLayers.push(layer);
                else
                    this.prevLayers[i] = layer;
                handle.object.layers.disableAll();
            }
        }
        if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off && this._reflectionProbe) {
            this._reflectionProbe.onSet(this);
        }
    }
    onBeforeRenderThree(_renderer, _scene, _camera, _geometry, material, _group) {
        // progressive load before rendering so we only load textures for visible materials
        if (!suppressProgressiveLoading && material._didRequestTextureLOD === undefined && this.allowProgressiveLoading) {
            material._didRequestTextureLOD = 0;
            if (debugProgressiveLoading) {
                console.log("Load material LOD (with delay)", material.name);
                setTimeout(() => {
                    NEEDLE_progressive.assignTextureLOD(this.context, this.sourceId, material);
                }, 2000);
            }
            else {
                NEEDLE_progressive.assignTextureLOD(this.context, this.sourceId, material);
            }
        }
        if (material.envMapIntensity !== undefined) {
            const factor = this.hasLightmap ? Math.PI : 1;
            material.envMapIntensity = Math.max(0, this.context.rendererData.environmentIntensity / factor);
        }
        // if (this._reflectionProbe?.texture) {
        //     material.envMap = this._reflectionProbe.texture;
        //     // this.context.renderer.prop
        //     // console.log(material.name);
        //     // this.context.renderer.properties.get(material);
        //     // this.context.renderer.properties.update(material, "environment", this._reflectionProbe.texture);
        // }
        //     _scene.environment = null;
        // else _scene.environment = Renderer.envmap;
        // if (!material.envmap)
        //     material.envMap = Renderer.envmap;
        // material.needsUpdate = true;
        // if (!camera) {
        //     let isXRCamera = false;
        //     if (this.context.isInXR) {
        //         // @ts-ignore
        //         const arr = this.context.renderer.xr.getCamera() as ArrayCamera;
        //         if (arr.cameras?.length > 0) {
        //             camera = arr;
        //             isXRCamera = true;
        //         }
        //     }
        // }
        // if (this.customShaderHandler) {
        //     this.customShaderHandler.onBeforeRender(renderer, scene, camera, geometry, material, group);
        // }
        // else if (this.rawShaderHandler) {
        //     for (const h of this.rawShaderHandler) {
        //         h.onBeforeRender(this.gameObject, camera);
        //     }
        // }
        if (this._lightmaps) {
            for (const lm of this._lightmaps) {
                lm.onBeforeRenderThree(material);
            }
        }
    }
    onAfterRender() {
        if (this._isInstancingEnabled && this.handles && this.prevLayers && this.prevLayers.length >= this.handles.length) {
            for (let i = 0; i < this.handles.length; i++) {
                const handle = this.handles[i];
                handle.object.layers.mask = this.prevLayers[i];
            }
        }
        if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off && this._reflectionProbe) {
            this._reflectionProbe.onUnset(this);
        }
    }
    applySettings(go) {
        go.receiveShadow = this.receiveShadows;
        if (this.shadowCastingMode == ShadowCastingMode.On) {
            go.castShadow = true;
        }
        else
            go.castShadow = false;
    }
    _reflectionProbe = null;
    updateReflectionProbe() {
        // handle reflection probe
        this._reflectionProbe = null;
        if (this.reflectionProbeUsage !== ReflectionProbeUsage.Off) {
            if (!this.probeAnchor)
                return;
            // update the reflection probe right before rendering
            // if we do it immediately the reflection probe might not be enabled yet 
            // (since this method is called from onEnable)
            this.startCoroutine(this._updateReflectionProbe(), FrameEvent.OnBeforeRender);
        }
    }
    *_updateReflectionProbe() {
        const obj = this.probeAnchor || this.gameObject;
        const isAnchor = this.probeAnchor ? true : false;
        this._reflectionProbe = ReflectionProbe.get(obj, this.context, isAnchor);
    }
    setVisibility(visible) {
        if (!this.isMultiMaterialObject(this.gameObject)) {
            setCustomVisibility(this.gameObject, visible);
        }
        else {
            for (const ch of this.gameObject.children) {
                if (this.isMeshOrSkinnedMesh(ch)) {
                    setCustomVisibility(ch, visible);
                }
            }
        }
    }
    isMultiMaterialObject(obj) {
        return obj.type === "Group";
    }
    isMeshOrSkinnedMesh(obj) {
        return obj.type === "Mesh" || obj.type === "SkinnedMesh";
    }
}
__decorate([
    serializable()
], Renderer.prototype, "receiveShadows", void 0);
__decorate([
    serializable()
], Renderer.prototype, "shadowCastingMode", void 0);
__decorate([
    serializable()
], Renderer.prototype, "lightmapIndex", void 0);
__decorate([
    serializable(Vector4)
], Renderer.prototype, "lightmapScaleOffset", void 0);
__decorate([
    serializable()
], Renderer.prototype, "enableInstancing", void 0);
__decorate([
    serializable()
], Renderer.prototype, "renderOrder", void 0);
__decorate([
    serializable()
], Renderer.prototype, "allowOcclusionWhenDynamic", void 0);
__decorate([
    serializable(Object3D)
], Renderer.prototype, "probeAnchor", void 0);
__decorate([
    serializable()
], Renderer.prototype, "reflectionProbeUsage", void 0);
export class MeshRenderer extends Renderer {
}
export class SkinnedMeshRenderer extends MeshRenderer {
    awake() {
        super.awake();
        // disable skinned mesh occlusion because of https://github.com/mrdoob/three.js/issues/14499
        this.allowOcclusionWhenDynamic = false;
    }
}
export var ShadowCastingMode;
(function (ShadowCastingMode) {
    /// <summary>
    ///   <para>No shadows are cast from this object.</para>
    /// </summary>
    ShadowCastingMode[ShadowCastingMode["Off"] = 0] = "Off";
    /// <summary>
    ///   <para>Shadows are cast from this object.</para>
    /// </summary>
    ShadowCastingMode[ShadowCastingMode["On"] = 1] = "On";
    /// <summary>
    ///   <para>Shadows are cast from this object, treating it as two-sided.</para>
    /// </summary>
    ShadowCastingMode[ShadowCastingMode["TwoSided"] = 2] = "TwoSided";
    /// <summary>
    ///   <para>Object casts shadows, but is otherwise invisible in the Scene.</para>
    /// </summary>
    ShadowCastingMode[ShadowCastingMode["ShadowsOnly"] = 3] = "ShadowsOnly";
})(ShadowCastingMode || (ShadowCastingMode = {}));
;
class InstancingHandler {
    objs = [];
    setup(obj, context, handlesArray, args, level = 0) {
        const res = this.tryCreateOrAddInstance(obj, context, args);
        if (res) {
            if (handlesArray === null)
                handlesArray = [];
            handlesArray.push(res);
            return handlesArray;
        }
        if (level <= 0 && obj.type !== "Mesh") {
            const nextLevel = level + 1;
            for (const ch of obj.children) {
                handlesArray = this.setup(ch, context, handlesArray, args, nextLevel);
            }
        }
        return handlesArray;
    }
    tryCreateOrAddInstance(obj, context, args) {
        if (obj.type === "Mesh") {
            const index = args.foundMeshes;
            args.foundMeshes += 1;
            if (!args.rend.enableInstancing)
                return null;
            if (index >= args.rend.enableInstancing.length) {
                // console.error("Something is wrong with instance setup", obj, args.rend.enableInstancing, index);
                return null;
            }
            if (!args.rend.enableInstancing[index]) {
                // instancing is disabled
                // console.log("Instancing is disabled", obj);
                return null;
            }
            // instancing is enabled:
            const mesh = obj;
            const geo = mesh.geometry;
            const mat = mesh.material;
            for (const i of this.objs) {
                if (i.isFull())
                    continue;
                if (i.geo === geo && i.material === mat) {
                    return i.addInstance(mesh);
                }
            }
            // console.log("Add new instance mesh renderer", obj);
            const i = new InstancedMeshRenderer(obj.name, geo, mat, 200, context);
            this.objs.push(i);
            return i.addInstance(mesh);
        }
        return null;
    }
}
const instancing = new InstancingHandler();
class InstanceHandle {
    get name() {
        return this.object.name;
    }
    instanceIndex = -1;
    object;
    instancer;
    constructor(instanceIndex, originalObject, instancer) {
        this.instanceIndex = instanceIndex;
        this.object = originalObject;
        this.instancer = instancer;
        GameObject.markAsInstancedRendered(originalObject, true);
        // this.object.visible = false;
    }
    updateInstanceMatrix(updateChildren = false) {
        if (this.instanceIndex < 0)
            return;
        this.object.updateWorldMatrix(true, updateChildren);
        this.instancer.updateInstance(this.object.matrixWorld, this.instanceIndex);
    }
    add() {
        if (this.instanceIndex >= 0)
            return;
        this.instancer.add(this);
    }
    remove() {
        if (this.instanceIndex < 0)
            return;
        this.instancer.remove(this);
    }
}
class InstancedMeshRenderer {
    name = "";
    geo;
    material;
    get currentCount() { return this.inst.count; }
    context;
    inst;
    handles = [];
    maxCount;
    static nullMatrix = new THREE.Matrix4();
    isFull() {
        return this.currentCount >= this.maxCount;
    }
    constructor(name, geo, material, count, context) {
        this.name = name;
        this.geo = geo;
        this.material = material;
        this.context = context;
        this.maxCount = count;
        if (debugInstancing) {
            material = new THREE.MeshBasicMaterial({ color: this.randomColor() });
        }
        this.inst = new THREE.InstancedMesh(geo, material, count);
        this.inst.count = 0;
        this.inst.layers.set(2);
        this.inst.visible = true;
        // this.inst.castShadow = true;
        // this.inst.receiveShadow = true;
        this.context.scene.add(this.inst);
        // console.log(this.inst);
        // this.context.pre_render_callbacks.push(this.onPreRender.bind(this));
        // setInterval(() => {
        //     this.inst.visible = !this.inst.visible;
        // }, 500);
    }
    randomColor() {
        return new THREE.Color(Math.random(), Math.random(), Math.random());
    }
    addInstance(obj) {
        if (this.currentCount >= this.maxCount) {
            console.error("TOO MANY INSTANCES - resize is not yet implemented!", this.inst.count); // todo: make it resize
            return null;
        }
        const handle = new InstanceHandle(-1, obj, this);
        this.add(handle);
        return handle;
    }
    add(handle) {
        if (handle.instanceIndex < 0) {
            handle.instanceIndex = this.currentCount;
            // console.log(handle.instanceIndex, this.currentCount);
            if (handle.instanceIndex >= this.handles.length)
                this.handles.push(handle);
            else
                this.handles[handle.instanceIndex] = handle;
        }
        // console.log("Handle instance");
        handle.object.updateWorldMatrix(true, true);
        this.inst.setMatrixAt(handle.instanceIndex, handle.object.matrixWorld);
        this.inst.instanceMatrix.needsUpdate = true;
        this.inst.count += 1;
        if (this.inst.count > 0)
            this.inst.visible = true;
        // console.log("Added", this.name, this.inst.count, this.handles);
    }
    remove(handle) {
        if (!handle)
            return;
        if (handle.instanceIndex < 0 || handle.instanceIndex >= this.handles.length || this.inst.count <= 0) {
            return;
        }
        if (this.handles[handle.instanceIndex] !== handle) {
            console.error("instance handle is not part of renderer, was it removed before?", handle.instanceIndex, this.name);
            const index = this.handles.indexOf(handle);
            if (index < 0)
                return;
            handle.instanceIndex = index;
        }
        this.handles[handle.instanceIndex] = null;
        this.inst.setMatrixAt(handle.instanceIndex, InstancedMeshRenderer.nullMatrix);
        const removedLastElement = handle.instanceIndex >= this.currentCount - 1;
        // console.log(removedLastElement, this.currentCount, handle.instanceIndex, this.handles);
        if (!removedLastElement && this.currentCount > 0) {
            const lastElement = this.handles[this.currentCount - 1];
            if (lastElement) {
                lastElement.instanceIndex = handle.instanceIndex;
                lastElement.updateInstanceMatrix();
                this.handles[handle.instanceIndex] = lastElement;
                this.handles[this.currentCount - 1] = null;
                // this.inst.setMatrixAt(handle.instanceIndex, lastElement.object.matrixWorld);
                // this.inst.setMatrixAt(this.currentCount - 1, InstancedMeshRenderer.nullMatrix);
            }
        }
        if (this.inst.count > 0)
            this.inst.count -= 1;
        handle.instanceIndex = -1;
        if (this.inst.count <= 0)
            this.inst.visible = false;
        this.inst.instanceMatrix.needsUpdate = true;
    }
    updateInstance(mat, index) {
        this.inst.setMatrixAt(index, mat);
        this.inst.instanceMatrix.needsUpdate = true;
    }
}
//# sourceMappingURL=Renderer.js.map