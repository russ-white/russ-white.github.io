/// <reference types="webxr" />
import * as THREE from "three";
import { Context, FrameEvent } from "../engine/engine_setup";
import { Object3D } from "three";
import { ConstructorConcrete, SourceIdentifier, IComponent, IGameObject, Constructor, GuidsMap, Collision, ICollider } from "../engine/engine_types";
import { InstantiateOptions, HideFlags } from "../engine/engine_gameobject";
declare abstract class GameObject extends THREE.Object3D implements THREE.Object3D, IGameObject {
    guid: string | undefined;
    static setActive(go: THREE.Object3D, active: boolean, processStart?: boolean, setVisible?: boolean): void;
    static isActiveSelf(go: THREE.Object3D): boolean;
    static isActiveInHierarchy(go: THREE.Object3D): boolean;
    static markAsInstancedRendered(go: THREE.Object3D, instanced: boolean): void;
    static isUsingInstancing(instance: THREE.Object3D): boolean;
    static foreachComponent(instance: THREE.Object3D, cb: (comp: Component) => any, recursive?: boolean): any;
    static instantiateSynced(instance: GameObject | Object3D | null, opts: InstantiateOptions): GameObject | null;
    static instantiate(instance: GameObject | Object3D | null, opts?: InstantiateOptions | null): GameObject | null;
    static destroySynced(instance: THREE.Object3D | Component, context?: Context, recursive?: boolean): void;
    static destroy(instance: THREE.Object3D | Component, recursive?: boolean, isRoot?: boolean): void;
    /**
     * Add an object to parent and also ensure all components are being registered
     */
    static add(instance: THREE.Object3D | null | undefined, parent: THREE.Object3D, context?: Context): void;
    /**
     * Removes the object from its parent and deactivates all of its components
     */
    static remove(instance: THREE.Object3D | null | undefined): void;
    static invokeOnChildren(go: THREE.Object3D | null | undefined, functionName: string, ...args: any): void;
    static invoke(go: THREE.Object3D | null | undefined, functionName: string, children?: boolean, ...args: any): void;
    static addNewComponent<T>(go: GameObject | THREE.Object3D, type: ConstructorConcrete<T>, callAwake?: boolean): T;
    static addComponent(go: GameObject, instance: Component): void;
    static removeComponent(instance: Component): Component;
    static getOrAddComponent<T>(go: GameObject | THREE.Object3D, typeName: ConstructorConcrete<T>): T;
    static getComponent<T>(go: GameObject | THREE.Object3D | null, typeName: Constructor<T> | null): T | null;
    static getComponents<T>(go: GameObject | THREE.Object3D | null, typeName: Constructor<T>, arr?: T[] | null): T[];
    static findByGuid(guid: string, hierarchy: THREE.Object3D): GameObject | Component | null | undefined;
    static findObjectOfType<T>(typeName: Constructor<T>, context?: Context | THREE.Object3D, includeInactive?: boolean): T | null;
    static findObjectsOfType<T>(typeName: Constructor<T>, context?: Context | THREE.Object3D): Array<T>;
    static getComponentInChildren<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>): T | null;
    static getComponentsInChildren<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>, arr?: T[] | null): Array<T>;
    static getComponentInParent<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>): T | null;
    static getComponentsInParent<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>, arr?: Array<T> | null): Array<T>;
    static getAllComponents(go: GameObject | THREE.Object3D): Behaviour[];
    static iterateComponents(go: GameObject | THREE.Object3D): Generator<any, void, unknown>;
    abstract activeSelf: boolean;
    abstract addNewComponent<T>(type: Constructor<T>): T | null;
    abstract removeComponent(comp: Component): Component;
    abstract getOrAddComponent<T>(typeName: Constructor<T> | null): T;
    abstract getComponent<T>(type: Constructor<T>): T | null;
    abstract getComponents<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    abstract getComponentInChildren<T>(type: Constructor<T>): T | null;
    abstract getComponentsInChildren<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    abstract getComponentInParent<T>(type: Constructor<T>): T | null;
    abstract getComponentsInParent<T>(type: Constructor<T>, arr?: T[]): Array<T>;
}
declare class Component implements IComponent, EventTarget {
    get isComponent(): boolean;
    private __context;
    get context(): Context;
    set context(context: Context);
    get scene(): THREE.Scene;
    get layer(): number;
    get name(): string;
    private __name?;
    set name(str: string);
    get tag(): string;
    set tag(str: string);
    get static(): any;
    get hideFlags(): HideFlags;
    get activeAndEnabled(): boolean;
    private get __isActive();
    private get __isActiveInHierarchy();
    private set __isActiveInHierarchy(value);
    gameObject: GameObject;
    guid: string;
    sourceId?: SourceIdentifier;
    /** called on a component with a map of old to new guids (e.g. when instantiate generated new guids and e.g. timeline track bindings needs to remape them) */
    resolveGuids?(guidsMap: GuidsMap): void;
    /** called once when the component becomes active for the first time */
    awake(): void;
    /** called every time when the component gets enabled (this is invoked after awake and before start) */
    onEnable(): void;
    onDisable(): void;
    onDestroy(): void;
    /** called when you decorate fields with the @validate() decorator
     * @param field the name of the field that was changed
     */
    onValidate?(prop?: string): void;
    start?(): void;
    earlyUpdate?(): void;
    update?(): void;
    lateUpdate?(): void;
    onBeforeRender?(frame: XRFrame | null): void;
    onAfterRender?(): void;
    onCollisionEnter?(col: Collision): any;
    onCollisionExit?(col: Collision): any;
    onCollisionStay?(col: Collision): any;
    onTriggerEnter?(col: ICollider): any;
    onTriggerStay?(col: ICollider): any;
    onTriggerExit?(col: ICollider): any;
    startCoroutine(routine: Generator, evt?: FrameEvent): Generator;
    stopCoroutine(routine: Generator, evt?: FrameEvent): void;
    get destroyed(): boolean;
    destroy(): void;
    /** @internal */
    protected __didAwake: boolean;
    /** @internal */
    private __didStart;
    /** @internal */
    protected __didEnable: boolean;
    /** @internal */
    protected __isEnabled: boolean | undefined;
    /** @internal */
    private __destroyed;
    /** @internal */
    get __internalDidAwakeAndStart(): boolean;
    /** @internal */
    constructor();
    /** @internal */
    __internalNewInstanceCreated(): void;
    /** @internal */
    __internalAwake(): void;
    /** @internal */
    __internalStart(): void;
    /** @internal */
    __internalEnable(): boolean;
    /** @internal */
    __internalDisable(): void;
    /** @internal */
    __internalDestroy(): void;
    get enabled(): boolean;
    set enabled(val: boolean);
    private static _worldPositionBuffer;
    private static _worldQuaternionBuffer;
    private static _worldEulerBuffer;
    private _worldPosition;
    private _worldQuaternion;
    private static _tempQuaternionBuffer2;
    private _worldEuler;
    private _worldRotation;
    get worldPosition(): THREE.Vector3;
    set worldPosition(val: THREE.Vector3);
    setWorldPosition(x: number, y: number, z: number): void;
    get worldQuaternion(): THREE.Quaternion;
    set worldQuaternion(val: THREE.Quaternion);
    setWorldQuaternion(x: number, y: number, z: number, w: number): void;
    get worldEuler(): THREE.Euler;
    set worldEuler(val: THREE.Euler);
    get worldRotation(): THREE.Vector3;
    set worldRotation(val: THREE.Vector3);
    setWorldRotation(x: number, y: number, z: number, degrees?: boolean): void;
    private static _forward;
    get forward(): THREE.Vector3;
    private _eventListeners;
    addEventListener(type: string, listener: EventListener): void;
    removeEventListener(type: string, listener: EventListener): void;
    dispatchEvent(evt: Event): boolean;
}
declare class Behaviour extends Component {
}
export { Behaviour, Component, GameObject };
