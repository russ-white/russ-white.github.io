var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import { LinearToneMapping, ACESFilmicToneMapping, ReinhardToneMapping } from "three";
import { serializable } from "../engine/engine_serialization_decorator";
import { getParam } from "../engine/engine_utils";
const debug = getParam("debugvolume");
export var TonemappingMode;
(function (TonemappingMode) {
    TonemappingMode[TonemappingMode["None"] = 0] = "None";
    TonemappingMode[TonemappingMode["Neutral"] = 1] = "Neutral";
    TonemappingMode[TonemappingMode["ACES"] = 2] = "ACES";
})(TonemappingMode || (TonemappingMode = {}));
export class VolumeParameter {
    overrideState = false;
    value = 0;
}
export class VolumeComponent {
    active = false;
    parameters;
}
export class ToneMapping extends VolumeComponent {
    mode;
    get isToneMapping() { return true; }
}
export class ColorAdjustments extends VolumeComponent {
    postExposure;
}
// resolve the types:
function resolveComponentType(data) {
    if ("mode" in data)
        return ToneMapping;
    if ("postExposure" in data)
        return ColorAdjustments;
    return VolumeComponent;
}
const volumeKey = Symbol("volumeprofile");
export class VolumeProfile {
    components;
    apply(context) {
        this.onUpdate(context, false);
    }
    unapply(context) {
        this.onUpdate(context, true);
    }
    onUpdate(context, remove) {
        if (!this.components)
            return;
        const renderer = context.renderer;
        const currentProfile = renderer[volumeKey];
        const isActive = currentProfile !== undefined;
        if (remove) {
            // can not remove volume profile that is not active
            if (!isActive)
                return;
        }
        else {
            renderer[volumeKey] = this;
        }
        for (const component of this.components) {
            if (component instanceof ToneMapping) {
                const tonemapping = component;
                if (!component.active || remove) {
                    context.renderer.toneMapping = LinearToneMapping;
                    continue;
                }
                if (debug)
                    console.log("VOLUME:", TonemappingMode[tonemapping.mode?.value ?? 0]);
                const mode = tonemapping.mode;
                const value = mode?.overrideState ? mode?.value : 0;
                switch (value ?? 0) {
                    case TonemappingMode.None:
                        context.renderer.toneMapping = LinearToneMapping;
                        break;
                    case TonemappingMode.Neutral:
                        context.renderer.toneMapping = ReinhardToneMapping;
                        break;
                    case TonemappingMode.ACES:
                        context.renderer.toneMapping = ACESFilmicToneMapping;
                        break;
                }
            }
            else if (component instanceof ColorAdjustments) {
                const colorAdjustments = component;
                // unity range goes from -15..15
                // three.js range goes from 0..inf
                if (debug)
                    console.log(colorAdjustments.postExposure);
                const exposure = Math.pow(2, colorAdjustments.postExposure?.value ?? 0);
                const useExposure = colorAdjustments.postExposure?.overrideState && !remove;
                context.renderer.toneMappingExposure = useExposure ? exposure : 1;
                if (!context.renderer.toneMapping)
                    context.renderer.toneMapping = LinearToneMapping;
            }
        }
    }
}
__decorate([
    serializable([d => resolveComponentType(d), VolumeComponent])
], VolumeProfile.prototype, "components", void 0);
export class Volume extends Behaviour {
    sharedProfile;
    awake() {
        if (debug) {
            console.log(this);
            console.log("Press P to toggle post processing");
            window.addEventListener("keydown", (e) => {
                if (e.key === "p") {
                    console.log("Toggle volume: " + this.name, !this.enabled);
                    this.enabled = !this.enabled;
                }
            });
        }
    }
    onEnable() {
        if (debug)
            console.log("APPLY VOLUME", this);
        this.sharedProfile?.apply(this.context);
    }
    onDisable() {
        this.sharedProfile?.unapply(this.context);
    }
}
__decorate([
    serializable(VolumeProfile)
], Volume.prototype, "sharedProfile", void 0);
//# sourceMappingURL=Volume.js.map