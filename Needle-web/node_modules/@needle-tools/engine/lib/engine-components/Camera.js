var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import * as THREE from "three";
// import { OrbitControls } from "./OrbitControls";
import { getParam } from "../engine/engine_utils";
import { serializable } from "../engine/engine_serialization_decorator";
import { RGBAColor } from "./js-extensions/RGBAColor";
import { PerspectiveCamera, Ray } from "three";
import { XRSessionMode } from "../engine/engine_setup";
import { showBalloonMessage } from "../engine/debug/debug";
import { getWorldPosition } from "../engine/engine_three_utils";
import { Gizmos } from "../engine/engine_gizmos";
export var ClearFlags;
(function (ClearFlags) {
    ClearFlags[ClearFlags["Skybox"] = 1] = "Skybox";
    ClearFlags[ClearFlags["SolidColor"] = 2] = "SolidColor";
    ClearFlags[ClearFlags["Uninitialized"] = 4] = "Uninitialized";
})(ClearFlags || (ClearFlags = {}));
const debug = getParam("debugcam");
const debugscreenpointtoray = getParam("debugscreenpointtoray");
export class Camera extends Behaviour {
    get isCamera() {
        return true;
    }
    get aspect() {
        if (this._cam instanceof PerspectiveCamera)
            return this._cam.aspect;
        return (this.context.domWidth / this.context.domHeight);
    }
    get fieldOfView() { return this._fov; }
    set fieldOfView(val) {
        const changed = this._fov != val;
        this._fov = val;
        if (changed && this._cam) {
            if (this._cam instanceof THREE.PerspectiveCamera) {
                this._cam.fov = this._fov;
                this._cam.updateProjectionMatrix();
            }
        }
    }
    get nearClipPlane() { return this._nearClipPlane; }
    set nearClipPlane(val) {
        const changed = this._nearClipPlane != val;
        this._nearClipPlane = val;
        if (this._cam && changed) {
            this._cam.near = val;
            this._cam.updateProjectionMatrix();
        }
    }
    _nearClipPlane = 0.1;
    get farClipPlane() { return this._farClipPlane; }
    set farClipPlane(val) {
        const changed = this._farClipPlane != val;
        this._farClipPlane = val;
        if (this._cam && changed) {
            this._cam.far = val;
            this._cam.updateProjectionMatrix();
        }
    }
    _farClipPlane = 1000;
    get clearFlags() {
        return this._clearFlags;
    }
    set clearFlags(val) {
        if (val === this._clearFlags)
            return;
        this._clearFlags = val;
        this.applyClearFlagsIfIsActiveCamera();
    }
    orthographic = false;
    orthographicSize = 5;
    ARBackgroundAlpha = 0;
    set cullingMask(val) {
        this._cullingMask = val;
        if (this._cam) {
            this._cam.layers.mask = val;
        }
    }
    get cullingMask() {
        if (this._cam)
            return this._cam.layers.mask;
        return this._cullingMask;
    }
    _cullingMask = 0xffffffff;
    set backgroundBlurriness(val) {
        if (val === this._backgroundBlurriness)
            return;
        if (val === undefined)
            this._backgroundBlurriness = undefined;
        else
            this._backgroundBlurriness = Math.min(Math.max(val, 0), 1);
        this.applyClearFlagsIfIsActiveCamera();
    }
    get backgroundBlurriness() {
        return this._backgroundBlurriness;
    }
    _backgroundBlurriness;
    set backgroundIntensity(val) {
        if (val === this._backgroundIntensity)
            return;
        if (val === undefined)
            this._backgroundIntensity = undefined;
        else
            this._backgroundIntensity = Math.min(Math.max(val, 0), 10);
        this.applyClearFlagsIfIsActiveCamera();
    }
    get backgroundIntensity() {
        return this._backgroundIntensity;
    }
    _backgroundIntensity;
    get backgroundColor() {
        return this._backgroundColor ?? null;
    }
    set backgroundColor(val) {
        if (!val)
            return;
        if (!this._backgroundColor) {
            if (!val.clone)
                return;
            this._backgroundColor = val.clone();
        }
        else
            this._backgroundColor.copy(val);
        // set background color to solid if provided color doesnt have any alpha channel
        if (val.alpha === undefined)
            this._backgroundColor.alpha = 1;
        this.applyClearFlagsIfIsActiveCamera();
    }
    _backgroundColor;
    _fov = 60;
    _cam = null;
    _clearFlags = ClearFlags.SolidColor;
    _skybox;
    get cam() {
        if (this.activeAndEnabled)
            this.buildCamera();
        return this._cam;
    }
    static _origin = new THREE.Vector3();
    static _direction = new THREE.Vector3();
    screenPointToRay(x, y, ray) {
        let cam = this.cam;
        const origin = Camera._origin;
        origin.set(x, y, -1);
        this.context.input.convertScreenspaceToRaycastSpace(origin);
        if (debugscreenpointtoray)
            console.log("screenPointToRay", x.toFixed(2), y.toFixed(2), "now:", origin.x.toFixed(2), origin.y.toFixed(2), "isInXR:" + this.context.isInXR);
        origin.z = -1;
        origin.unproject(cam);
        const dir = Camera._direction.set(origin.x, origin.y, origin.z);
        const camPosition = getWorldPosition(cam);
        dir.sub(camPosition);
        dir.normalize();
        if (ray) {
            ray.set(camPosition, dir);
            return ray;
        }
        else {
            return new Ray(camPosition.clone(), dir.clone());
        }
    }
    awake() {
        if (!this.sourceId) {
            console.warn("Camera has no source - the camera should be exported inside a gltf", this.name);
        }
        if (debugscreenpointtoray) {
            window.addEventListener("pointerdown", evt => {
                const px = evt.clientX;
                const py = evt.clientY;
                console.log("touch", px.toFixed(2), py.toFixed(2));
                const ray = this.screenPointToRay(px, py);
                const randomHex = "#" + Math.floor(Math.random() * 16777215).toString(16);
                Gizmos.DrawRay(ray.origin, ray.direction, randomHex, 10);
            });
        }
    }
    onEnable() {
        if (debug)
            console.log(this);
        this.buildCamera();
        if (this.tag == "MainCamera" || !this.context.mainCameraComponent) {
            this.context.setCurrentCamera(this);
        }
        this.applyClearFlagsIfIsActiveCamera();
    }
    onDisable() {
        this.context.removeCamera(this);
    }
    buildCamera() {
        if (this._cam)
            return;
        const cameraAlreadyCreated = this.gameObject["isCamera"];
        // TODO: when exporting from blender we already have a camera in the children
        let cam = null;
        if (cameraAlreadyCreated) {
            cam = this.gameObject;
            cam?.layers.enableAll();
        }
        else
            cam = this.gameObject.children[0];
        if (cam && cam.isCamera) {
            if (cam.type === "PerspectiveCamera") {
                cam.fov = this._fov;
                cam.near = this._nearClipPlane;
                cam.far = this._farClipPlane;
                cam.updateProjectionMatrix();
            }
        }
        else if (!this.orthographic) {
            cam = new THREE.PerspectiveCamera(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane);
            cam.fov = this.fieldOfView;
        }
        else {
            const factor = this.orthographicSize * 100;
            cam = new THREE.OrthographicCamera(window.innerWidth / -factor, window.innerWidth / factor, window.innerHeight / factor, window.innerHeight / -factor, this._nearClipPlane, this._farClipPlane);
        }
        this._cam = cam;
        this._cam.layers.mask = this._cullingMask;
        if (this.tag == "MainCamera") {
            this.context.setCurrentCamera(this);
        }
    }
    applyClearFlagsIfIsActiveCamera() {
        if (debug)
            showBalloonMessage("apply Camera clear flags");
        if (this._cam && this.context.mainCameraComponent === this) {
            switch (this._clearFlags) {
                case ClearFlags.Skybox:
                    if (this.environmentIsTransparent()) {
                        if (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < 0.001) {
                            this.context.scene.background = null;
                            this.context.renderer.setClearColor(0x000000, 0);
                            return;
                        }
                    }
                    this.enableSkybox();
                    if (this._backgroundBlurriness !== undefined)
                        this.context.scene.backgroundBlurriness = this._backgroundBlurriness;
                    if (this._backgroundIntensity !== undefined)
                        //@ts-ignore
                        this.context.scene.backgroundIntensity = this._backgroundIntensity;
                    break;
                case ClearFlags.SolidColor:
                    if (this._backgroundColor) {
                        let alpha = this._backgroundColor.alpha;
                        // when in WebXR use ar background alpha override or set to 0
                        if (this.environmentIsTransparent()) {
                            alpha = this.ARBackgroundAlpha ?? 0;
                        }
                        this.context.scene.background = null;
                        this.context.renderer.setClearColor(this._backgroundColor, alpha);
                    }
                    break;
                case ClearFlags.Uninitialized:
                    this.context.scene.background = null;
                    this.context.renderer.setClearColor(0x000000, 0);
                    break;
            }
        }
    }
    environmentIsTransparent() {
        const session = this.context.renderer.xr?.getSession();
        if (!session)
            return false;
        const environmentBlendMode = session.environmentBlendMode;
        if (debug)
            showBalloonMessage("Environment blend mode: " + environmentBlendMode + " on " + navigator.userAgent);
        const transparent = environmentBlendMode === 'additive' || environmentBlendMode === 'alpha-blend';
        if (this.context.xrSessionMode === XRSessionMode.ImmersiveAR) {
            if (environmentBlendMode === "opaque") {
                // workaround for Quest 2 returning opaque when it should be alpha-blend
                // check user agent if this is the Quest browser and return true if so
                if (navigator.userAgent?.includes("OculusBrowser")) {
                    return true;
                }
                // Mozilla WebXR Viewer
                else if (navigator.userAgent?.includes("Mozilla") && navigator.userAgent?.includes("Mobile WebXRViewer/v2")) {
                    return true;
                }
            }
        }
        return transparent;
    }
    enableSkybox() {
        if (!this._skybox)
            this._skybox = new CameraSkybox(this);
        this._skybox.enable();
    }
}
__decorate([
    serializable()
], Camera.prototype, "fieldOfView", null);
__decorate([
    serializable()
], Camera.prototype, "nearClipPlane", null);
__decorate([
    serializable()
], Camera.prototype, "farClipPlane", null);
__decorate([
    serializable()
], Camera.prototype, "clearFlags", null);
__decorate([
    serializable()
], Camera.prototype, "orthographic", void 0);
__decorate([
    serializable()
], Camera.prototype, "orthographicSize", void 0);
__decorate([
    serializable()
], Camera.prototype, "ARBackgroundAlpha", void 0);
__decorate([
    serializable()
], Camera.prototype, "cullingMask", null);
__decorate([
    serializable()
], Camera.prototype, "backgroundBlurriness", null);
__decorate([
    serializable()
], Camera.prototype, "backgroundIntensity", null);
__decorate([
    serializable(RGBAColor)
], Camera.prototype, "backgroundColor", null);
class CameraSkybox {
    _camera;
    _skybox;
    get context() { return this._camera?.context; }
    constructor(camera) {
        this._camera = camera;
    }
    enable() {
        this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId);
        if (!this._skybox) {
            console.warn("Failed to load/find skybox texture", this);
        }
        else if (this.context.scene.background !== this._skybox) {
            if (debug)
                console.log("Set skybox", this._camera, this._skybox);
            this._skybox.encoding = THREE.sRGBEncoding;
            this._skybox.mapping = THREE.EquirectangularReflectionMapping;
            this.context.scene.background = this._skybox;
        }
    }
}
//# sourceMappingURL=Camera.js.map