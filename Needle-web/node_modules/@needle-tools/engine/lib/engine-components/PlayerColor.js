import { RoomEvents } from "../engine/engine_networking";
import { Behaviour, GameObject } from "./Component";
import * as THREE from "three";
import { AvatarMarker } from "./WebXRAvatar";
import { WaitForSeconds } from "../engine/engine_coroutine";
export class PlayerColor extends Behaviour {
    awake() {
        // console.log("AWAKE", this.name);
        this.context.connection.beginListen(RoomEvents.JoinedRoom, this.tryAssignColor.bind(this));
    }
    _didAssignPlayerColor = false;
    onEnable() {
        // console.log("ENABLE", this.name);
        if (!this._didAssignPlayerColor)
            this.startCoroutine(this.waitForConnection());
    }
    *waitForConnection() {
        while (!this.destroyed && this.enabled) {
            yield WaitForSeconds(.2);
            if (this.tryAssignColor())
                break;
        }
        // console.log("STOP WAITING", this.name, this.destroyed);
    }
    tryAssignColor() {
        const marker = GameObject.getComponentInParent(this.gameObject, AvatarMarker);
        if (marker && marker.connectionId) {
            this._didAssignPlayerColor = true;
            this.assignUserColor(marker.connectionId);
            return true;
        }
        return false;
    }
    assignUserColor(id) {
        // console.log(this.name, id, this);
        const hash = PlayerColor.hashCode(id);
        const color = PlayerColor.colorFromHashCode(hash);
        if (this.gameObject.type === "Mesh") {
            const mesh = this.gameObject;
            this.assignColor(color, id, mesh);
        }
        else if (this.gameObject.children) {
            for (const ch of this.gameObject.children) {
                const obj = ch;
                if (obj.material && obj.material.color) {
                    this.assignColor(color, id, obj);
                }
            }
        }
    }
    assignColor(col, id, mesh) {
        let mat = mesh.material;
        if (!mat)
            return;
        if (mat["_playerMaterial"] !== id) {
            // console.log("ORIG", mat);
            mat = mat.clone();
            mat["_playerMaterial"] = id;
            mesh.material = mat;
            // console.log("CLONE", mat);
        }
        // else console.log("DONT CLONE", mat);
        mat["color"] = col;
    }
    static hashCode(str) {
        var hash = 0, i, chr;
        if (str.length === 0)
            return hash;
        for (i = 0; i < str.length; i++) {
            chr = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }
    ;
    static colorFromHashCode(hash) {
        const r = (hash & 0xFF0000) >> 16;
        const g = (hash & 0x00FF00) >> 8;
        const b = hash & 0x0000FF;
        return new THREE.Color(r / 255, g / 255, b / 255);
    }
}
//# sourceMappingURL=PlayerColor.js.map