import { RaycastOptions } from "../../engine/engine_physics";
import { Behaviour, GameObject } from "../Component";
import { WebXR } from "../WebXR";
import { ControllerEvents, WebXRController } from "../WebXRController";
import { Context } from "../../engine/engine_setup";
import { OrbitControls } from "../OrbitControls";
import { PointerEventData } from "./PointerEvents";
import { InputEvents, KeyCode } from "../../engine/engine_input";
import { Object3D } from "three";
import { getParam } from "../../engine/engine_utils";
import { UIRaycastUtils } from "./RaycastUtils";
import { $shadowDomOwner } from "./BaseUIComponent";
const debug = getParam("debugeventsystem");
export class EventSystem extends Behaviour {
    static _eventSystemMap = new Map();
    static didSearchEventSystem = false;
    static createIfNoneExists(context) {
        if (!this.didSearchEventSystem) {
            this.didSearchEventSystem = true;
            if (EventSystem.systems.length <= 0) {
                EventSystem.systems.push(...GameObject.findObjectsOfType(EventSystem, context));
            }
        }
        for (const sys of EventSystem.systems) {
            if (sys.context === context)
                return; // exists
        }
        const go = new Object3D();
        GameObject.addNewComponent(go, EventSystem);
        context.scene.add(go);
    }
    static get systems() {
        const context = Context.Current;
        if (!this._eventSystemMap.has(context)) {
            this._eventSystemMap.set(context, []);
        }
        return this._eventSystemMap.get(context);
    }
    //@ts-ignore
    static ensureUpdateMeshUI(instance, context) {
        MeshUIHelper.update(instance, context);
    }
    static markUIDirty(_context) {
        MeshUIHelper.markDirty();
    }
    static get instance() {
        return this.systems[0];
    }
    orbitControl = null;
    orbitControlWasEnabled = false;
    raycaster = [];
    constructor() {
        super();
        EventSystem.systems.push(this);
    }
    onDestroy() {
        EventSystem.systems.splice(EventSystem.systems.indexOf(this), 1);
    }
    start() {
        // const res = GameObject.findObjectsOfType(Raycaster, this.context);
        // if (res)
        //     this.raycaster = [...res];
    }
    register(rc) {
        if (rc && this.raycaster && !this.raycaster.includes(rc))
            this.raycaster?.push(rc);
    }
    unregister(rc) {
        const i = this.raycaster?.indexOf(rc);
        if (i !== undefined && i !== -1) {
            this.raycaster?.splice(i, 1);
        }
    }
    _selectStartFn;
    _selectEndFn;
    _selectUpdateFn;
    onEnable() {
        const grabbed = new Map();
        this._selectStartFn ??= (ctrl, args) => {
            if (!args.grab)
                return;
            MeshUIHelper.resetLastSelected();
            const opts = new PointerEventData();
            opts.inputSource = ctrl;
            opts.isDown = ctrl.selectionDown;
            opts.isUp = ctrl.selectionUp;
            opts.isPressed = ctrl.selectionPressed;
            opts.isClicked = false;
            grabbed.set(ctrl, args.grab);
            if (args.grab && !this.handleEvents(args.grab, opts)) {
                args.grab = null;
            }
            ;
        };
        this._selectEndFn ??= (ctrl, args) => {
            if (!args.grab)
                return;
            const opts = new PointerEventData();
            opts.inputSource = ctrl;
            opts.isDown = ctrl.selectionDown;
            opts.isUp = ctrl.selectionUp;
            opts.isPressed = ctrl.selectionPressed;
            opts.isClicked = ctrl.selectionClick;
            this.handleEvents(args.grab, opts);
            const prevGrabbed = grabbed.get(ctrl);
            grabbed.set(ctrl, null);
            if (prevGrabbed) {
                for (let i = 0; i < this.raisedPointerDownEvents.length; i++) {
                    const comp = this.raisedPointerDownEvents[i];
                    const obj = this.raisedPointerDownObjects[i];
                    if (obj === prevGrabbed && comp) {
                        comp.onPointerUp?.call(comp, opts);
                        this.raisedPointerDownEvents.splice(i, 1);
                        this.raisedPointerDownObjects.splice(i, 1);
                        i--;
                    }
                }
            }
        };
        const controllerRcOpts = new RaycastOptions();
        this._selectUpdateFn ??= (_ctrl) => {
            controllerRcOpts.ray = _ctrl.getRay();
            const rc = this.performRaycast(controllerRcOpts);
            if (!rc)
                return;
            const opts = new PointerEventData();
            opts.inputSource = _ctrl;
            this.handleIntersections(rc, opts);
        };
        WebXRController.addEventListener(ControllerEvents.SelectStart, this._selectStartFn);
        WebXRController.addEventListener(ControllerEvents.SelectEnd, this._selectEndFn);
        WebXRController.addEventListener(ControllerEvents.Update, this._selectUpdateFn);
        this.context.pre_update_callbacks.push(this.onBeforeUpdate.bind(this));
        this.context.input.addEventListener(InputEvents.PointerDown, this.onPointerDown.bind(this));
    }
    onDisable() {
        WebXRController.removeEventListener(ControllerEvents.SelectStart, this._selectStartFn);
        WebXRController.removeEventListener(ControllerEvents.SelectEnd, this._selectEndFn);
        WebXRController.removeEventListener(ControllerEvents.Update, this._selectUpdateFn);
    }
    onPointerDown() {
        this.onBeforeUpdate();
    }
    // doesnt work in dist
    // onBeforeRender() {
    //     MeshUIHelper.update(this.context);
    // }
    lastPointerEvent = null;
    objectsHoveredThisFrame = [];
    objectsHoveredLastFrame = [];
    // todo: these should be listed by input source (e.g. per controller, mouse, touch)
    raisedPointerDownEvents = []; // << keep in sync
    raisedPointerDownObjects = []; // < keep in sync
    _didMove = false;
    onBeforeUpdate() {
        this.objectsHoveredThisFrame.length = 0;
        this.resetMeshUIStates();
        if (WebXR.IsInWebXR)
            return;
        // console.log(this.context.input.isKeyPressed(KeyCode.ALT));
        if (this.context.input.isKeyPressed(KeyCode.ALT)) {
            // console.log("alt pressed");
            return;
        }
        if (!this._didMove) {
            const pos = this.context.input.getPointerPositionRC(0);
            if (pos && pos.x === 0 && pos.y === 0)
                return;
            this._didMove = true;
        }
        const hits = this.performRaycast(null);
        const args = new PointerEventData(this.context.input.getPointerEvent(0));
        args.inputSource = this.context.input;
        args.isClicked = this.context.input.mouseClick;
        args.isDown = this.context.input.mouseDown;
        args.isUp = this.context.input.mouseUp;
        args.isPressed = this.context.input.mousePressed;
        this.lastPointerEvent = args;
        if (!hits)
            return;
        // handle orbit control before handling input events
        // this is just so button events that modify OrbitControls.enabled work
        let orbitControlComponent = null;
        let previousOrbitControlState = null;
        if (this.context.input.mouseDown && this.currentActiveMeshUIComponents.length > 0 && this.context.mainCameraComponent) {
            orbitControlComponent = GameObject.getComponent(this.context.mainCameraComponent.gameObject, OrbitControls) ?? null;
            if (orbitControlComponent) {
                previousOrbitControlState = orbitControlComponent.enabled;
                orbitControlComponent.enabled = false;
            }
        }
        // if (args.isClicked)
        //     console.log(this.guid, ...hits);
        this.handleIntersections(hits, args);
        if (orbitControlComponent) {
            this.orbitControl = orbitControlComponent;
            if (this.orbitControl?.enabled) {
                this.orbitControlWasEnabled = this.orbitControl.enabled;
                this.orbitControl.enabled = false;
            }
            else if (this.orbitControl && !this.context.input.mousePressed) {
                this.orbitControl.enabled = this.orbitControlWasEnabled;
                this.orbitControl = null;
            }
        }
    }
    _tempComponentsArray = [];
    onBeforeRender() {
        if (this.lastPointerEvent)
            this.lastPointerEvent.used = false;
        else
            return;
        if (this.lastPointerEvent.isUp) {
            for (const obj of this.raisedPointerDownEvents) {
                if (obj.onPointerUp) {
                    obj.onPointerUp(this.lastPointerEvent);
                }
            }
            this.raisedPointerDownEvents.length = 0;
            this.raisedPointerDownObjects.length = 0;
        }
        for (const obj of this.objectsHoveredLastFrame) {
            // if the object is not hovered anymore we want to call the exit events
            if (this.objectsHoveredThisFrame.indexOf(obj) < 0) {
                // console.log("LAST", ...this.objectsHoveredLastFrame);
                // console.log("THIS", ...this.objectsHoveredThisFrame);
                this._tempComponentsArray.length = 0;
                const behaviours = GameObject.getComponentsInParent(obj, Behaviour, this._tempComponentsArray);
                this.lastPointerEvent.object = obj;
                for (let i = 0; i < behaviours.length; i++) {
                    const beh = behaviours[i];
                    if (!beh.gameObject || beh.destroyed)
                        continue;
                    const inst = beh;
                    if (inst.onPointerExit) {
                        inst.onPointerExit(this.lastPointerEvent);
                    }
                }
            }
        }
        // swap arrays
        const arr = this.objectsHoveredLastFrame;
        this.objectsHoveredLastFrame = this.objectsHoveredThisFrame;
        this.objectsHoveredThisFrame = arr;
    }
    _sortedHits = [];
    performRaycast(opts) {
        if (!this.raycaster)
            return null;
        this._sortedHits.length = 0;
        for (const rc of this.raycaster) {
            if (!rc.activeAndEnabled)
                continue;
            const res = rc.performRaycast(opts);
            if (res && res.length > 0)
                this._sortedHits.push(...res);
        }
        this._sortedHits.sort((a, b) => {
            return a.distance - b.distance;
        });
        return this._sortedHits;
    }
    handleIntersections(hits, args) {
        if (!hits || hits.length <= 0)
            return false;
        // if (pressed)
        //     console.log(this.context.alias, ...hits);
        hits = this.sortCandidates(hits);
        for (const hit of hits) {
            const { object } = hit;
            if (this.handleEvents(object, args)) {
                return true;
            }
        }
        return false;
    }
    _sortingBuffer = [];
    _noDepthTestingResults = [];
    sortCandidates(hits) {
        // iterate over all hits and filter for nodepth objects and normal hit objects
        // the no-depth objects will be handled first starting from the closest
        // assuming the hits array is sorted by distance (closest > furthest)
        this._sortingBuffer.length = 0;
        this._noDepthTestingResults.length = 0;
        for (let i = 0; i < hits.length; i++) {
            const hit = hits[i];
            const object = hit.object;
            if (object.material) {
                if (object.material["depthTest"] === false) {
                    this._noDepthTestingResults.push(hit);
                    continue;
                }
            }
            this._sortingBuffer.push(hit);
        }
        for (const obj of this._sortingBuffer) {
            this._noDepthTestingResults.push(obj);
        }
        return this._noDepthTestingResults;
    }
    handleEventsArray = [];
    out = {};
    handleEvents(object, args) {
        if (!this.testIsVisible(object)) {
            if (args.isClicked && debug)
                console.log("not allowed", object);
            return false;
        }
        const originalObject = object;
        args.object = object;
        this.lastPointerEvent = args;
        const parent = object.parent;
        let isShadow = false;
        const clicked = args.isClicked ?? false;
        let canvasGroup = null;
        // handle potential shadow dom built from three mesh ui
        if (parent && parent.isUI) {
            const pressedOrClicked = (args.isPressed || args.isClicked) ?? false;
            if (parent[$shadowDomOwner]) {
                const actualGo = parent[$shadowDomOwner].gameObject;
                if (actualGo) {
                    const res = UIRaycastUtils.isInteractable(actualGo, this.out);
                    if (!res)
                        return this.out.canvasGroup?.interactable ?? false;
                    canvasGroup = this.out.canvasGroup ?? null;
                    const handled = this.handleMeshUIIntersection(object, pressedOrClicked);
                    if (!clicked && handled) {
                        // return true;
                    }
                    object = actualGo;
                    isShadow = true;
                }
            }
            if (!isShadow) {
                const obj = this.handleMeshUiObjectWithoutShadowDom(parent, pressedOrClicked);
                if (obj)
                    return true;
            }
        }
        // if (clicked)
        //     console.log(this.context.time.frame, object);
        this.objectsHoveredThisFrame.push(object);
        if (canvasGroup === null || canvasGroup.interactable) {
            const isHovered = this.objectsHoveredLastFrame.indexOf(object) >= 0;
            this.handleEventsArray.length = 0;
            const behaviours = GameObject.getComponentsInParent(object, Behaviour, this.handleEventsArray);
            // console.log(behaviours);
            for (let i = 0; i < behaviours.length; i++) {
                if (args.used)
                    return true;
                if (behaviours[i].destroyed)
                    continue;
                const comp = behaviours[i];
                if (comp.interactable === false)
                    continue;
                if (comp.onPointerEnter) {
                    if (!isHovered) {
                        comp.onPointerEnter(args);
                    }
                }
                if (args.isDown) {
                    if (comp.onPointerDown && !this.raisedPointerDownEvents.includes(comp)) {
                        comp.onPointerDown(args);
                        // need to save this to also send pointer up event
                        this.raisedPointerDownEvents.push(comp);
                        this.raisedPointerDownObjects.push(originalObject);
                    }
                }
                if (args.isUp) {
                    if (comp.onPointerUp) {
                        comp.onPointerUp(args);
                    }
                }
                if (args.isClicked) {
                    if (comp.onPointerClick) {
                        comp.onPointerClick(args);
                    }
                }
            }
        }
        return true;
    }
    handleMeshUiObjectWithoutShadowDom(obj, pressed) {
        if (!obj || !obj.isUI)
            return true;
        const hit = this.handleMeshUIIntersection(obj, pressed);
        return hit;
    }
    currentActiveMeshUIComponents = [];
    handleMeshUIIntersection(meshUiObject, pressed) {
        const res = MeshUIHelper.updateState(meshUiObject, pressed);
        if (res) {
            this.currentActiveMeshUIComponents.push(res);
        }
        return res !== null;
    }
    resetMeshUIStates() {
        if (this.context.input.getPointerPressedCount() > 0) {
            MeshUIHelper.resetLastSelected();
        }
        if (!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)
            return;
        for (let i = 0; i < this.currentActiveMeshUIComponents.length; i++) {
            const comp = this.currentActiveMeshUIComponents[i];
            MeshUIHelper.resetState(comp);
        }
        this.currentActiveMeshUIComponents.length = 0;
    }
    testIsVisible(obj) {
        if (!obj)
            return true;
        if (!GameObject.isActiveSelf(obj))
            return false;
        return this.testIsVisible(obj.parent);
    }
}
class MeshUIHelper {
    static lastSelected = null;
    static lastUpdateFrame = [];
    static needsUpdate = false;
    static markDirty() {
        this.needsUpdate = true;
    }
    static update(threeMeshUI, context) {
        for (const lu of this.lastUpdateFrame) {
            if (lu.context === context) {
                if (context.time.frameCount === lu.frame)
                    return;
                lu.frame = context.time.frameCount;
                if (this.needsUpdate || context.time.frameCount < 30) {
                    this.needsUpdate = false;
                    threeMeshUI.update();
                }
                return;
            }
        }
        this.lastUpdateFrame = [{ context, frame: context.time.frameCount }];
        threeMeshUI.update();
    }
    static updateState(intersect, selectState) {
        let foundBlock = null;
        if (intersect) {
            foundBlock = this.findBlockInParent(intersect);
            // console.log(intersect, "-- found block:", foundBlock)
            if (foundBlock && foundBlock !== this.lastSelected) {
                const interactable = foundBlock["interactable"];
                if (interactable === false)
                    return null;
                if (selectState) {
                    this.lastSelected = foundBlock;
                    //@ts-ignore
                    if (foundBlock.states["pressed"])
                        //@ts-ignore
                        foundBlock.setState("pressed");
                }
                else {
                    //@ts-ignore
                    if (foundBlock.states["hovered"])
                        //@ts-ignore
                        foundBlock.setState("hovered");
                }
                ;
                this.needsUpdate = true;
            }
        }
        // Update non-targeted buttons state
        // MeshUIBaseComponent.objectsWithState.forEach((obj) => {
        //     if ((!intersect || obj !== foundBlock) && obj.isUI) {
        //         obj.setState('idle');
        //     };
        // });
        return foundBlock;
    }
    static resetLastSelected() {
        const last = this.lastSelected;
        if (!last)
            return;
        this.lastSelected = null;
        this.resetState(last);
    }
    static resetState(obj) {
        if (!obj)
            return;
        const interactable = obj["interactable"];
        if (interactable === false) {
            if (obj.states["disabled"])
                obj.setState("disabled");
        }
        else if (obj === this.lastSelected && obj.states["selected"]) {
            obj.setState("selected");
        }
        else
            obj.setState('normal');
        this.needsUpdate = true;
    }
    static findBlockInParent(elem) {
        if (!elem)
            return null;
        if (elem.isBlock) {
            if (Object.keys(elem.states).length > 0)
                return elem;
        }
        return this.findBlockInParent(elem.parent);
    }
}
//# sourceMappingURL=EventSystem.js.map