var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "../Component";
import { FrameEvent } from "../../engine/engine_setup";
import { serializable } from "../../engine/engine_serialization_decorator";
import { Text } from "./Text";
import { getParam } from "../../engine/engine_utils";
import { EventList } from "../EventList";
const debug = getParam("debuginputfield");
export class InputField extends Behaviour {
    get text() {
        return this.textComponent?.text ?? "";
    }
    get isFocused() {
        return InputField.active === this;
    }
    textComponent;
    placeholder;
    onValueChanged;
    onEndEdit;
    static active = null;
    static activeTime = -1;
    static htmlField = null;
    inputEventFn;
    start() {
        if (debug)
            console.log(this.name, this);
    }
    onEnable() {
        if (!InputField.htmlField) {
            InputField.htmlField = document.createElement("input");
            InputField.htmlField.classList.add("ar");
            document.body.appendChild(InputField.htmlField);
        }
        if (!this.inputEventFn) {
            this.inputEventFn = this.onInput.bind(this);
        }
        // InputField.htmlField.addEventListener("input", this.mobileInputEventListener);
        InputField.htmlField.addEventListener("keyup", this.inputEventFn);
        // InputField.htmlField.addEventListener("change", this.inputEventFn);
        if (this.placeholder && this.textComponent?.text.length) {
            GameObject.setActive(this.placeholder.gameObject, false);
        }
    }
    onDisable() {
        // InputField.htmlField?.removeEventListener("input", this.mobileInputEventListener);
        InputField.htmlField?.removeEventListener("keyup", this.inputEventFn);
        // InputField.htmlField?.removeEventListener("change", this.inputEventFn);
        this.onDeselected();
    }
    onPointerClick(_args) {
        if (debug)
            console.log("CLICK", _args, InputField.active);
        InputField.activeTime = this.context.time.time;
        if (InputField.active !== this) {
            this.startCoroutine(this.activeLoop(), FrameEvent.LateUpdate);
        }
        this.selectInputField();
    }
    *activeLoop() {
        this.onSelected();
        while (InputField.active === this) {
            if (this.context.input.getPointerUp(0)) {
                if (this.context.time.time - InputField.activeTime > 0.2) {
                    break;
                }
            }
            this.setTextFromInputField();
            yield;
        }
        this.onDeselected();
    }
    onSelected() {
        if (InputField.active === this)
            return;
        if (debug)
            console.log("Select", this.name, this, InputField.htmlField, this.context.isInXR, this.context.arOverlayElement, this.textComponent?.text, InputField.htmlField?.value);
        InputField.active?.onDeselected();
        InputField.active = this;
        if (this.placeholder)
            GameObject.setActive(this.placeholder.gameObject, false);
        if (InputField.htmlField) {
            InputField.htmlField.value = this.textComponent?.text || "";
            if (debug)
                console.log("set input field value", InputField.htmlField.value);
            if (this.context.isInXR) {
                const overlay = this.context.arOverlayElement;
                if (overlay) {
                    InputField.htmlField.style.width = "0px";
                    InputField.htmlField.style.height = "0px";
                    overlay.append(InputField.htmlField);
                }
            }
            this.selectInputField();
        }
    }
    onDeselected() {
        if (InputField.active !== this)
            return;
        InputField.active = null;
        if (debug)
            console.log("Deselect", this.name, this);
        if (InputField.htmlField) {
            InputField.htmlField.blur();
            document.body.append(InputField.htmlField);
            InputField.htmlField.style.width = "";
            InputField.htmlField.style.height = "";
        }
        if (this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0))
            GameObject.setActive(this.placeholder.gameObject, true);
        this.onEndEdit?.invoke();
    }
    onInput(evt) {
        if (InputField.active !== this)
            return;
        if (debug)
            console.log(evt.code, evt, InputField.htmlField?.value, this.textComponent?.text);
        if (evt.code === "Escape" || evt.code === "Enter") {
            this.onDeselected();
            return;
        }
        if (InputField.htmlField) {
            if (this.textComponent) {
                this.setTextFromInputField();
                if (this.placeholder) {
                    GameObject.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0);
                }
            }
            this.selectInputField();
        }
        // switch (evt.inputType) {
        //     case "insertCompositionText":
        //         this.appendLetter(evt.data?.charAt(evt.data.length - 1) || null);
        //         break;
        //     case "insertText":
        //         console.log(evt.data);
        //         this.appendLetter(evt.data);
        //         break;
        //     case "deleteContentBackward":
        //         this.deleteLetter();
        //         break;
        // }
    }
    setTextFromInputField() {
        if (this.textComponent && InputField.htmlField) {
            if (this.textComponent.text !== InputField.htmlField.value) {
                if (debug)
                    console.log("VALUE CHANGED");
                const oldValue = this.textComponent.text;
                const newValue = InputField.htmlField.value;
                this.onValueChanged?.invoke(newValue, oldValue);
            }
            this.textComponent.text = InputField.htmlField.value;
        }
    }
    selectInputField() {
        if (InputField.htmlField) {
            InputField.htmlField.setSelectionRange(InputField.htmlField.value.length, InputField.htmlField.value.length);
            InputField.htmlField.focus();
        }
    }
}
__decorate([
    serializable(Text)
], InputField.prototype, "textComponent", void 0);
__decorate([
    serializable(Text)
], InputField.prototype, "placeholder", void 0);
__decorate([
    serializable(EventList)
], InputField.prototype, "onValueChanged", void 0);
__decorate([
    serializable(EventList)
], InputField.prototype, "onEndEdit", void 0);
//# sourceMappingURL=InputField.js.map