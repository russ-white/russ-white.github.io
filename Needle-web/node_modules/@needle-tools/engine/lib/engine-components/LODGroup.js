var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import * as THREE from "three";
import { getParam } from "../engine/engine_utils";
import { serializable } from "../engine/engine_serialization_decorator";
import { Vector3 } from "three";
const debug = getParam("debugLODs");
const noLods = getParam("noLODs");
var LODFadeMode;
(function (LODFadeMode) {
    LODFadeMode[LODFadeMode["None"] = 0] = "None";
    LODFadeMode[LODFadeMode["CrossFade"] = 1] = "CrossFade";
    LODFadeMode[LODFadeMode["SpeedTree"] = 2] = "SpeedTree";
})(LODFadeMode || (LODFadeMode = {}));
export class LODModel {
    screenRelativeTransitionHeight;
    distance;
    renderers;
}
__decorate([
    serializable()
], LODModel.prototype, "screenRelativeTransitionHeight", void 0);
__decorate([
    serializable()
], LODModel.prototype, "distance", void 0);
__decorate([
    serializable()
], LODModel.prototype, "renderers", void 0);
class LOD {
    model;
    renderers;
    constructor(group, model) {
        this.model = model;
        this.renderers = [];
        for (const guid of model.renderers) {
            const rend = this.findRenderer(guid, group.gameObject); // GameObject.findByGuid(guid, group.gameObject) as Renderer;
            if (rend && rend.gameObject) {
                this.renderers.push(rend);
            }
            else if (debug) {
                console.warn("Renderer not found: " + guid, group.gameObject);
            }
        }
    }
    findRenderer(guid, go) {
        const res = GameObject.foreachComponent(go, comp => {
            if (comp.guid === guid)
                return comp;
            // explanation: https://github.com/needle-tools/needle-tiny-playground/issues/218#issuecomment-1150234346
            const prototypeGuid = Object.getPrototypeOf(comp)?.guid;
            if (prototypeGuid === guid)
                return comp;
            return null;
        });
        if (res)
            return res;
        for (const ch of go.children) {
            const rend = this.findRenderer(guid, ch);
            if (rend)
                return rend;
        }
        return null;
    }
}
export class LODGroup extends Behaviour {
    fadeMode = LODFadeMode.None;
    localReferencePoint = undefined;
    lodCount = 0;
    size = 0;
    animateCrossFading = false;
    lodModels;
    _lods = [];
    _settings = [];
    // https://threejs.org/docs/#api/en/objects/LOD
    _lodsHandler;
    start() {
        if (noLods)
            return;
        if (this._lodsHandler)
            return;
        if (!this.gameObject)
            return;
        if (debug)
            console.log(this);
        if (this.lodModels && Array.isArray(this.lodModels)) {
            let maxDistance = 0;
            let renderers = [];
            for (const model of this.lodModels) {
                maxDistance = Math.max(model.distance, maxDistance);
                const lod = new LOD(this, model);
                this._lods.push(lod);
                for (const rend of lod.renderers) {
                    if (!renderers.includes(rend))
                        renderers.push(rend);
                }
            }
            this._lodsHandler = new Array();
            for (let i = 0; i < renderers.length; i++) {
                const handler = new THREE.LOD();
                this._lodsHandler.push(handler);
                this.gameObject.add(handler);
            }
            const empty = new THREE.Object3D();
            if (debug)
                console.log(renderers);
            for (let i = 0; i < renderers.length; i++) {
                const rend = renderers[i];
                const handler = this._lodsHandler[i];
                const obj = rend.gameObject;
                let maxDistance = 0;
                let lodDistanceDiff = 0;
                if (debug)
                    console.log(i, obj.name);
                for (const lod of this._lods) {
                    // get object to be lodded, it can be empty
                    let object = null;
                    if (lod.renderers.includes(rend))
                        object = obj;
                    else {
                        object = empty;
                    }
                    if (debug)
                        console.log("add", lod.model.distance, object.name);
                    const dist = lod.model.distance;
                    lodDistanceDiff = dist - maxDistance;
                    maxDistance = Math.max(dist, maxDistance);
                    this.onAddLodLevel(handler, object, dist);
                }
                const cullDistance = maxDistance + lodDistanceDiff;
                if (debug) {
                    console.log("cull", cullDistance);
                }
                this.onAddLodLevel(handler, empty, cullDistance);
            }
        }
    }
    update() {
        if (!this.gameObject)
            return;
        if (!this._lodsHandler)
            return;
        const cam = this.context.mainCamera;
        if (!cam)
            return;
        for (const h of this._lodsHandler) {
            h.update(cam);
        }
    }
    onAddLodLevel(lod, obj, dist) {
        lod.addLevel(obj, dist * this._distanceFactor);
        const setting = { lod: lod, levelIndex: lod.levels.length - 1, distance: dist };
        this._settings.push(setting);
    }
    _distanceFactor = 1;
    distanceFactor(factor) {
        if (factor === this._distanceFactor)
            return;
        this._distanceFactor = factor;
        for (const setting of this._settings) {
            const level = setting.lod.levels[setting.levelIndex];
            level.distance = setting.distance * factor;
        }
    }
}
__decorate([
    serializable(Vector3)
], LODGroup.prototype, "localReferencePoint", void 0);
__decorate([
    serializable(LODModel)
], LODGroup.prototype, "lodModels", void 0);
//# sourceMappingURL=LODGroup.js.map