import { Behaviour } from "./Component";
import * as THREE from "three";
import { Mesh, Object3D, Texture } from "three";
import { IRenderer, ISharedMaterials } from "../engine/engine_types";
export { InstancingUtil } from "../engine/engine_instancing";
export declare enum ReflectionProbeUsage {
    Off = 0,
    BlendProbes = 1,
    BlendProbesAndSkybox = 2,
    Simple = 3
}
export declare class FieldWithDefault {
    path: string | null;
    asset: object | null;
    default: any;
}
export declare enum RenderState {
    Both = 0,
    Back = 1,
    Front = 2
}
declare class SharedMaterialArray implements ISharedMaterials {
    [num: number]: THREE.Material;
    private _renderer;
    private _targets;
    is(renderer: Renderer): boolean;
    constructor(renderer: Renderer);
    get length(): number;
    private setMaterial;
    private getMaterial;
}
export declare class Renderer extends Behaviour implements IRenderer {
    /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
     *
     * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
    static setVisible(obj: Object3D, visible: boolean): void;
    receiveShadows: boolean;
    shadowCastingMode: ShadowCastingMode;
    lightmapIndex: number;
    lightmapScaleOffset: THREE.Vector4;
    enableInstancing: boolean[] | undefined;
    renderOrder: number[] | undefined;
    allowOcclusionWhenDynamic: boolean;
    probeAnchor?: Object3D;
    reflectionProbeUsage: ReflectionProbeUsage;
    private _lightmaps?;
    get sharedMesh(): Mesh | undefined;
    get sharedMaterial(): THREE.Material;
    set sharedMaterial(mat: THREE.Material);
    /**@deprecated please use sharedMaterial */
    get material(): THREE.Material;
    /**@deprecated please use sharedMaterial */
    set material(mat: THREE.Material);
    private _sharedMaterials;
    get sharedMaterials(): SharedMaterialArray;
    static get shouldSuppressInstancing(): string | boolean;
    private _lightmapTextureOverride;
    get lightmap(): Texture | null;
    set lightmap(tex: Texture | null | undefined);
    get hasLightmap(): boolean;
    allowProgressiveLoading: boolean;
    awake(): void;
    private _isInstancingEnabled;
    private handles;
    private prevLayers;
    private clearInstancingState;
    setInstancingEnabled(enabled: boolean): boolean;
    start(): void;
    onEnable(): void;
    onDisable(): void;
    onDestroy(): void;
    applyStencil(): void;
    static envmap: THREE.Texture | null;
    onBeforeRender(): void;
    onBeforeRenderThree(_renderer: any, _scene: any, _camera: any, _geometry: any, material: any, _group: any): void;
    onAfterRender(): void;
    private applySettings;
    private _reflectionProbe;
    private updateReflectionProbe;
    private _updateReflectionProbe;
    private setVisibility;
    private isMultiMaterialObject;
    private isMeshOrSkinnedMesh;
}
export declare class MeshRenderer extends Renderer {
}
export declare class SkinnedMeshRenderer extends MeshRenderer {
    awake(): void;
}
export declare enum ShadowCastingMode {
    Off = 0,
    On = 1,
    TwoSided = 2,
    ShadowsOnly = 3
}
