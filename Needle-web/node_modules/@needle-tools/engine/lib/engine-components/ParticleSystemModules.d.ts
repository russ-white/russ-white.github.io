import { Matrix4, Object3D, Quaternion, Vector3, Vector2, Vector4 } from "three";
import { RGBAColor } from "./js-extensions/RGBAColor";
import { AnimationCurve } from "./AnimationCurve";
import { Vec2, Vec3 } from "../engine/engine_types";
import { Context } from "../engine/engine_setup";
import { EmitterShape, Particle, ShapeJSON } from "three.quarks";
declare type Color4 = {
    r: number;
    g: number;
    b: number;
    a: number;
};
declare type ColorKey = {
    time: number;
    color: Color4;
};
declare type AlphaKey = {
    time: number;
    alpha: number;
};
export interface IParticleSystem {
    get currentParticles(): number;
    get maxParticles(): number;
    get time(): number;
    get deltaTime(): number;
    get duration(): number;
    readonly main: MainModule;
    get container(): Object3D;
    get worldspace(): boolean;
    get worldPos(): Vector3;
    get worldQuaternion(): Quaternion;
    get worldQuaternionInverted(): Quaternion;
    get worldScale(): Vector3;
    get matrixWorld(): Matrix4;
}
export declare enum ParticleSystemRenderMode {
    Billboard = 0,
    Mesh = 4
}
export declare class Gradient {
    alphaKeys: Array<AlphaKey>;
    colorKeys: Array<ColorKey>;
    get duration(): number;
    evaluate(time: number, target: RGBAColor): RGBAColor;
}
export declare enum ParticleSystemCurveMode {
    Constant = 0,
    Curve = 1,
    TwoCurves = 2,
    TwoConstants = 3
}
export declare enum ParticleSystemGradientMode {
    Color = 0,
    Gradient = 1,
    TwoColors = 2,
    TwoGradients = 3,
    RandomColor = 4
}
export declare enum ParticleSystemSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2
}
export declare enum ParticleSystemShapeType {
    Sphere = 0,
    SphereShell = 1,
    Hemisphere = 2,
    HemisphereShell = 3,
    Cone = 4,
    Box = 5,
    Mesh = 6,
    ConeShell = 7,
    ConeVolume = 8,
    ConeVolumeShell = 9,
    Circle = 10,
    CircleEdge = 11,
    SingleSidedEdge = 12,
    MeshRenderer = 13,
    SkinnedMeshRenderer = 14,
    BoxShell = 15,
    BoxEdge = 16,
    Donut = 17,
    Rectangle = 18,
    Sprite = 19,
    SpriteRenderer = 20
}
export declare enum ParticleSystemShapeMultiModeValue {
    Random = 0,
    Loop = 1,
    PingPong = 2,
    BurstSpread = 3
}
export declare class MinMaxCurve {
    mode: ParticleSystemCurveMode;
    constant: number;
    constantMin: number;
    constantMax: number;
    curve?: AnimationCurve;
    curveMin?: AnimationCurve;
    curveMax?: AnimationCurve;
    curveMultiplier?: number;
    evaluate(t01: number, lerpFactor?: number): number;
}
export declare class MinMaxGradient {
    mode: ParticleSystemGradientMode;
    color: RGBAColor;
    colorMin: RGBAColor;
    colorMax: RGBAColor;
    gradient: Gradient;
    gradientMin: Gradient;
    gradientMax: Gradient;
    private static _temp;
    private static _temp2;
    evaluate(t01: number, lerpFactor?: number): RGBAColor;
}
declare type ParticleSystemScalingMode = {
    Hierarchy: number;
    Local: number;
    Shape: number;
};
export declare class MainModule {
    cullingMode: number;
    duration: number;
    emitterVelocityMode: number;
    flipRotation: number;
    gravityModifier: MinMaxCurve;
    gravityModifierMultiplier: number;
    loop: boolean;
    maxParticles: number;
    playOnAwake: boolean;
    prewarm: boolean;
    ringBufferLoopRange: {
        x: number;
        y: number;
    };
    ringBufferMode: boolean;
    scalingMode: ParticleSystemScalingMode;
    simulationSpace: ParticleSystemSimulationSpace;
    simulationSpeed: number;
    startColor: MinMaxGradient;
    startDelay: MinMaxCurve;
    startDelayMultiplier: number;
    startLifetime: MinMaxCurve;
    startLifetimeMultiplier: number;
    startRotation: MinMaxCurve;
    startRotationMultiplier: number;
    startRotation3D: boolean;
    startRotationX: MinMaxCurve;
    startRotationXMultiplier: number;
    startRotationY: MinMaxCurve;
    startRotationYMultiplier: number;
    startRotationZ: MinMaxCurve;
    startRotationZMultiplier: number;
    startSize: MinMaxCurve;
    startSize3D: boolean;
    startSizeMultiplier: number;
    startSizeX: MinMaxCurve;
    startSizeXMultiplier: number;
    startSizeY: MinMaxCurve;
    startSizeYMultiplier: number;
    startSizeZ: MinMaxCurve;
    startSizeZMultiplier: number;
    startSpeed: MinMaxCurve;
    startSpeedMultiplier: number;
    stopAction: number;
    useUnscaledTime: boolean;
}
export declare class ParticleBurst {
    cycleCount: number;
    maxCount: number;
    minCount: number;
    probability: number;
    repeatInterval: number;
    time: number;
    count: {
        constant: number;
        constantMax: number;
        constantMin: number;
        curve?: AnimationCurve;
        curveMax?: AnimationCurve;
        curveMin?: AnimationCurve;
        curveMultiplier?: number;
        mode: ParticleSystemCurveMode;
    };
    private _performed;
    reset(): void;
    run(time: number): number;
}
export declare class EmissionModule {
    enabled: boolean;
    get burstCount(): number;
    bursts: ParticleBurst[];
    rateOverTime: MinMaxCurve;
    rateOverTimeMultiplier: number;
    rateOverDistance: MinMaxCurve;
    rateOverDistanceMultiplier: number;
    /** set from system */
    system: IParticleSystem;
    reset(): void;
    getBurst(): number;
}
export declare class ColorOverLifetimeModule {
    enabled: boolean;
    color: MinMaxGradient;
}
export declare class SizeOverLifetimeModule {
    enabled: boolean;
    separateAxes: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    private _time;
    private _temp;
    evaluate(t01: number, target?: Vec3, lerpFactor?: number): Vec3;
}
export declare class ShapeModule implements EmitterShape {
    get type(): string;
    initialize(particle: Particle): void;
    toJSON(): ShapeJSON;
    clone(): EmitterShape;
    shapeType: ParticleSystemShapeType;
    enabled: boolean;
    alignToDirection: boolean;
    angle: number;
    arc: number;
    arcSpread: number;
    arcSpeedMultiplier: number;
    arcMode: ParticleSystemShapeMultiModeValue;
    boxThickness: Vector3;
    position: Vector3;
    rotation: Vector3;
    private _rotation;
    scale: Vector3;
    radius: number;
    radiusThickness: number;
    sphericalDirectionAmount: number;
    randomDirectionAmount: number;
    randomPositionAmount: number;
    private system;
    private _space?;
    private readonly _worldSpaceMatrix;
    private readonly _worldSpaceMatrixInverse;
    constructor();
    update(system: IParticleSystem, _context: Context, simulationSpace: ParticleSystemSimulationSpace, obj: Object3D): void;
    /** nebula implementations: */
    /** initializer implementation */
    private _vector;
    private _temp;
    /** called by nebula on initialize */
    get vector(): Vector3;
    getPosition(): void;
    private _dir;
    getDirection(position: any): Vector3;
    private static _randomQuat;
    private static _tempVec;
    private randomizePosition;
    private randomizeDirection;
    private spherizeDirection;
    private randomSpherePoint;
    private _loopTime;
    private _loopDirection;
    private randomConePoint;
}
export declare class NoiseModule {
    damping: boolean;
    enabled: boolean;
    frequency: number;
    octaveCount: number;
    octaveMultiplier: number;
    octaveScale: number;
    positionAmount: MinMaxCurve;
    quality: number;
    remap: MinMaxCurve;
    remapEnabled: boolean;
    remapMultiplier: number;
    remapX: MinMaxCurve;
    remapXMultiplier: number;
    remapY: MinMaxCurve;
    remapYMultiplier: number;
    remapZ: MinMaxCurve;
    remapZMultiplier: number;
    scrollSpeedMultiplier: number;
    separateAxes: boolean;
    strengthMultiplier: number;
    strengthX: MinMaxCurve;
    strengthXMultiplier: number;
    strengthY: MinMaxCurve;
    strengthYMultiplier: number;
    strengthZ: MinMaxCurve;
    strengthZMultiplier: number;
    private _noise?;
    private _time;
    update(context: Context): void;
    /** nebula implementations: */
    private _temp;
    apply(_index: number, pos: Vec3, vel: Vec3, _deltaTime: number, age: number, life: number): void;
}
export declare enum ParticleSystemTrailMode {
    PerParticle = 0,
    Ribbon = 1
}
export declare enum ParticleSystemTrailTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3
}
export declare class TrailModule {
    enabled: boolean;
    attachRibbonToTransform: boolean;
    colorOverLifetime: MinMaxGradient;
    colorOverTrail: MinMaxGradient;
    dieWithParticles: boolean;
    inheritParticleColor: boolean;
    lifetime: MinMaxCurve;
    lifetimeMultiplier: number;
    minVertexDistance: number;
    mode: ParticleSystemTrailMode;
    ratio: number;
    ribbonCount: number;
    shadowBias: number;
    sizeAffectsLifetime: boolean;
    sizeAffectsWidth: boolean;
    splitSubEmitterRibbons: boolean;
    textureMode: ParticleSystemTrailTextureMode;
    widthOverTrail: MinMaxCurve;
    widthOverTrailMultiplier: number;
    worldSpace: boolean;
    getWidth(size: number, _life01: number, pos01: number): number;
    getColor(color: Vector4, life01: number, pos01: number): void;
}
export declare class VelocityOverLifetimeModule {
    enabled: boolean;
    space: ParticleSystemSimulationSpace;
    speedModifier: MinMaxCurve;
    speedModifierMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    private _system?;
    update(system: IParticleSystem): void;
    private _temp;
    apply(_index: number, _pos: Vec3, vel: Vec3, _dt: number, age: number, life: number): void;
}
declare enum ParticleSystemAnimationTimeMode {
    Lifetime = 0,
    Speed = 1,
    FPS = 2
}
declare enum ParticleSystemAnimationRowMode {
    Custom = 0,
    Random = 1,
    MeshIndex = 2
}
declare enum ParticleSystemAnimationType {
    WholeSheet = 0,
    SingleRow = 1
}
export declare class TextureSheetAnimationModule {
    animation: ParticleSystemAnimationType;
    enabled: boolean;
    cycleCount: number;
    frameOverTime: MinMaxCurve;
    frameOverTimeMultiplier: number;
    numTilesX: number;
    numTilesY: number;
    startFrame: MinMaxCurve;
    startFrameMultiplier: number;
    rowMode: ParticleSystemAnimationRowMode;
    rowIndex: number;
    spriteCount: number;
    timeMode: ParticleSystemAnimationTimeMode;
    private sampleOnceAtStart;
    getStartIndex(): number;
    evaluate(t01: number): number | undefined;
    private getIndex;
}
export declare class RotationOverLifetimeModule {
    enabled: boolean;
    separateAxes: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    evaluate(t01: number): number;
}
export declare class RotationBySpeedModule {
    enabled: boolean;
    range: Vec2;
    separateAxes: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    evaluate(_t01: number, speed: number): number;
}
export declare class LimitVelocityOverLifetimeModule {
    enabled: boolean;
    dampen: number;
    drag: MinMaxCurve;
    dragMultiplier: number;
    limit: MinMaxCurve;
    limitMultiplier: number;
    separateAxes: boolean;
    limitX: MinMaxCurve;
    limitXMultiplier: number;
    limitY: MinMaxCurve;
    limitYMultiplier: number;
    limitZ: MinMaxCurve;
    limitZMultiplier: number;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;
    space: ParticleSystemSimulationSpace;
    private _temp;
    private _temp2;
    apply(_position: Vec3, baseVelocity: Vector3, currentVelocity: Vector3, _size: number, t01: number, _dt: number, _scale: number): void;
}
export declare enum ParticleSystemInheritVelocityMode {
    Initial = 0,
    Current = 1
}
export declare class InheritVelocityModule {
    enabled: boolean;
    curve: MinMaxCurve;
    curveMultiplier: number;
    mode: ParticleSystemInheritVelocityMode;
    system: IParticleSystem;
    private _lastWorldPosition;
    private _velocity;
    private _temp;
    update(_context: Context): void;
    applyInitial(vel: Vector3): void;
    applyCurrent(vel: Vector3, t01: number, lerpFactor: number): void;
}
export declare class SizeBySpeedModule {
    enabled: boolean;
    range: Vector2;
    separateAxes: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    evaluate(vel: Vector3, _t01: number, lerpFactor: number, size: number): number;
}
export declare class ColorBySpeedModule {
    enabled: boolean;
    range: Vector2;
    color: MinMaxGradient;
    evaluate(vel: Vector3, lerpFactor: number, color: Vector4): void;
}
export {};
