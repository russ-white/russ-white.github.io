import type { NdArray } from 'ndarray';
import { Accessor, Primitive, Texture, Transform, TransformContext } from '@gltf-transform/core';
/**
 * Prepares a function used in an {@link Document.transform} pipeline. Use of this wrapper is
 * optional, and plain functions may be used in transform pipelines just as well. The wrapper is
 * used internally so earlier pipeline stages can detect and optimize based on later stages.
 */
export declare function createTransform(name: string, fn: Transform): Transform;
export declare function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean;
/** Maps pixels from source to target textures, with a per-pixel callback. */
export declare function rewriteTexture(source: Texture, target: Texture, fn: (pixels: NdArray, i: number, j: number) => void): Promise<Texture | null>;
export declare function getGLPrimitiveCount(prim: Primitive): number;
export declare class SetMap<K, V> {
    private _map;
    get size(): number;
    has(k: K): boolean;
    add(k: K, v: V): this;
    get(k: K): Set<V>;
    keys(): Iterable<K>;
}
export declare function formatBytes(bytes: number, decimals?: number): string;
export declare function formatLong(x: number): string;
export declare function formatDelta(a: number, b: number, decimals?: number): string;
export declare function formatDeltaOp(a: number, b: number): string;
/**
 * Returns a list of all unique vertex attributes on the given primitive and
 * its morph targets.
 */
export declare function deepListAttributes(prim: Primitive): Accessor[];
export declare function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void;
export declare function remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number): void;
export declare function createIndices(count: number, maxIndex?: number): Uint16Array | Uint32Array;
