{"version":3,"file":"functions.js","sources":["../src/utils.ts","../src/center.ts","../src/colorspace.ts","../src/dedup.ts","../src/dequantize.ts","../src/draco.ts","../src/inspect.ts","../src/instance.ts","../src/prune.ts","../src/reorder.ts","../src/sort-primitive-weights.ts","../src/quantize.ts","../src/meshopt.ts","../src/metal-rough.ts","../src/unweld.ts","../src/normals.ts","../src/partition.ts","../src/resample.ts","../src/sequence.ts","../src/weld.ts","../src/simplify.ts","../src/list-texture-channels.ts","../src/list-texture-slots.ts","../src/squoosh.ts","../src/tangents.ts","../src/texture-resize.ts","../src/transform-mesh.ts","../src/unlit.ts","../src/unpartition.ts","../src/list-texture-info.ts"],"sourcesContent":["import type { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { Accessor, Primitive, Texture, Transform, TransformContext } from '@gltf-transform/core';\n\n/**\n * Prepares a function used in an {@link Document.transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/** Maps pixels from source to target textures, with a per-pixel callback. */\nexport async function rewriteTexture(\n\tsource: Texture,\n\ttarget: Texture,\n\tfn: (pixels: NdArray, i: number, j: number) => void\n): Promise<Texture | null> {\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(srcImage, source.getMimeType());\n\n\tfor (let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor (let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = await savePixels(pixels, 'image/png');\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices ? indices.getCount() / 2 : position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices ? indices.getCount() / 3 : position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n\nexport function formatBytes(bytes: number, decimals = 2): string {\n\tif (bytes === 0) return '0 Bytes';\n\n\tconst k = 1000;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\nexport function formatLong(x: number): string {\n\treturn x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\nexport function formatDelta(a: number, b: number, decimals = 2): string {\n\tconst prefix = a > b ? '–' : '+';\n\tconst suffix = '%';\n\treturn prefix + ((Math.abs(a - b) / a) * 100).toFixed(decimals) + suffix;\n}\n\nexport function formatDeltaOp(a: number, b: number) {\n\treturn `${formatLong(a)} → ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n */\nexport function deepListAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n\nexport function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void {\n\tprim.swap(src, dst);\n\tfor (const target of prim.listTargets()) {\n\t\ttarget.swap(src, dst);\n\t}\n}\n\nexport function remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number) {\n\tconst elementSize = attribute.getElementSize();\n\tconst srcCount = attribute.getCount();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = srcArray.slice(0, dstCount * elementSize);\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[remap[i] * elementSize + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray);\n}\n\nexport function createIndices(count: number, maxIndex = count): Uint16Array | Uint32Array {\n\tconst array = maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n\tfor (let i = 0; i < array.length; i++) array[i] = i;\n\treturn array;\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { bounds } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = { pivot: 'center' };\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n */\nexport function center(_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = { ...CENTER_DEFAULTS, ..._options } as Required<CenterOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot()\n\t\t\t.listScenes()\n\t\t\t.forEach((scene, index) => {\n\t\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\t\tlet pivot: vec3;\n\t\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\t\tconst bbox = bounds(scene);\n\t\t\t\t\tpivot = [\n\t\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t\t];\n\t\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t\t} else {\n\t\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\t\tif (isAnimated) {\n\t\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\t\tscene.addChild(offsetNode);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\t\tchild.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import type { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'colorspace';\n\n/** Options for the {@link colorspace} function. */\nexport interface ColorspaceOptions {\n\t/** Must be `\"sRGB\"`. Required. */\n\tinputEncoding: string;\n}\n\n/**\n * Vertex color colorspace correction. The glTF format requires vertex colors to be stored\n * as linear values, and this function provides a way to correct vertex colors that are\n * (incorrectly) sRGB.\n */\nexport function colorspace(options: ColorspaceOptions): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" – should be \"sRGB\" or ` +\n\t\t\t\t\t'\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear(c: number): number {\n\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import {\n\tAccessor,\n\tBufferUtils,\n\tDocument,\n\tILogger,\n\tMaterial,\n\tMesh,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tRoot,\n\tTexture,\n\tTransform,\n} from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MESH, PropertyType.TEXTURE, PropertyType.MATERIAL],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n */\nexport const dedup = function (_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = { ...DEDUP_DEFAULTS, ..._options } as Required<DedupOptions>;\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction dedupAccessors(logger: ILogger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\tconst inputAccessors: Set<Accessor> = new Set();\n\tconst outputAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => attributeAccessors.add(accessor));\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices) indicesAccessors.add(indices);\n\t\t});\n\t});\n\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input) inputAccessors.add(input);\n\t\t\tif (output) outputAccessors.add(output);\n\t\t}\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = BufferUtils.toView(a.getArray()!);\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()!))) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size}` + ' attributes.'\n\t);\n\n\tconst duplicateInputs = detectDuplicates(Array.from(inputAccessors));\n\tconst duplicateOutputs = detectDuplicates(Array.from(outputAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateInputs.size + duplicateOutputs.size} duplicates among` +\n\t\t\t` ${inputAccessors.size + outputAccessors.size} animation accessors.`\n\t);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicateInputs.has(input)) {\n\t\t\t\tsampler.swap(input, duplicateInputs.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicateOutputs.has(output)) {\n\t\t\t\tsampler.swap(output, duplicateOutputs.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\tArray.from(duplicateInputs.keys()).forEach((input) => input.dispose());\n\tArray.from(duplicateOutputs.keys()).forEach((output) => output.dispose());\n}\n\nfunction dedupMeshes(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor | Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tconst meshKey = srcKeyItems.join(';');\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${numMeshes - uniqueMeshes.size} duplicates among ${numMeshes} meshes.`);\n}\n\nfunction dedupImages(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates: Map<Material, Material> = new Map();\n\tconst skip = new Set(['name']);\n\n\t// Compare each material to every other material — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++) {\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < materials.length; j++) {\n\t\t\tconst b = materials[j];\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\tif (a.equals(b, skip)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t// eslint-disable-next-line max-len\n\t\t`${NAME}: Found ${duplicates.size} duplicates among ${root.listMaterials().length} materials.`\n\t);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim: Primitive | PrimitiveTarget, refs: Map<Accessor | Material, number>): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n","import type { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\nimport { MeshQuantization } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: DequantizeOptions = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link MeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = { ...DEQUANTIZE_DEFAULTS, ..._options } as Required<DequantizeOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(MeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dequantizePrimitive(prim: Primitive, options: Required<DequantizeOptions>): void {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tdequantizeAttribute(semantic, prim.getAttribute(semantic)!, options);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tdequantizeAttribute(semantic, target.getAttribute(semantic)!, options);\n\t\t}\n\t}\n}\n\nfunction dequantizeAttribute(semantic: string, attribute: Accessor, options: Required<DequantizeOptions>): void {\n\tif (!attribute.getArray()) return;\n\tif (!options.pattern.test(semantic)) return;\n\tif (attribute.getComponentSize() >= 4) return;\n\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = attribute.getCount(), el = [] as number[]; i < il; i++) {\n\t\tel = attribute.getElement(i, el);\n\t\tattribute.setArray(dstArray).setElement(i, el).setArray(srcArray);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { DracoMeshCompression } from '@gltf-transform/extensions';\n\nexport interface DracoOptions {\n\tmethod?: 'edgebreaker' | 'sequential';\n\tencodeSpeed?: number;\n\tdecodeSpeed?: number;\n\tquantizePosition?: number;\n\tquantizeNormal?: number;\n\tquantizeColor?: number;\n\tquantizeTexcoord?: number;\n\tquantizeGeneric?: number;\n\tquantizationVolume?: 'mesh' | 'scene';\n}\n\nexport const DRACO_DEFAULTS: DracoOptions = {\n\tmethod: 'edgebreaker',\n\tencodeSpeed: 5,\n\tdecodeSpeed: 5,\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeColor: 8,\n\tquantizeTexcoord: 12,\n\tquantizeGeneric: 12,\n\tquantizationVolume: 'mesh',\n};\n\n/**\n * Applies Draco compression using {@link DracoMeshCompression KHR_draco_mesh_compression}.\n * This type of compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link DracoMeshCompression} extension itself.\n */\nexport const draco = (_options: DracoOptions): Transform => {\n\tconst options = { ...DRACO_DEFAULTS, ..._options } as Required<DracoOptions>;\n\treturn (doc: Document): void => {\n\t\tdoc.createExtension(DracoMeshCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.method === 'edgebreaker'\n\t\t\t\t\t\t? DracoMeshCompression.EncoderMethod.EDGEBREAKER\n\t\t\t\t\t\t: DracoMeshCompression.EncoderMethod.SEQUENTIAL,\n\t\t\t\tencodeSpeed: options.encodeSpeed,\n\t\t\t\tdecodeSpeed: options.decodeSpeed,\n\t\t\t\tquantizationBits: {\n\t\t\t\t\tPOSITION: options.quantizePosition,\n\t\t\t\t\tNORMAL: options.quantizeNormal,\n\t\t\t\t\tCOLOR: options.quantizeColor,\n\t\t\t\t\tTEX_COORD: options.quantizeTexcoord,\n\t\t\t\t\tGENERIC: options.quantizeGeneric,\n\t\t\t\t},\n\t\t\t\tquantizationVolume: options.quantizationVolume,\n\t\t\t});\n\t};\n};\n","import {\n\tAccessor,\n\tDocument,\n\tExtensionProperty,\n\tGLTF,\n\tImageUtils,\n\tTexture,\n\tbounds,\n\tPropertyType,\n} from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils';\nimport { KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, read as readKTX } from 'ktx-parse';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect(doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes(doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc\n\t\t.getRoot()\n\t\t.listScenes()\n\t\t.map((scene) => {\n\t\t\tconst root = scene.listChildren()[0];\n\t\t\tconst sceneBounds = bounds(scene);\n\t\t\treturn {\n\t\t\t\tname: scene.getName(),\n\t\t\t\trootName: root ? root.getName() : '',\n\t\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t\t};\n\t\t});\n\treturn { properties: scenes };\n}\n\n/** List meshes. */\nfunction listMeshes(doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc\n\t\t.getRoot()\n\t\t.listMeshes()\n\t\t.map((mesh) => {\n\t\t\tconst instances = mesh.listParents().filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\t\t\tlet glPrimitives = 0;\n\t\t\tlet verts = 0;\n\t\t\tconst semantics = new Set<string>();\n\t\t\tconst meshIndices = new Set<string>();\n\t\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\t\tsemantics.add(semantic + ':' + accessorToTypeLabel(attr));\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t\t}\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tmeshIndices.add(accessorToTypeLabel(indices));\n\t\t\t\t\tmeshAccessors.add(indices);\n\t\t\t\t}\n\t\t\t\tverts += prim.listAttributes()[0].getCount();\n\t\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\t\tconst modes = mesh.listPrimitives().map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\t\treturn {\n\t\t\t\tname: mesh.getName(),\n\t\t\t\tmode: Array.from(new Set(modes)),\n\t\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\t\tglPrimitives: glPrimitives,\n\t\t\t\tvertices: verts,\n\t\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\t\tinstances: instances,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: meshes };\n}\n\n/** List materials. */\nfunction listMaterials(doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc\n\t\t.getRoot()\n\t\t.listMaterials()\n\t\t.map((material) => {\n\t\t\tconst instances = material\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\t// Find all texture slots attached to this material or its extensions.\n\t\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listEdges()\n\t\t\t\t.filter((ref) => {\n\t\t\t\t\tconst child = ref.getChild();\n\t\t\t\t\tconst parent = ref.getParent();\n\t\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map((ref) => ref.getName());\n\n\t\t\treturn {\n\t\t\t\tname: material.getName(),\n\t\t\t\tinstances,\n\t\t\t\ttextures: slots,\n\t\t\t\talphaMode: material.getAlphaMode(),\n\t\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t\t};\n\t\t});\n\n\treturn { properties: materials };\n}\n\n/** List textures. */\nfunction listTextures(doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc\n\t\t.getRoot()\n\t\t.listTextures()\n\t\t.map((texture) => {\n\t\t\tconst instances = texture\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listParentEdges(texture)\n\t\t\t\t.filter((edge) => edge.getParent().propertyType !== PropertyType.ROOT)\n\t\t\t\t.map((edge) => edge.getName());\n\n\t\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\t\tlet compression = '';\n\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\tconst container = readKTX(texture.getImage()!);\n\t\t\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\t\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\t\t\tcompression = 'ETC1S';\n\t\t\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\t\t\tcompression = 'UASTC';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: texture.getName(),\n\t\t\t\turi: texture.getURI(),\n\t\t\t\tslots: Array.from(new Set(slots)),\n\t\t\t\tinstances,\n\t\t\t\tmimeType: texture.getMimeType(),\n\t\t\t\tcompression,\n\t\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\t\tgpuSize: ImageUtils.getMemSize(texture.getImage()!, texture.getMimeType()),\n\t\t\t};\n\t\t});\n\n\treturn { properties: textures };\n}\n\n/** List animations. */\nfunction listAnimations(doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc\n\t\t.getRoot()\n\t\t.listAnimations()\n\t\t.map((anim) => {\n\t\t\tlet minTime = Infinity;\n\t\t\tlet maxTime = -Infinity;\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tif (!input) return;\n\t\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tlet keyframes = 0;\n\t\t\tconst accessors: Set<Accessor> = new Set();\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (!input) return;\n\t\t\t\tkeyframes += input.getCount();\n\t\t\t\taccessors.add(input);\n\t\t\t\tif (!output) return;\n\t\t\t\taccessors.add(output);\n\t\t\t});\n\t\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: anim.getName(),\n\t\t\t\tchannels: anim.listChannels().length,\n\t\t\t\tsamplers: anim.listSamplers().length,\n\t\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\t\tkeyframes: keyframes,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: animations };\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tprimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tcompression: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nconst NumericTypeLabels: Record<string, string> = {\n\tFloat32Array: 'f32',\n\tUint32Array: 'u32',\n\tUint16Array: 'u16',\n\tUint8Array: 'u8',\n\tInt32Array: 'i32',\n\tInt16Array: 'i16',\n\tInt8Array: 'i8',\n};\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction accessorToTypeLabel(accessor: Accessor): string {\n\tconst array = accessor.getArray()!;\n\tconst base = NumericTypeLabels[array.constructor.name] || '?';\n\tconst suffix = accessor.getNormalized() ? '_norm' : '';\n\treturn base + suffix;\n}\n","import { Document, ILogger, MathUtils, Mesh, Node, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, MeshGPUInstancing } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'instance';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface InstanceOptions {}\n\nconst INSTANCE_DEFAULTS: Required<InstanceOptions> = {};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. No\n * options are currently implemented for this function.\n */\nexport function instance(_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...INSTANCE_DEFAULTS, ..._options } as Required<InstanceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst batchExtension = doc.createExtension(MeshGPUInstancing);\n\n\t\tif (root.listAnimations().length) {\n\t\t\tlogger.warn(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < 2) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, (t = node.getWorldTranslation()));\n\t\t\t\t\tbatchRotation.setElement(i, (r = node.getWorldRotation()));\n\t\t\t\t\tbatchScale.setElement(i, (s = node.getWorldScale()));\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\n\t\t\t\t\t// Mark the node for cleanup.\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with multiple parent nodes were found.`);\n\t\t}\n\n\t\tif (batchExtension.listProperties().length === 0) {\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: ILogger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (\n\t\t\tnode.listChildren().length ||\n\t\t\tnode.getCamera() ||\n\t\t\tnode.getMesh() ||\n\t\t\tnode.getSkin() ||\n\t\t\tnode.listExtensions().length\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParent();\n\t\tif (nodeParent instanceof Node) {\n\t\t\tnodes.push(nodeParent);\n\t\t}\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction createBatch(doc: Document, batchExtension: MeshGPUInstancing, mesh: Mesh, count: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension\n\t\t.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n","import {\n\tAnimationChannel,\n\tDocument,\n\tGraph,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tNode,\n\tScene,\n\tExtensionProperty,\n\tMaterial,\n\tPrimitive,\n\tPrimitiveTarget,\n\tTexture,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'prune';\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n\t/** Whether to keep empty leaf nodes. */\n\tkeepLeaves?: boolean;\n\t/** Whether to keep unused vertex attributes, such as UVs without an assigned texture. */\n\tkeepAttributes?: boolean;\n}\nconst PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t],\n\tkeepLeaves: false,\n\tkeepAttributes: true,\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(prune());\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * No options are currently implemented for this function.\n */\nexport const prune = function (_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...PRUNE_DEFAULTS, ..._options } as Required<PruneOptions>;\n\tconst propertyTypes = new Set(options.propertyTypes);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst graph = doc.getGraph();\n\n\t\tconst disposed: Record<string, number> = {};\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\tif (propertyTypes.has(PropertyType.NODE) && !options.keepLeaves) root.listScenes().forEach(nodeTreeShake);\n\t\tif (propertyTypes.has(PropertyType.NODE)) root.listNodes().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.SKIN)) root.listSkins().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.MESH)) root.listMeshes().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.CAMERA)) root.listCameras().forEach(treeShake);\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE);\n\t\t}\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET);\n\t\t}\n\n\t\t// Prune unused vertex attributes.\n\t\tif (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tconst required = listRequiredSemantics(doc, prim.getMaterial());\n\t\t\t\t\tconst unused = listUnusedSemantics(prim, required);\n\t\t\t\t\tpruneAttributes(prim, unused);\n\t\t\t\t\tprim.listTargets().forEach((target) => pruneAttributes(target, unused));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.has(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t\tmarkDisposed(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim);\n\t\t\t\t\tsamplers.forEach(treeShake);\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach(treeShake);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) root.listMaterials().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) root.listTextures().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) root.listAccessors().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.BUFFER)) root.listBuffers().forEach(treeShake);\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\tif (Object.keys(disposed).length) {\n\t\t\tconst str = Object.keys(disposed)\n\t\t\t\t.map((t) => `${t} (${disposed[t]})`)\n\t\t\t\t.join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t\t//\n\n\t\t/** Disposes of the given property if it is unused. */\n\t\tfunction treeShake(prop: Property): void {\n\t\t\t// Consider a property unused if it has no references from another property, excluding\n\t\t\t// types Root and AnimationChannel.\n\t\t\tconst parents = prop.listParents().filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\t\t\tif (!parents.length) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * For property types the Root does not maintain references to, we'll need to search the\n\t\t * graph. It's possible that objects may have been constructed without any outbound links,\n\t\t * but since they're not on the graph they don't need to be tree-shaken.\n\t\t */\n\t\tfunction indirectTreeShake(graph: Graph<Property>, propertyType: string): void {\n\t\t\tgraph\n\t\t\t\t.listEdges()\n\t\t\t\t.map((edge) => edge.getParent())\n\t\t\t\t.filter((parent) => parent.propertyType === propertyType)\n\t\t\t\t.forEach(treeShake);\n\t\t}\n\n\t\t/** Iteratively prunes leaf Nodes without contents. */\n\t\tfunction nodeTreeShake(prop: Node | Scene): void {\n\t\t\tprop.listChildren().forEach(nodeTreeShake);\n\n\t\t\tif (prop instanceof Scene) return;\n\n\t\t\tconst isUsed = graph.listParentEdges(prop).some((e) => {\n\t\t\t\tconst ptype = e.getParent().propertyType;\n\t\t\t\treturn ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n\t\t\t});\n\t\t\tconst isEmpty = graph.listChildren(prop).length === 0;\n\t\t\tif (isEmpty && !isUsed) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\tfunction pruneAttributes(prim: Primitive | PrimitiveTarget, unused: string[]) {\n\t\t\tfor (const semantic of unused) {\n\t\t\t\tprim.setAttribute(semantic, null);\n\t\t\t}\n\t\t}\n\n\t\t/** Records properties disposed by type. */\n\t\tfunction markDisposed(prop: Property): void {\n\t\t\tdisposed[prop.propertyType] = disposed[prop.propertyType] || 0;\n\t\t\tdisposed[prop.propertyType]++;\n\t\t}\n\t});\n};\n\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim: Primitive | PrimitiveTarget, required: Set<string>): string[] {\n\tconst unused = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (semantic === 'TANGENT' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n\t\t\tunused.push(semantic);\n\t\t}\n\t}\n\treturn unused;\n}\n\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(\n\tdocument: Document,\n\tmaterial: Material | ExtensionProperty | null,\n\tsemantics = new Set<string>()\n): Set<string> {\n\tif (!material) return semantics;\n\n\tconst graph = document.getGraph();\n\n\tconst edges = graph.listChildEdges(material);\n\tconst textureNames = new Set<string>();\n\n\tfor (const edge of edges) {\n\t\tif (edge.getChild() instanceof Texture) {\n\t\t\ttextureNames.add(edge.getName());\n\t\t}\n\t}\n\n\tfor (const edge of edges) {\n\t\tconst name = edge.getName();\n\t\tconst child = edge.getChild();\n\n\t\tif (child instanceof TextureInfo) {\n\t\t\tif (textureNames.has(name.replace(/Info$/, ''))) {\n\t\t\t\tsemantics.add(`TEXCOORD_${child.getTexCoord()}`);\n\t\t\t}\n\t\t}\n\n\t\tif (child instanceof Texture && name.match(/normalTexture/i)) {\n\t\t\tsemantics.add('TANGENT');\n\t\t}\n\n\t\tif (child instanceof ExtensionProperty) {\n\t\t\tlistRequiredSemantics(document, child, semantics);\n\t\t}\n\n\t\t// TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n\t}\n\n\treturn semantics;\n}\n","import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform, deepListAttributes, remapAttribute, SetMap } from './utils';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder: unknown;\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance';\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n};\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n */\nexport function reorder(_options: ReorderOptions): Transform {\n\tconst options = { ...REORDER_DEFAULTS, ..._options } as Required<ReorderOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = createLayoutPlan(doc);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tconst dstIndices = srcIndices.clone();\n\t\t\tlet indicesArray = dstIndices.getArray()!.slice();\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size'\n\t\t\t);\n\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = srcAttribute.clone();\n\t\t\t\tremapAttribute(dstAttribute, remap, unique);\n\t\t\t\tfor (const prim of plan.attributesToPrimitives.get(srcAttribute)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\t\t\t\t\tif (prim.getIndices() === dstIndices) {\n\t\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.ACCESSOR] }));\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n */\nexport function createLayoutPlan(document: Document): LayoutPlan {\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\n\t\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { indicesToAttributes, indicesToMode, attributesToPrimitives };\n}\n","import { Accessor, GLTF, MathUtils, Primitive, PrimitiveTarget, TypedArray, vec4 } from '@gltf-transform/core';\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nexport function sortPrimitiveWeights(prim: Primitive | PrimitiveTarget, limit = Infinity) {\n\tif ((Number.isFinite(limit) && limit % 4) || limit <= 0) {\n\t\tthrow new Error(`Limit must be positive multiple of four.`);\n\t}\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\t// (1) Sort.\n\n\tconst indices = new Uint16Array(setCount * 4);\n\tconst srcWeights = new Float32Array(setCount * 4);\n\tconst dstWeights = new Float32Array(setCount * 4);\n\tconst srcJoints = new Uint32Array(setCount * 4);\n\tconst dstJoints = new Uint32Array(setCount * 4);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'WEIGHTS', srcWeights);\n\t\tgetVertexArray(prim, i, 'JOINTS', srcJoints);\n\n\t\t// Sort indices to create a lookup table, indices[dstIndex] → srcIndex,\n\t\t// indexed into the weights and joints arrays.\n\t\tfor (let j = 0; j < setCount * 4; j++) indices[j] = j;\n\t\tindices.sort((a, b) => (srcWeights[a] > srcWeights[b] ? -1 : 1));\n\n\t\t// Sort weights and joints.\n\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\tdstWeights[j] = srcWeights[indices[j]];\n\t\t\tdstJoints[j] = srcJoints[indices[j]];\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'WEIGHTS', dstWeights);\n\t\tsetVertexArray(prim, i, 'JOINTS', dstJoints);\n\t}\n\n\t// (2) Limit.\n\tfor (let i = setCount; i * 4 > limit; i--) {\n\t\tconst weights = prim.getAttribute(`WEIGHTS_${i - 1}`)!;\n\t\tconst joints = prim.getAttribute(`JOINTS_${i - 1}`)!;\n\t\tprim.setAttribute(`WEIGHTS_${i - 1}`, null);\n\t\tprim.setAttribute(`JOINTS_${i - 1}`, null);\n\t\tif (weights.listParents().length === 1) weights.dispose();\n\t\tif (joints.listParents().length === 1) joints.dispose();\n\t}\n\n\t// (3) Normalize.\n\tnormalizePrimitiveWeights(prim);\n}\n\n// Utilities.\n\ntype PrimLike = Primitive | PrimitiveTarget;\n\nfunction normalizePrimitiveWeights(prim: PrimLike): void {\n\t// Would prefer to warn if unsafe, but no logger accessible in this scope.\n\tif (!isNormalizeSafe(prim)) return;\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\tconst templateAttribute = prim.getAttribute('WEIGHTS_0')!;\n\tconst templateArray = templateAttribute.getArray()!;\n\tconst componentType = templateAttribute.getComponentType();\n\tconst normalized = templateAttribute.getNormalized();\n\tconst normalizedComponentType = normalized ? componentType : undefined;\n\tconst delta = normalized ? MathUtils.denormalize(1, componentType) : Number.EPSILON;\n\tconst joints = new Uint32Array(setCount * 4).fill(0);\n\tconst weights = templateArray.slice(0, setCount * 4).fill(0);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'JOINTS', joints);\n\t\tgetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\n\t\tlet weightsSum = sum(weights, normalizedComponentType);\n\t\tif (weightsSum === 0) continue;\n\n\t\t// (1) If sum of weights not within δ of 1, renormalize all weights.\n\t\tif (Math.abs(1 - weightsSum) > delta) {\n\t\t\tfor (let j = 0; j < weights.length; j++) {\n\t\t\t\tif (normalized) {\n\t\t\t\t\tconst intValue = MathUtils.normalize(weights[j] / weightsSum, componentType);\n\t\t\t\t\tweights[j] = MathUtils.denormalize(intValue, componentType);\n\t\t\t\t} else {\n\t\t\t\t\tweights[j] /= weightsSum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tweightsSum = sum(weights, normalizedComponentType);\n\n\t\t// (2) Sum of normalized weights may still be off by δ. Compensate\n\t\t// in least-significant weight.\n\t\tif (normalized && weightsSum !== 1) {\n\t\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\t\tif (weights[j] > 0) {\n\t\t\t\t\tweights[j] += MathUtils.normalize(1 - weightsSum, componentType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Remove joint indices whose weights have fallen to zero.\n\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\tif (weights[j] === 0) {\n\t\t\t\tjoints[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'JOINTS', joints);\n\t\tsetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\t}\n}\n\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\ttarget: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): TypedArray {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tweights.getElement(vertexIndex, el);\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\ttarget[i * 4 + j] = MathUtils.normalize(el[j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\ttarget[i * 4 + j] = el[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\tvalues: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): void {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\tel[j] = MathUtils.denormalize(values[i * 4 + j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\tel[j] = values[i * 4 + j];\n\t\t\t}\n\t\t}\n\t\tweights.setElement(vertexIndex, el);\n\t}\n}\n\n/** Sum an array of numbers. */\nfunction sum(values: TypedArray, normalizedComponentType?: GLTF.AccessorComponentType): number {\n\tlet sum = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tif (normalizedComponentType) {\n\t\t\tsum += MathUtils.denormalize(values[i], normalizedComponentType);\n\t\t} else {\n\t\t\tsum += values[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim: PrimLike): boolean {\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.filter((name) => name.startsWith('WEIGHTS_'))\n\t\t.map((name) => prim.getAttribute(name)!);\n\tconst normList = attributes.map((a) => a.getNormalized());\n\tconst typeList = attributes.map((a) => a.getComponentType());\n\treturn new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n","import {\n\tAccessor,\n\tAnimationChannel,\n\tbbox,\n\tDocument,\n\tILogger,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tSkin,\n\tTransform,\n\tvec2,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { MeshQuantization } from '@gltf-transform/extensions';\nimport type { Volume } from '@gltf-transform/extensions';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\nimport { sortPrimitiveWeights } from './sort-primitive-weights';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n\t/** Normalize weight attributes. */\n\tnormalizeWeights?: boolean;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<QuantizeOptions> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n\tnormalizeWeights: true,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n */\nconst quantize = (_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform => {\n\tconst options = { ...QUANTIZE_DEFAULTS, ..._options } as Required<QuantizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tdoc.createExtension(MeshQuantization).setRequired(true);\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(doc, mesh, nodeTransform);\n\t\t\t\ttransformMeshMaterials(mesh, 1 / nodeTransform.scale);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tquantizePrimitive(doc, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(doc, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait doc.transform(\n\t\t\tprune({ propertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL] }),\n\t\t\tdedup({ propertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL] })\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction quantizePrimitive(\n\tdoc: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>\n): void {\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!options.pattern.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 8–16.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n\t\tsortPrimitiveWeights(prim, Infinity);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(doc: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (!(parent instanceof Node)) continue;\n\n\t\tconst animChannels = parent.listParents().filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\tif (parent.getSkin()) {\n\t\t\tparent.setSkin(transformSkin(parent.getSkin()!, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet targetNode: Node;\n\t\tif (isParentNode || isAnimated) {\n\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\tanimChannels\n\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t} else {\n\t\t\ttargetNode = parent;\n\t\t}\n\n\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\ttargetNode.setMatrix(nodeMatrix);\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone();\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh: Mesh, scale: number) {\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tlet material = prim.getMaterial();\n\t\tif (!material) continue;\n\n\t\tlet volume = material.getExtension<Volume>('KHR_materials_volume');\n\t\tif (!volume || volume.getThicknessFactor() <= 0) continue;\n\n\t\t// prune()+dedup() will clean this up later.\n\t\tvolume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n\t\tmaterial = material.clone().setExtension('KHR_materials_volume', volume);\n\t\tprim.setMaterial(material);\n\t}\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tlet value = Math.round(Math.abs(el[j]) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(true);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: ILogger,\n\toptions: Required<QuantizeOptions>\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nexport { quantize };\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { MeshoptCompression } from '@gltf-transform/extensions';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { reorder } from './reorder';\nimport { quantize } from './quantize';\n\nexport interface MeshoptOptions {\n\tencoder: unknown;\n\tlevel?: 'medium' | 'high';\n}\n\nexport const MESHOPT_DEFAULTS: Required<Omit<MeshoptOptions, 'encoder'>> = { level: 'high' };\n\nconst NAME = 'meshopt';\n\n/**\n * Applies Meshopt compression using {@link MeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link MeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   reorder({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n */\nexport const meshopt = (_options: MeshoptOptions): Transform => {\n\tconst options = { ...MESHOPT_DEFAULTS, ..._options } as Required<MeshoptOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn async (document: Document): Promise<void> => {\n\t\tawait document.transform(\n\t\t\treorder({\n\t\t\t\tencoder: encoder,\n\t\t\t\ttarget: 'size',\n\t\t\t}),\n\t\t\tquantize({\n\t\t\t\t// IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n\t\t\t\t// _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n\t\t\t\tpattern: options.level === 'medium' ? /.*/ : /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/,\n\t\t\t\tquantizePosition: 14,\n\t\t\t\tquantizeTexcoord: 12,\n\t\t\t\tquantizeColor: 8,\n\t\t\t\tquantizeNormal: 8,\n\t\t\t})\n\t\t);\n\n\t\tdocument\n\t\t\t.createExtension(MeshoptCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.level === 'medium'\n\t\t\t\t\t\t? MeshoptCompression.EncoderMethod.QUANTIZE\n\t\t\t\t\t\t: MeshoptCompression.EncoderMethod.FILTER,\n\t\t\t});\n\t};\n};\n","import type { Document, Texture, Transform } from '@gltf-transform/core';\nimport {\n\tMaterialsIOR,\n\tMaterialsPBRSpecularGlossiness,\n\tMaterialsSpecular,\n\tPBRSpecularGlossiness,\n} from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n */\nexport function metalRough(_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...METALROUGH_DEFAULTS, ..._options } as Required<MetalRoughOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(MaterialsIOR);\n\t\tconst specExtension = doc.createExtension(MaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(MaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension\n\t\t\t\t.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","\nimport type { Accessor, Document, ILogger, Transform, TypedArray } from '@gltf-transform/core';\nimport { createTransform, formatDeltaOp } from './utils';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n */\nexport function unweld(_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNWELD_DEFAULTS, ..._options } as Required<UnweldOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (!indices) continue;\n\n\t\t\t\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\n\t\t\t\t// Vertex attributes.\n\t\t\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\t\t\tprim.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t// Clean up.\n\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t}\n\n\t\t\t\t// Morph target vertex attributes.\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\t\t\ttarget.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t\t// Clean up.\n\t\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dstVertexCount = prim.getAttribute('POSITION')!.getCount();\n\t\t\t\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t\t\t\t// Clean up.\n\t\t\t\tprim.setIndices(null);\n\t\t\t\tif (indices.listParents().length === 1) indices.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction unweldAttribute(\n\tsrcAttribute: Accessor,\n\tindices: Accessor,\n\tlogger: ILogger,\n\tvisited: Map<Accessor, Map<Accessor, Accessor>>\n): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\tlogger.debug(`${NAME}: Cache hit for reused attribute, \"${srcAttribute.getName()}\".`);\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst dstAttribute = srcAttribute.clone();\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as new (len: number) => TypedArray;\n\tdstAttribute.setArray(new ArrayCtor(indices.getCount() * srcAttribute.getElementSize()));\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < indices.getCount(); i++) {\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(indices.getScalar(i), el));\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { unweld } from './unweld';\nimport { createTransform } from './utils';\nimport { normalize } from 'gl-matrix/vec3';\n\nconst NAME = 'normals';\n\n/** Options for the {@link normals} function. */\nexport interface NormalsOptions {\n\t/** Whether to overwrite existing `NORMAL` attributes. */\n\toverwrite?: boolean;\n}\n\nconst NORMALS_DEFAULTS: Required<NormalsOptions> = {\n\toverwrite: false,\n};\n\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n */\nexport function normals(_options: NormalsOptions = NORMALS_DEFAULTS): Transform {\n\tconst options = { ...NORMALS_DEFAULTS, ..._options } as Required<NormalsOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tlet modified = 0;\n\n\t\tawait document.transform(unweld());\n\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\t\tlet normal = prim.getAttribute('NORMAL');\n\n\t\t\t\tif (options.overwrite && normal) {\n\t\t\t\t\tnormal.dispose();\n\t\t\t\t} else if (normal) {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping primitive: NORMAL found.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnormal = document\n\t\t\t\t\t.createAccessor()\n\t\t\t\t\t.setArray(new Float32Array(position.getCount() * 3))\n\t\t\t\t\t.setType('VEC3');\n\n\t\t\t\tconst a = [0, 0, 0] as vec3;\n\t\t\t\tconst b = [0, 0, 0] as vec3;\n\t\t\t\tconst c = [0, 0, 0] as vec3;\n\n\t\t\t\tfor (let i = 0; i < position.getCount(); i += 3) {\n\t\t\t\t\tposition.getElement(i + 0, a);\n\t\t\t\t\tposition.getElement(i + 1, b);\n\t\t\t\t\tposition.getElement(i + 2, c);\n\n\t\t\t\t\tconst faceNormal = computeNormal(a, b, c);\n\n\t\t\t\t\tnormal.setElement(i + 0, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 1, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 2, faceNormal);\n\t\t\t\t}\n\n\t\t\t\tprim.setAttribute('NORMAL', normal);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a: vec3, b: vec3, c: vec3): vec3 {\n\tconst A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n\tconst B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n\tconst n = [\n\t\tA[1] * B[2] - A[2] * B[1], //\n\t\tA[2] * B[0] - A[0] * B[2],\n\t\tA[0] * B[1] - A[1] * B[0],\n\t] as vec3;\n\treturn normalize([0, 0, 0], n) as vec3;\n}\n","import { Document, ILogger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> = {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n */\nconst partition = (_options: PartitionOptions = PARTITION_DEFAULTS): Transform => {\n\tconst options = { ...PARTITION_DEFAULTS, ..._options } as Required<PartitionOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.BUFFER] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction partitionMeshes(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\tprimitive.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\tprimitive.listTargets().forEach((primTarget) => {\n\t\t\t\t\tprimTarget.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI(basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import {\n\tAccessor,\n\tAnimationSampler,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tTransformContext,\n} from '@gltf-transform/core';\nimport quat, { getAngle, slerp } from 'gl-matrix/quat';\nimport { dedup } from './dedup';\nimport { createTransform, isTransformPending } from './utils';\n\nconst NAME = 'resample';\n\nexport interface ResampleOptions {\n\ttolerance?: number;\n}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> = { tolerance: 1e-4 };\n\n/**\n * Resample {@link Animation}s, losslessly deduplicating keyframes to reduce file size. Duplicate\n * keyframes are commonly present in animation 'baked' by the authoring software to apply IK\n * constraints or other software-specific features. Based on THREE.KeyframeTrack.optimize().\n *\n * Example: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n */\nexport const resample = (_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform => {\n\tconst options = { ...RESAMPLE_DEFAULTS, ..._options } as Required<ResampleOptions>;\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst srcAccessorCount = document.getRoot().listAccessors().length;\n\t\tconst logger = document.getLogger();\n\n\t\tlet didSkipMorphTargets = false;\n\n\t\tfor (const animation of document.getRoot().listAnimations()) {\n\t\t\t// Skip morph targets, see https://github.com/donmccurdy/glTF-Transform/issues/290.\n\t\t\tconst samplerTargetPaths = new Map<AnimationSampler, GLTF.AnimationChannelTargetPath>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tsamplerTargetPaths.set(channel.getSampler()!, channel.getTargetPath()!);\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tif (samplerTargetPaths.get(sampler) === 'weights') {\n\t\t\t\t\tdidSkipMorphTargets = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sampler.getInterpolation() === 'STEP' || sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\taccessorsVisited.add(sampler.getInput()!);\n\t\t\t\t\taccessorsVisited.add(sampler.getOutput()!);\n\t\t\t\t\toptimize(sampler, samplerTargetPaths.get(sampler)!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\t// Resampling may result in duplicate input or output sampler\n\t\t// accessors. Find and remove the duplicates after processing.\n\t\tconst dstAccessorCount = document.getRoot().listAccessors().length;\n\t\tif (dstAccessorCount > srcAccessorCount && !isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tif (didSkipMorphTargets) {\n\t\t\tlogger.warn(`${NAME}: Skipped optimizing morph target keyframes, not yet supported.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction optimize(sampler: AnimationSampler, path: GLTF.AnimationChannelTargetPath, options: ResampleOptions): void {\n\tconst input = sampler.getInput()!.clone();\n\tconst output = sampler.getOutput()!.clone();\n\n\tconst tolerance = options.tolerance as number;\n\tconst interpolation = sampler.getInterpolation();\n\n\tconst lastIndex = input.getCount() - 1;\n\tconst tmp: number[] = [];\n\tconst value: number[] = [];\n\tconst valueNext: number[] = [];\n\tconst valuePrev: number[] = [];\n\n\tlet writeIndex = 1;\n\n\tfor (let i = 1; i < lastIndex; ++i) {\n\t\tconst timePrev = input.getScalar(writeIndex - 1);\n\t\tconst time = input.getScalar(i);\n\t\tconst timeNext = input.getScalar(i + 1);\n\t\tconst t = (time - timePrev) / (timeNext - timePrev);\n\n\t\tlet keep = false;\n\n\t\t// Remove unnecessary adjacent keyframes.\n\t\tif (time !== timeNext && (i !== 1 || time !== input.getScalar(0))) {\n\t\t\toutput.getElement(writeIndex - 1, valuePrev);\n\t\t\toutput.getElement(i, value);\n\t\t\toutput.getElement(i + 1, valueNext);\n\n\t\t\tif (interpolation === 'LINEAR' && path === 'rotation') {\n\t\t\t\t// Prune keyframes colinear with prev/next keyframes.\n\t\t\t\tconst sample = slerp(tmp as quat, valuePrev as quat, valueNext as quat, t) as number[];\n\t\t\t\tconst angle = getAngle(valuePrev as quat, value as quat) + getAngle(value as quat, valueNext as quat);\n\t\t\t\tkeep = !MathUtils.eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n\t\t\t} else if (interpolation === 'LINEAR') {\n\t\t\t\t// Prune keyframes colinear with prev/next keyframes.\n\t\t\t\tconst sample = vlerp(tmp, valuePrev, valueNext, t);\n\t\t\t\tkeep = !MathUtils.eq(value, sample, tolerance);\n\t\t\t} else if (interpolation === 'STEP') {\n\t\t\t\t// Prune keyframes identical to prev/next keyframes.\n\t\t\t\tkeep = !MathUtils.eq(value, valuePrev) || !MathUtils.eq(value, valueNext);\n\t\t\t}\n\t\t}\n\n\t\t// In-place compaction.\n\t\tif (keep) {\n\t\t\tif (i !== writeIndex) {\n\t\t\t\tinput.setScalar(writeIndex, input.getScalar(i));\n\t\t\t\toutput.setElement(writeIndex, output.getElement(i, tmp));\n\t\t\t}\n\t\t\twriteIndex++;\n\t\t}\n\t}\n\n\t// Flush last keyframe (compaction looks ahead).\n\tif (lastIndex > 0) {\n\t\tinput.setScalar(writeIndex, input.getScalar(lastIndex));\n\t\toutput.setElement(writeIndex, output.getElement(lastIndex, tmp));\n\t\twriteIndex++;\n\t}\n\n\t// If the sampler was optimized, truncate and save the results. If not, clean up.\n\tif (writeIndex !== input.getCount()) {\n\t\tinput.setArray(input.getArray()!.slice(0, writeIndex));\n\t\toutput.setArray(output.getArray()!.slice(0, writeIndex * output.getElementSize()));\n\t\tsampler.setInput(input);\n\t\tsampler.setOutput(output);\n\t} else {\n\t\tinput.dispose();\n\t\toutput.dispose();\n\t}\n}\n\nfunction lerp(v0: number, v1: number, t: number): number {\n\treturn v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out: number[], a: number[], b: number[], t: number): number[] {\n\tfor (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\treturn out;\n}\n","import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n */\nexport function sequence (_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = {...SEQUENCE_DEFAULTS, ..._options} as Required<SequenceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n}\n","import {\n\tAccessor,\n\tDocument,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tTransform,\n\tTransformContext,\n\tTypedArray,\n\tvec3,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { createIndices, createTransform, formatDeltaOp, isTransformPending } from './utils';\n\nconst NAME = 'weld';\n\nconst Tolerance = {\n\tDEFAULT: 0.0001,\n\tTEXCOORD: 0.0001, // [0, 1]\n\tCOLOR: 0.01, // [0, 1]\n\tNORMAL: 0.5, // [-1, 1]\n\tJOINTS: 0.0, // [0, ∞]\n\tWEIGHTS: 0.01, // [0, ∞]\n};\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Tolerance, as a fraction of primitive AABB, used when merging similar vertices. */\n\ttolerance?: number;\n\t/** Whether to overwrite existing indices. */\n\toverwrite?: boolean;\n}\n\nexport const WELD_DEFAULTS: Required<WeldOptions> = {\n\ttolerance: Tolerance.DEFAULT,\n\toverwrite: true,\n};\n\n/**\n * Index {@link Primitive Primitives} and (optionally) merge similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For --tolerance=0, geometry\n * is indexed in place, without merging.\n *\n * Example:\n *\n * ```javascript\n * import { weld } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tweld({ tolerance: 0.001 })\n * );\n * ```\n */\nexport function weld(_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = { ...WELD_DEFAULTS, ..._options } as Required<WeldOptions>;\n\n\tif (options.tolerance > 0.1 || options.tolerance < 0) {\n\t\tthrow new Error(`${NAME}: Requires 0 ≤ tolerance ≤ 0.1`);\n\t}\n\n\treturn createTransform(NAME, async (doc: Document, context?: TransformContext): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tweldPrimitive(doc, prim, options);\n\t\t\t}\n\t\t}\n\n\t\t// TODO(perf): Suppose we just invoked simplify(), and dedup is not explicitly\n\t\t// in the transform stack .... now we are going to run it twice!\n\t\tif (!isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait doc.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Index a {@link Primitive} and (optionally) weld similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For --tolerance=0, geometry\n * is indexed in place, without merging.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(document, prim, {tolerance: 0.0001});\n * }\n * ```\n */\nexport function weldPrimitive(doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tif (prim.getIndices() && !options.overwrite) return;\n\tif (prim.getMode() === Primitive.Mode.POINTS) return;\n\tif (options.tolerance === 0) {\n\t\t_indexPrimitive(doc, prim);\n\t} else {\n\t\t_weldPrimitive(doc, prim, options);\n\t}\n}\n\n/** @internal Adds indices, if missing. Does not merge vertices. */\nfunction _indexPrimitive(doc: Document, prim: Primitive): void {\n\t// No need to overwrite here, even if options.overwrite=true.\n\tif (prim.getIndices()) return;\n\n\tconst attr = prim.listAttributes()[0];\n\tconst numVertices = attr.getCount();\n\tconst buffer = attr.getBuffer();\n\tconst indices = doc\n\t\t.createAccessor()\n\t\t.setBuffer(buffer)\n\t\t.setType(Accessor.Type.SCALAR)\n\t\t.setArray(createIndices(numVertices));\n\tprim.setIndices(indices);\n}\n\n/** @internal Weld and merge, combining vertices that are similar on all vertex attributes. */\nfunction _weldPrimitive(doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tconst logger = doc.getLogger();\n\n\tconst srcPosition = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices() || doc.createAccessor().setArray(createIndices(srcPosition.getCount()));\n\tconst uniqueIndices = new Uint32Array(new Set(srcIndices.getArray()!));\n\n\t// (1) Compute per-attribute tolerances, pre-sort vertices.\n\n\tconst tolerance = Math.max(options.tolerance, Number.EPSILON);\n\tconst attributeTolerance: Record<string, number> = {};\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tattributeTolerance[semantic] = getAttributeTolerance(semantic, attribute, tolerance);\n\t}\n\n\tlogger.debug(`${NAME}: Tolerance thresholds: ${formatKV(attributeTolerance)}`);\n\n\tconst posA: vec3 = [0, 0, 0];\n\tconst posB: vec3 = [0, 0, 0];\n\n\tuniqueIndices.sort((a, b) => {\n\t\tsrcPosition.getElement(a, posA);\n\t\tsrcPosition.getElement(b, posB);\n\t\treturn posA[0] > posB[0] ? 1 : -1;\n\t});\n\n\t// (2) Compare and identify vertices to weld. Use sort to keep iterations below O(n²),\n\n\tconst weldMap = createIndices(uniqueIndices.length); // oldIndex → oldCommonIndex\n\tconst writeMap = createIndices(uniqueIndices.length); // oldIndex → newIndex\n\n\tconst srcVertexCount = srcPosition.getCount();\n\tlet dstVertexCount = 0;\n\tlet backIters = 0;\n\n\tfor (let i = 0; i < uniqueIndices.length; i++) {\n\t\tconst a = uniqueIndices[i];\n\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst b = weldMap[uniqueIndices[j]];\n\n\t\t\tsrcPosition.getElement(a, posA);\n\t\t\tsrcPosition.getElement(b, posB);\n\n\t\t\t// Sort order allows early exit on X-axis distance.\n\t\t\tif (Math.abs(posA[0] - posB[0]) > attributeTolerance['POSITION']) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbackIters++;\n\n\t\t\t// Weld if base attributes and morph target attributes match.\n\t\t\tconst isBaseMatch = prim.listSemantics().every((semantic) => {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t});\n\t\t\tconst isTargetMatch = prim.listTargets().every((target) => {\n\t\t\t\treturn target.listSemantics().every((semantic) => {\n\t\t\t\t\tconst attribute = target.getAttribute(semantic)!;\n\t\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (isBaseMatch && isTargetMatch) {\n\t\t\t\tweldMap[a] = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Output the vertex if we didn't find a match, else record the index of the match.\n\t\tif (weldMap[a] === a) {\n\t\t\twriteMap[a] = dstVertexCount++; // note: reorders the primitive on x-axis sort.\n\t\t} else {\n\t\t\twriteMap[a] = writeMap[weldMap[a]];\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Iterations per vertex: ${Math.round(backIters / uniqueIndices.length)} (avg)`);\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t// (3) Update indices.\n\n\tconst dstIndicesCount = srcIndices.getCount(); // # primitives does not change.\n\tconst dstIndicesArray = createIndices(dstIndicesCount, uniqueIndices.length);\n\tfor (let i = 0; i < dstIndicesCount; i++) {\n\t\tdstIndicesArray[i] = writeMap[srcIndices.getScalar(i)];\n\t}\n\tprim.setIndices(srcIndices.clone().setArray(dstIndicesArray));\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\t// (4) Update vertex attributes.\n\n\tfor (const srcAttr of prim.listAttributes()) {\n\t\tswapAttributes(prim, srcAttr, writeMap, dstVertexCount);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttr of target.listAttributes()) {\n\t\t\tswapAttributes(target, srcAttr, writeMap, dstVertexCount);\n\t\t}\n\t}\n}\n\n/** Creates a new TypedArray of the same type as an original, with a new length. */\nfunction createArrayOfType<T extends TypedArray>(array: T, length: number): T {\n\tconst ArrayCtor = array.constructor as new (length: number) => T;\n\treturn new ArrayCtor(length);\n}\n\n/** Replaces an {@link Attribute}, creating a new one with the given elements. */\nfunction swapAttributes(\n\tparent: Primitive | PrimitiveTarget,\n\tsrcAttr: Accessor,\n\treorder: Uint32Array | Uint16Array,\n\tdstCount: number\n): void {\n\tconst dstAttrArray = createArrayOfType(srcAttr.getArray()!, dstCount * srcAttr.getElementSize());\n\tconst dstAttr = srcAttr.clone().setArray(dstAttrArray);\n\tconst done = new Uint8Array(dstCount);\n\n\tfor (let i = 0, el = [] as number[]; i < reorder.length; i++) {\n\t\tif (!done[reorder[i]]) {\n\t\t\tdstAttr.setElement(reorder[i], srcAttr.getElement(i, el));\n\t\t\tdone[reorder[i]] = 1;\n\t\t}\n\t}\n\n\tparent.swap(srcAttr, dstAttr);\n\n\t// Clean up.\n\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n}\n\nconst _a = [] as number[];\nconst _b = [] as number[];\n\n/** Computes a per-attribute tolerance, based on domain and usage of the attribute. */\nfunction getAttributeTolerance(semantic: string, attribute: Accessor, tolerance: number): number {\n\t// Attributes like NORMAL and COLOR_# do not vary in range like POSITION,\n\t// so do not apply the given tolerance factor to these attributes.\n\tif (semantic === 'NORMAL' || semantic === 'TANGENT') return Tolerance.NORMAL;\n\tif (semantic.startsWith('COLOR_')) return Tolerance.COLOR;\n\tif (semantic.startsWith('TEXCOORD_')) return Tolerance.TEXCOORD;\n\tif (semantic.startsWith('JOINTS_')) return Tolerance.JOINTS;\n\tif (semantic.startsWith('WEIGHTS_')) return Tolerance.WEIGHTS;\n\n\t_a.length = _b.length = 0;\n\tattribute.getMinNormalized(_a);\n\tattribute.getMaxNormalized(_b);\n\tconst range = Math.max(..._b) - Math.min(..._a) || 1;\n\treturn tolerance * range;\n}\n\n/** Compares two vertex attributes against a tolerance threshold. */\nfunction compareAttributes(attribute: Accessor, a: number, b: number, tolerance: number, _semantic: string): boolean {\n\tattribute.getElement(a, _a);\n\tattribute.getElement(b, _b);\n\tfor (let i = 0, il = attribute.getElementSize(); i < il; i++) {\n\t\tif (Math.abs(_a[i] - _b[i]) > tolerance) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction formatKV(kv: Record<string, unknown>): string {\n\treturn Object.entries(kv)\n\t\t.map(([k, v]) => `${k}=${v}`)\n\t\t.join(', ');\n}\n","import { Accessor, Document, Primitive, PropertyType, Transform, TransformContext } from '@gltf-transform/core';\nimport {\n\tcreateTransform,\n\tformatDeltaOp,\n\tdeepListAttributes,\n\tremapAttribute,\n\tdeepSwapAttribute,\n\tisTransformPending,\n} from './utils';\nimport { weld } from './weld';\nimport type { MeshoptSimplifier } from 'meshoptimizer';\nimport { dedup } from './dedup';\n\nconst NAME = 'simplify';\n\n/** Options for the {@link simplify} function. */\nexport interface SimplifyOptions {\n\t/** MeshoptSimplifier instance. */\n\tsimplifier: unknown;\n\t/** Target ratio (0–1) of vertices to keep. Default: 0.5 (50%). */\n\tratio?: number;\n\t/** Limit on error, as a fraction of mesh radius. Default: 0.01 (1%). */\n\terror?: number;\n\t/**\n\t * Whether to lock topological borders of the mesh. May be necessary when\n\t * adjacent 'chunks' of a large mesh (e.g. terrain) share a border, helping\n\t * to ensure no seams appear.\n\t */\n\tlockBorder?: boolean;\n}\n\nexport const SIMPLIFY_DEFAULTS: Required<Omit<SimplifyOptions, 'simplifier'>> = {\n\tratio: 0.5,\n\terror: 0.001,\n\tlockBorder: false,\n};\n\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.5, error=0.001: Aims for 50% simplification, constrained to 0.1% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n * - ratio=0.0, error=0.01: Aims for maximum simplification, constrained to 1% error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({ tolerance: 0.0001 }),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n */\nexport const simplify = (_options: SimplifyOptions): Transform => {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier | undefined;\n\n\tif (!simplifier) {\n\t\tthrow new Error(`${NAME}: simplifier dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait simplifier.ready;\n\t\tawait document.transform(weld({ overwrite: false }));\n\n\t\t// Simplify mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`${NAME}: Skipping primitive of mesh \"${mesh.getName()}\": Requires TRIANGLES draw mode.`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsimplifyPrimitive(document, prim, options);\n\t\t\t}\n\t\t}\n\n\t\t// Where multiple primitive indices point into the same vertex streams, simplification\n\t\t// may write duplicate streams. Find and remove the duplicates after processing.\n\t\tif (!isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nexport function simplifyPrimitive(document: Document, prim: Primitive, _options: SimplifyOptions): Primitive {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\n\tconst logger = document.getLogger();\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcVertexCount = position.getCount();\n\n\tlet positionArray = position.getArray()!;\n\tlet indicesArray = srcIndices.getArray()!;\n\n\t// (1) Gather attributes and indices in Meshopt-compatible format.\n\n\tif (position.getComponentType() !== Accessor.ComponentType.FLOAT) {\n\t\tif (position.getNormalized()) {\n\t\t\tconst src = positionArray;\n\t\t\tconst dst = new Float32Array(src.length);\n\n\t\t\t// Dequantize.\n\t\t\tfor (let i = 0, il = position.getCount(), el = [] as number[]; i < il; i++) {\n\t\t\t\tel = position.getElement(i, el);\n\t\t\t\tposition.setArray(dst).setElement(i, el).setArray(src);\n\t\t\t}\n\n\t\t\tpositionArray = dst;\n\t\t} else {\n\t\t\tpositionArray = new Float32Array(positionArray);\n\t\t}\n\t}\n\n\tif (srcIndices.getComponentType() !== Accessor.ComponentType.UNSIGNED_INT) {\n\t\tindicesArray = new Uint32Array(indicesArray);\n\t}\n\n\t// (2) Run simplification.\n\n\tconst targetCount = Math.floor((options.ratio * srcVertexCount) / 3) * 3;\n\tconst [dstIndicesArray, error] = simplifier.simplify(\n\t\tindicesArray as Uint32Array,\n\t\tpositionArray as Float32Array,\n\t\t3,\n\t\ttargetCount,\n\t\toptions.error,\n\t\toptions.lockBorder ? ['LockBorder'] : []\n\t);\n\n\tconst [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(position.getCount(), unique)} vertices, error: ${error.toFixed(4)}.`);\n\n\t// (3) Write vertex attributes.\n\n\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\tconst dstAttribute = srcAttribute.clone();\n\t\tremapAttribute(dstAttribute, remap, unique);\n\t\tdeepSwapAttribute(prim, srcAttribute, dstAttribute);\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\t// (4) Write indices.\n\n\tconst dstIndices = srcIndices.clone();\n\tdstIndices.setArray(srcVertexCount <= 65534 ? new Uint16Array(dstIndicesArray) : dstIndicesArray);\n\tprim.setIndices(dstIndices);\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\treturn prim;\n}\n","import type { Document, Texture } from '@gltf-transform/core';\nimport { Material, TextureChannel, PropertyType } from '@gltf-transform/core';\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(document, texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n */\nexport function listTextureChannels(document: Document, texture: Texture): TextureChannel[] {\n\tconst mask = getTextureChannelMask(document, texture);\n\tconst channels = [];\n\tif (mask & TextureChannel.R) channels.push(TextureChannel.R);\n\tif (mask & TextureChannel.G) channels.push(TextureChannel.G);\n\tif (mask & TextureChannel.B) channels.push(TextureChannel.B);\n\tif (mask & TextureChannel.A) channels.push(TextureChannel.A);\n\treturn channels;\n}\n\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(document, texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function getTextureChannelMask(document: Document, texture: Texture): number {\n\tlet mask = 0x0000;\n\tfor (const edge of document.getGraph().listParentEdges(texture)) {\n\t\tconst parent = edge.getParent();\n\t\tlet { channels } = edge.getAttributes() as { channels: number | undefined };\n\n\t\tif (\n\t\t\tchannels &&\n\t\t\tedge.getName() === 'baseColorTexture' &&\n\t\t\tparent instanceof Material &&\n\t\t\tparent.getAlphaMode() === Material.AlphaMode.OPAQUE\n\t\t) {\n\t\t\tchannels &= ~TextureChannel.A;\n\t\t}\n\n\t\tif (channels) {\n\t\t\tmask |= channels;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\tdocument.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n\t\t}\n\t}\n\treturn mask;\n}\n","import type { Document, Texture } from '@gltf-transform/core';\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(document, texture);\n * // → ['occlusionTexture', 'metallicRoughnesTexture']\n * ```\n */\nexport function listTextureSlots(doc: Document, texture: Texture): string[] {\n\tconst root = doc.getRoot();\n\tconst slots = doc\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.filter((edge) => edge.getParent() !== root)\n\t\t.map((edge) => edge.getName());\n\treturn Array.from(new Set(slots));\n}\n","import { Document, TextureChannel, Transform } from '@gltf-transform/core';\nimport { TextureWebP } from '@gltf-transform/extensions';\nimport { getTextureChannelMask } from './list-texture-channels';\nimport { listTextureSlots } from './list-texture-slots';\nimport type { SquooshLib } from './types/squoosh-lib';\nimport { formatBytes } from './utils';\n\nenum Codec {\n\tOXIPNG = 'oxipng',\n\tMOZJPEG = 'mozjpeg',\n\tWEBP = 'webp',\n}\n\nconst CODEC_TO_MIME_TYPE: Record<Codec, string> = {\n\t[Codec.OXIPNG]: 'image/png',\n\t[Codec.MOZJPEG]: 'image/jpeg',\n\t[Codec.WEBP]: 'image/webp',\n};\n\n// TODO(feat): There are _many_ other encoder options for each of the\n// codecs provided here, but the options are mostly undocumented. If\n// anyone is willing to contribute documentation on what the options\n// are, I'm happy to expose more here.\n// See: https://github.com/GoogleChromeLabs/squoosh/blob/dev/libsquoosh/src/codecs.ts\nexport interface SquooshOptions {\n\tsquoosh: unknown;\n\tjobs?: number;\n\tformats?: RegExp;\n\tslots?: RegExp;\n\tauto?: boolean;\n}\n\ninterface SquooshInternalOptions extends SquooshOptions {\n\tcodec: Codec;\n}\n\nconst SQUOOSH_DEFAULTS: Required<Omit<Omit<SquooshInternalOptions, 'codec'>, 'squoosh'>> = {\n\tjobs: 4,\n\tformats: /.*/,\n\tslots: /.*/,\n\tauto: false,\n};\n\nconst WEBP_DEFAULTS: Omit<SquooshInternalOptions, 'squoosh'> = {\n\t...SQUOOSH_DEFAULTS,\n\tcodec: Codec.WEBP,\n};\nconst MOZJPEG_DEFAULTS: Omit<SquooshInternalOptions, 'squoosh'> = {\n\t...SQUOOSH_DEFAULTS,\n\tcodec: Codec.MOZJPEG,\n\tformats: /^image\\/jpeg$/,\n};\nconst OXIPNG_DEFAULTS: Omit<SquooshInternalOptions, 'squoosh'> = {\n\t...SQUOOSH_DEFAULTS,\n\tcodec: Codec.OXIPNG,\n\tformats: /^image\\/png$/,\n};\n\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp'];\n\nlet pool: SquooshLib.ImagePool | null = null;\nlet poolUsers = 0;\n\nconst requestImagePool = (squoosh: typeof SquooshLib, jobs: number): SquooshLib.ImagePool => {\n\tif (!pool) {\n\t\tpool = new squoosh.ImagePool(jobs);\n\t}\n\tpoolUsers++;\n\treturn pool;\n};\n\nconst releaseImagePool = (): void => {\n\tpoolUsers--;\n\tif (pool && poolUsers <= 0) {\n\t\tpool.close(); // Required for process to exit.\n\t\tpool = null;\n\t}\n};\n\n/** @internal Shared base for {@link webp()}, {@link mozjpeg()}, and {@link oxipng()}. */\nexport const squoosh = function (_options: SquooshInternalOptions): Transform {\n\tconst options = { ...SQUOOSH_DEFAULTS, ..._options } as Required<SquooshInternalOptions>;\n\tconst squoosh = options.squoosh as typeof SquooshLib | null;\n\tconst codec = options.codec;\n\n\tif (!squoosh) {\n\t\tthrow new Error(`${codec}: squoosh dependency required — install \"@squoosh/lib\".`);\n\t}\n\n\treturn async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst textures = document.getRoot().listTextures();\n\t\tconst pool = requestImagePool(squoosh, options.jobs);\n\n\t\tawait Promise.all(\n\t\t\ttextures.map(async (texture, textureIndex) => {\n\t\t\t\tconst slots = listTextureSlots(document, texture);\n\t\t\t\tconst channels = getTextureChannelMask(document, texture);\n\t\t\t\tconst textureLabel =\n\t\t\t\t\ttexture.getURI() ||\n\t\t\t\t\ttexture.getName() ||\n\t\t\t\t\t`${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n\t\t\t\tconst prefix = `${codec}:texture(${textureLabel})`;\n\n\t\t\t\t// FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n\n\t\t\t\tif (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (!options.formats.test(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (slots.length && !slots.some((slot) => options.slots.test(slot))) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (options.codec === Codec.MOZJPEG && channels & TextureChannel.A) {\n\t\t\t\t\tlogger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${prefix}: Slots → [${slots.join(', ')}]`);\n\n\t\t\t\t// COMPRESS: Run `squoosh/lib` library.\n\n\t\t\t\tconst image = pool.ingestImage(texture.getImage()!);\n\t\t\t\tconst srcByteLength = texture.getImage()!.byteLength;\n\n\t\t\t\tawait image.encode({ [options.codec]: options.auto ? 'auto' : {} });\n\n\t\t\t\tconst encodedImage = await image.encodedWith[options.codec];\n\n\t\t\t\tlogger.debug(`${prefix}: ${JSON.stringify(encodedImage.optionsUsed)}`);\n\n\t\t\t\ttexture.setImage(encodedImage.binary).setMimeType(CODEC_TO_MIME_TYPE[options.codec]);\n\t\t\t\tconst dstByteLength = encodedImage.binary.byteLength;\n\n\t\t\t\tlogger.debug(`${prefix}: ${formatBytes(srcByteLength)} → ${formatBytes(dstByteLength)}`);\n\t\t\t})\n\t\t);\n\n\t\treleaseImagePool();\n\n\t\tlogger.debug(`${codec}: Complete.`);\n\t};\n};\n\n/**\n * Converts images to WebP, using the {@link TextureWebP} extension.\n *\n * Requires `@squoosh/lib`, and currently works only in Node.js\n * environments. Support for encoding in web browsers may be available pending\n * [GoogleChromeLabs/squoosh#1084](https://github.com/GoogleChromeLabs/squoosh/issues/1084).\n *\n * Example:\n *\n * ```javascript\n * import { cpus } from 'os';\n * import * as squoosh from '@squoosh/lib';\n * import { webp } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \twebp({ squoosh, jobs: cpus().length })\n * );\n * ```\n */\nexport const webp = function (options: SquooshOptions): Transform {\n\tconst _options = { ...WEBP_DEFAULTS, ...options } as SquooshInternalOptions;\n\treturn async (document: Document): Promise<void> => {\n\t\tawait squoosh(_options)(document);\n\n\t\t// Attach EXT_texture_web if needed.\n\t\tconst textures = document.getRoot().listTextures();\n\t\tif (textures.some((texture) => texture.getMimeType() === CODEC_TO_MIME_TYPE[Codec.WEBP])) {\n\t\t\tdocument.createExtension(TextureWebP).setRequired(true);\n\t\t}\n\t};\n};\n\n/**\n * Optimizes JPEG images by default, optionally converting PNG textures to JPEG.\n *\n * Requires `@squoosh/lib`, and currently works only in Node.js\n * environments. Support for encoding in web browsers may be available pending\n * [GoogleChromeLabs/squoosh#1084](https://github.com/GoogleChromeLabs/squoosh/issues/1084).\n *\n * Example:\n *\n * ```javascript\n * import { cpus } from 'os';\n * import * as squoosh from '@squoosh/lib';\n * import { mozjpeg } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tmozjpeg({ squoosh, jobs: cpus().length })\n * );\n * ```\n */\nexport const mozjpeg = function (options: SquooshOptions): Transform {\n\tconst _options = { ...MOZJPEG_DEFAULTS, ...options } as SquooshInternalOptions;\n\treturn (document: Document): void => {\n\t\treturn squoosh(_options)(document);\n\t};\n};\n\n/**\n * Optimizes PNG images by default, optionally converting JPEG textures to PNG.\n *\n * Requires `@squoosh/lib`, and currently works only in Node.js\n * environments. Support for encoding in web browsers may be available pending\n * [GoogleChromeLabs/squoosh#1084](https://github.com/GoogleChromeLabs/squoosh/issues/1084).\n *\n * Example:\n *\n * ```javascript\n * import { cpus } from 'os';\n * import * as squoosh from '@squoosh/lib';\n * import { oxipng } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \toxipng({ squoosh, jobs: cpus().length })\n * );\n * ```\n */\nexport const oxipng = function (options: SquooshOptions): Transform {\n\tconst _options = { ...OXIPNG_DEFAULTS, ...options } as SquooshInternalOptions;\n\treturn (document: Document): void => {\n\t\treturn squoosh(_options)(document);\n\t};\n};\n","import { Accessor, Document, ILogger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array;\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean;\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n */\nexport function tangents(_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tif (!_options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required — install \"mikktspace\".`);\n\t}\n\n\tconst options = { ...TANGENTS_DEFAULTS, ..._options } as Required<TangentsOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord)\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(prim: Primitive, logger: ILogger, meshName: string, i: number, overwrite: boolean): boolean {\n\tif (\n\t\tprim.getMode() !== Primitive.Mode.TRIANGLES ||\n\t\t!prim.getAttribute('POSITION') ||\n\t\t!prim.getAttribute('NORMAL') ||\n\t\t!prim.getAttribute('TEXCOORD_0')\n\t) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` +\n\t\t\t\t' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.'\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\t// TODO(feat): Do this automatically for qualifying primitives.\n\t\tlogger.warn(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","import ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport type { Document, Transform, vec2 } from '@gltf-transform/core';\nimport { listTextureSlots } from './list-texture-slots';\nimport { createTransform } from './utils';\n\nconst NAME = 'textureResize';\n\n/** Options for the {@link textureResize} function. */\nexport interface TextureResizeOptions {\n\t/**\n\t * Maximum width/height to enforce, preserving aspect ratio. For example,\n\t * a 4096x8192 texture, resized with limit [2048, 2048] will be reduced\n\t * to 1024x2048.\n\t */\n\tsize: vec2;\n\t/** Resampling filter method. LANCZOS3 is sharper, LANCZOS2 is smoother. */\n\tfilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to resize, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/** Pattern to match slots usage for resizing. */\n\tslots?: RegExp | null;\n}\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport const TEXTURE_RESIZE_DEFAULTS: TextureResizeOptions = {\n\tsize: [2048, 2048],\n\tfilter: TextureResizeFilter.LANCZOS3,\n\tpattern: null,\n\tslots: null,\n};\n\n/**\n * Resize PNG or JPEG {@link Texture Textures}, with {@link https://en.wikipedia.org/wiki/Lanczos_algorithm Lanczos filtering}.\n * Implementation provided by {@link https://github.com/donmccurdy/ndarray-lanczos ndarray-lanczos} package.\n */\nexport function textureResize(_options: TextureResizeOptions = TEXTURE_RESIZE_DEFAULTS): Transform {\n\tconst options = { ...TEXTURE_RESIZE_DEFAULTS, ..._options } as Required<TextureResizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const texture of doc.getRoot().listTextures()) {\n\t\t\tconst name = texture.getName();\n\t\t\tconst uri = texture.getURI();\n\t\t\tconst match = !options.pattern || options.pattern.test(name) || options.pattern.test(uri);\n\t\t\tif (!match) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {\n\t\t\t\tlogger.warn(`${NAME}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst slots = listTextureSlots(doc, texture);\n\t\t\tif (options.slots && !slots.some((slot) => options.slots?.test(slot))) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst [maxWidth, maxHeight] = options.size;\n\t\t\tconst [srcWidth, srcHeight] = texture.getSize()!;\n\n\t\t\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, not within size range.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dstWidth = srcWidth;\n\t\t\tlet dstHeight = srcHeight;\n\n\t\t\tif (dstWidth > maxWidth) {\n\t\t\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\t\t\tdstWidth = maxWidth;\n\t\t\t}\n\n\t\t\tif (dstHeight > maxHeight) {\n\t\t\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\t\t\tdstHeight = maxHeight;\n\t\t\t}\n\n\t\t\tconst srcImage = texture.getImage()!;\n\t\t\tconst srcPixels = await getPixels(srcImage, texture.getMimeType());\n\t\t\tconst dstPixels = ndarray(new Uint8Array(dstWidth * dstHeight * 4), [dstWidth, dstHeight, 4]);\n\n\t\t\tlogger.debug(`${NAME}: Resizing \"${uri || name}\", ${srcPixels.shape} → ${dstPixels.shape}...`);\n\t\t\tlogger.debug(`${NAME}: Slots → [${slots.join(', ')}]`);\n\n\t\t\ttry {\n\t\t\t\toptions.filter === TextureResizeFilter.LANCZOS3\n\t\t\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\tlogger.warn(`${NAME}: Failed to resize \"${uri || name}\": \"${e.message}\".`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\ttexture.setImage(await savePixels(dstPixels, texture.getMimeType()));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { vec3, mat4, Accessor, Primitive, vec4, Mesh, PropertyType, PrimitiveTarget } from '@gltf-transform/core';\nimport { create as createMat3, fromMat4, invert, transpose } from 'gl-matrix/mat3';\nimport { create as createVec3, normalize as normalizeVec3, transformMat3, transformMat4 } from 'gl-matrix/vec3';\nimport { create as createVec4 } from 'gl-matrix/vec4';\nimport { createIndices, deepListAttributes } from './utils';\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * Method:\n * - If any primitives are shared by other meshes, they will be detached.\n * - If any vertex streams are shared by primitives of other meshes, vertex data\n *  will be overwritten unless _overwrite=false_ or the indices are masked. If\n * \t_overwrite=false_, a detached copy of the vertex stream is made before applying\n * \tthe transform.\n * - Primitives within the mesh sharing vertex streams will continue to share those streams.\n * - For indexed primitives, only indexed vertices are modified.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n * @param overwrite Whether to overwrite vertex streams in place. If false,\n * \t\tstreams shared with other meshes will be detached.\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformMesh(mesh: Mesh, matrix: mat4, overwrite = false, skipIndices?: Set<number>): void {\n\t// (1) Detach shared prims.\n\tfor (const srcPrim of mesh.listPrimitives()) {\n\t\tconst isShared = srcPrim.listParents().some((p) => p.propertyType === PropertyType.MESH && p !== mesh);\n\t\tif (isShared) {\n\t\t\tconst dstPrim = srcPrim.clone();\n\t\t\tmesh.swap(srcPrim, dstPrim);\n\n\t\t\tfor (const srcTarget of dstPrim.listTargets()) {\n\t\t\t\tconst dstTarget = srcTarget.clone();\n\t\t\t\tdstPrim.swap(srcTarget, dstTarget);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (2) Detach shared vertex streams.\n\tif (!overwrite) {\n\t\tconst parents = new Set<Primitive | PrimitiveTarget>([\n\t\t\t...mesh.listPrimitives(),\n\t\t\t...mesh.listPrimitives().flatMap((prim) => prim.listTargets()),\n\t\t]);\n\t\tconst attributes = new Map<Accessor, Accessor>();\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\t\t\tconst isShared = srcAttribute\n\t\t\t\t\t.listParents()\n\t\t\t\t\t.some((a) => (a instanceof Primitive || a instanceof PrimitiveTarget) && !parents.has(a));\n\t\t\t\tif (isShared && !attributes.has(srcAttribute)) {\n\t\t\t\t\tattributes.set(srcAttribute, srcAttribute.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const parent of parents) {\n\t\t\tfor (const [srcAttribute, dstAttribute] of attributes) {\n\t\t\t\tparent.swap(srcAttribute, dstAttribute);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (3) Apply transform.\n\tskipIndices = skipIndices || new Set<number>();\n\tfor (const prim of mesh.listPrimitives()) {\n\t\ttransformPrimitive(prim, matrix, skipIndices);\n\t}\n}\n\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * When calling {@link transformPrimitive}, any un-masked vertices are overwritten\n * directly in the underlying vertex streams. If streams should be detached instead,\n * see {@link transformMesh}.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformPrimitive(prim: Primitive, matrix: mat4, skipIndices = new Set<number>()): void {\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst indices = (prim.getIndices()?.getArray() || createIndices(position!.getCount())) as Uint32Array;\n\n\t// Apply transform to base attributes.\n\tif (position) {\n\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t}\n\n\tconst normal = prim.getAttribute('NORMAL');\n\tif (normal) {\n\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t}\n\n\tconst tangent = prim.getAttribute('TANGENT');\n\tif (tangent) {\n\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t}\n\n\t// Apply transform to morph attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tconst position = target.getAttribute('POSITION');\n\t\tif (position) {\n\t\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst normal = target.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst tangent = target.getAttribute('TANGENT');\n\t\tif (tangent) {\n\t\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t\t}\n\t}\n\n\t// Update mask.\n\tfor (let i = 0; i < indices.length; i++) skipIndices.add(indices[i]);\n}\n\nfunction applyMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\t// An arbitrary transform may not keep vertex positions in the required\n\t// range of a normalized attribute. Replace the array, instead.\n\tconst dstArray = new Float32Array(attribute.getCount() * 3);\n\tconst elementSize = attribute.getElementSize();\n\n\tfor (let i = 0, el: number[] = [], il = attribute.getCount(); i < il; i++) {\n\t\tdstArray.set(attribute.getElement(i, el), i * elementSize);\n\t}\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat4(vector, vector, matrix);\n\t\tdstArray.set(vector, index * 3);\n\n\t\tskipIndices.add(index);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nfunction applyNormalMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst normalMatrix = createMat3();\n\tfromMat4(normalMatrix, matrix);\n\tinvert(normalMatrix, normalMatrix);\n\ttranspose(normalMatrix, normalMatrix);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat3(vector, vector, normalMatrix);\n\t\tnormalizeVec3(vector, vector);\n\t\tattribute.setElement(index, vector);\n\n\t\tskipIndices.add(index);\n\t}\n}\n\nfunction applyTangentMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst v3 = createVec3() as vec3;\n\tconst v4 = createVec4() as vec4;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, v4);\n\n\t\t// mat4 affine matrix applied to vector, vector interpreted as a direction.\n\t\t// Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n\t\tconst [x, y, z] = v4;\n\t\tv3[0] = matrix[0] * x + matrix[4] * y + matrix[8] * z;\n\t\tv3[1] = matrix[1] * x + matrix[5] * y + matrix[9] * z;\n\t\tv3[2] = matrix[2] * x + matrix[6] * y + matrix[10] * z;\n\t\tnormalizeVec3(v3, v3);\n\n\t\t(v4[0] = v3[0]), (v4[1] = v3[1]), (v4[2] = v3[2]);\n\n\t\tattribute.setElement(index, v4);\n\n\t\tskipIndices.add(index);\n\t}\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { MaterialsUnlit } from '@gltf-transform/extensions';\n\nexport const unlit = (): Transform => {\n\treturn (doc: Document): void => {\n\t\tconst unlitExtension = doc.createExtension(MaterialsUnlit) as MaterialsUnlit;\n\t\tconst unlit = unlitExtension.createUnlit();\n\t\tdoc.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tmaterial.setExtension('KHR_materials_unlit', unlit);\n\t\t\t});\n\t};\n};\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'unpartition';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnpartitionOptions {}\nconst UNPARTITION_DEFAULTS: Required<UnpartitionOptions> = {};\n\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); // → [Buffer]\n * ```\n */\nconst unpartition = (_options: UnpartitionOptions = UNPARTITION_DEFAULTS): Transform => {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNPARTITION_DEFAULTS, ..._options } as Required<UnpartitionOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tconst buffer = document.getRoot().listBuffers()[0];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listAccessors()\n\t\t\t.forEach((a) => a.setBuffer(buffer));\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.forEach((b, index) => (index > 0 ? b.dispose() : null));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nexport { unpartition };\n","import { Document, Texture, TextureInfo } from '@gltf-transform/core';\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given {@link Texture}.\n *\n * Example:\n *\n * ```js\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(document, texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 0, 1]\n * ```\n */\nexport function listTextureInfo(document: Document, texture: Texture): TextureInfo[] {\n\tconst graph = document.getGraph();\n\tconst results: TextureInfo[] = [];\n\n\tfor (const textureEdge of graph.listParentEdges(texture)) {\n\t\tconst parent = textureEdge.getParent();\n\t\tconst name = textureEdge.getName() + 'Info';\n\n\t\tfor (const edge of graph.listChildEdges(parent)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (child instanceof TextureInfo && edge.getName() === name) {\n\t\t\t\tresults.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n"],"names":["rewriteTexture","source","target","fn","srcImage","getImage","getPixels","getMimeType","pixels","i","shape","j","savePixels","dstImage","setImage","setMimeType","createTransform","name","Object","defineProperty","value","isTransformPending","context","initial","pending","stack","lastIndexOf","SetMap","_map","Map","size","has","k","add","v","entry","this","get","Set","set","keys","formatBytes","bytes","decimals","dm","Math","floor","log","parseFloat","pow","toFixed","formatLong","x","toString","replace","formatDeltaOp","a","b","abs","formatDelta","deepListAttributes","prim","accessors","attribute","listAttributes","push","listTargets","Array","from","deepSwapAttribute","src","dst","swap","remapAttribute","remap","dstCount","elementSize","getElementSize","srcCount","getCount","srcArray","getArray","dstArray","slice","setArray","createIndices","count","maxIndex","array","Uint16Array","Uint32Array","length","CENTER_DEFAULTS","pivot","NAME","DEDUP_DEFAULTS","propertyTypes","PropertyType","ACCESSOR","MESH","TEXTURE","MATERIAL","dedup","_options","options","propertyType","includes","Error","doc","logger","getLogger","indicesAccessors","attributeAccessors","inputAccessors","outputAccessors","meshes","getRoot","listMeshes","forEach","mesh","listPrimitives","primitive","accessor","indices","getIndices","animation","listAnimations","sampler","listSamplers","input","getInput","output","getOutput","detectDuplicates","duplicateAccessors","aData","BufferUtils","toView","getType","getComponentType","getNormalized","equals","duplicateIndices","debug","duplicateAttributes","duplicateInputs","duplicateOutputs","dispose","dedupAccessors","root","textures","listTextures","duplicates","bData","aSize","getSize","bSize","entries","listParents","property","Root","dedupImages","materials","listMaterials","skip","dedupMaterials","refs","listAccessors","index","material","numMeshes","uniqueMeshes","srcKeyItems","createPrimitiveKey","meshKey","join","targetMesh","parent","ROOT","dedupMeshes","primKeyItems","semantic","listSemantics","getAttribute","Primitive","getMaterial","getMode","DEQUANTIZE_DEFAULTS","pattern","dequantizePrimitive","dequantizeAttribute","test","getComponentSize","Float32Array","il","el","getElement","setElement","setNormalized","DRACO_DEFAULTS","method","encodeSpeed","decodeSpeed","quantizePosition","quantizeNormal","quantizeColor","quantizeTexcoord","quantizeGeneric","quantizationVolume","listScenes","properties","map","scene","listChildren","sceneBounds","bounds","getName","rootName","bboxMin","toPrecision","min","bboxMax","max","instances","filter","glPrimitives","verts","semantics","meshIndices","meshAccessors","attr","accessorToTypeLabel","targ","position","Mode","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","getGLPrimitiveCount","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","sort","attributes","extensions","listExtensions","slots","getGraph","listEdges","ref","child","getChild","getParent","Texture","ExtensionProperty","alphaMode","getAlphaMode","doubleSided","getDoubleSided","texture","listParentEdges","edge","resolution","ImageUtils","compression","dfd","readKTX","dataFormatDescriptor","colorModel","KHR_DF_MODEL_ETC1S","KHR_DF_MODEL_UASTC","uri","getURI","mimeType","gpuSize","getMemSize","anim","minTime","Infinity","maxTime","getMin","getMax","keyframes","channels","listChannels","samplers","duration","round","NumericTypeLabels","Uint8Array","Int32Array","Int16Array","Int8Array","Number","constructor","INSTANCE_DEFAULTS","pruneUnusedNodes","nodes","node","unusedNodes","pop","getCamera","getMesh","getSkin","nodeParent","Node","createBatch","batchExtension","buffer","getBuffer","batchTranslation","createAccessor","setType","setBuffer","batchRotation","batchScale","createInstancedMesh","setAttribute","PRUNE_DEFAULTS","NODE","SKIN","CAMERA","PRIMITIVE","PRIMITIVE_TARGET","ANIMATION","BUFFER","keepLeaves","keepAttributes","prune","graph","disposed","nodeTreeShake","prop","Scene","isUsed","some","e","ptype","SCENE","markDisposed","listNodes","treeShake","listSkins","listCameras","indirectTreeShake","required","listRequiredSemantics","unused","listUnusedSemantics","pruneAttributes","channel","getTargetNode","listBuffers","str","t","info","p","AnimationChannel","startsWith","document","edges","listChildEdges","textureNames","TextureInfo","getTexCoord","match","REORDER_DEFAULTS","reorder","encoder","ready","plan","createLayoutPlan","srcIndices","indicesToAttributes","dstIndices","clone","indicesArray","unique","reorderMesh","indicesToMode","srcAttribute","dstAttribute","attributesToPrimitives","transform","warn","sortPrimitiveWeights","limit","isFinite","vertexCount","setCount","srcWeights","dstWeights","srcJoints","dstJoints","getVertexArray","setVertexArray","weights","joints","normList","typeList","isNormalizeSafe","templateAttribute","templateArray","componentType","normalized","normalizedComponentType","undefined","delta","MathUtils","denormalize","EPSILON","fill","weightsSum","sum","intValue","normalize","normalizePrimitiveWeights","vertexIndex","prefix","values","SIGNED_INT","TRANSLATION","ROTATION","SCALE","WEIGHTS","TargetPath","TRS_CHANNELS","QUANTIZE_DEFAULTS","quantizeWeight","normalizeWeights","quantize","nodeTransform","createExtension","MeshQuantization","setRequired","getNodeTransform","bboxes","result","bbox","expandBounds","getPositionQuantizationVolume","transformMeshParents","transformMeshMaterials","scale","quantizePrimitive","bits","ctor","getQuantizationSettings","invert","fromTransform","fromScaling","transformMat4","quantizeAttribute","volume","offset","transformMatrix","animChannels","isAnimated","getTargetPath","isParentNode","setSkin","transformSkin","targetNode","createNode","setMesh","addChild","setTargetNode","nodeMatrix","getMatrix","multiplyMat4","setMatrix","skin","inverseBindMatrices","getInverseBindMatrices","ibm","setInverseBindMatrices","getExtension","getThicknessFactor","setThicknessFactor","setExtension","setMaterial","signBits","quantBits","storageBits","BYTES_PER_ELEMENT","lo","hi","di","sign","getMinNormalized","getMaxNormalized","positions","relativePositions","flatBounds","relMin","relMax","tmpMin","tmpMax","fromRotationTranslationScale","MESHOPT_DEFAULTS","level","state","pact","_isSettledPact","thenable","s","METALROUGH_DEFAULTS","UNWELD_DEFAULTS","unweld","visited","srcVertexCount","unweldAttribute","dstVertexCount","setIndices","ArrayCtor","getScalar","NORMALS_DEFAULTS","overwrite","computeNormal","c","A","B","PARTITION_DEFAULTS","animations","createBufferURI","basename","existing","RESAMPLE_DEFAULTS","tolerance","optimize","path","interpolation","getInterpolation","lastIndex","tmp","valueNext","valuePrev","writeIndex","timePrev","time","timeNext","keep","sample","slerp","angle","getAngle","eq","PI","vlerp","setScalar","setInput","setOutput","lerp","v0","v1","out","SEQUENCE_DEFAULTS","fps","WELD_DEFAULTS","weld","weldPrimitive","numVertices","Accessor","Type","SCALAR","_indexPrimitive","srcPosition","uniqueIndices","attributeTolerance","getAttributeTolerance","kv","posA","posB","weldMap","writeMap","backIters","isBaseMatch","every","compareAttributes","isTargetMatch","dstIndicesCount","dstIndicesArray","srcAttr","swapAttributes","_weldPrimitive","dstAttrArray","dstAttr","done","_a","_b","_semantic","SIMPLIFY_DEFAULTS","ratio","error","lockBorder","simplifyPrimitive","simplifier","positionArray","ComponentType","FLOAT","UNSIGNED_INT","targetCount","simplify","compactMesh","getTextureChannelMask","mask","getAttributes","Material","AlphaMode","OPAQUE","TextureChannel","listTextureSlots","Codec","CODEC_TO_MIME_TYPE","[object Object]","OXIPNG","MOZJPEG","WEBP","SQUOOSH_DEFAULTS","jobs","formats","auto","WEBP_DEFAULTS","codec","MOZJPEG_DEFAULTS","OXIPNG_DEFAULTS","SUPPORTED_MIME_TYPES","pool","poolUsers","requestImagePool","squoosh","ImagePool","releaseImagePool","close","Promise","all","textureIndex","textureLabel","slot","image","ingestImage","srcByteLength","encode","encodedWith","encodedImage","JSON","stringify","optionsUsed","binary","dstByteLength","TANGENTS_DEFAULTS","getNormalTexcoord","normalTextureInfo","getNormalTextureInfo","filterPrimitive","meshName","_Pact","bind","o","prototype","onFulfilled","TextureResizeFilter","TEXTURE_RESIZE_DEFAULTS","LANCZOS3","transformPrimitive","matrix","skipIndices","applyMatrix","normal","applyNormalMatrix","tangent","applyTangentMatrix","vector","createVec3","normalMatrix","createMat3","fromMat4","transpose","transformMat3","normalizeVec3","v3","v4","createVec4","y","z","unlit","UNPARTITION_DEFAULTS","offsetNode","setTranslation","getTranslation","inputEncoding","converted","sRGBToLinear","updatePrimitive","color","DracoMeshCompression","setEncoderOptions","EncoderMethod","EDGEBREAKER","SEQUENTIAL","quantizationBits","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","scenes","MeshGPUInstancing","numBatches","numInstances","meshInstances","traverse","modifiedNodes","batch","batchNode","needsTranslation","needsRotation","needsScale","r","getWorldTranslation","getWorldRotation","getWorldScale","listProperties","R","G","results","textureEdge","MeshoptCompression","QUANTIZE","FILTER","specGlossExtension","tex","inputTextures","listExtensionsUsed","ext","extensionName","iorExtension","MaterialsIOR","specExtension","MaterialsSpecular","MaterialsPBRSpecularGlossiness","specGloss","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","createTexture","setSpecularTexture","setSpecularColorTexture","getSpecularTextureInfo","getSpecularColorTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","modified","faceNormal","existingURIs","meshIndex","isArray","createBuffer","setURI","primTarget","partitionMeshes","animIndex","partitionAnimations","didSkipMorphTargets","accessorsVisited","srcAccessorCount","samplerTargetPaths","getSampler","dstAccessorCount","sequenceNodes","createAnimation","animBuffer","inputArray","outputArray","VEC3","createAnimationSampler","setInterpolation","AnimationSampler","Interpolation","STEP","createAnimationChannel","setTargetPath","setSampler","addSampler","addChannel","generateTangents","attributeIDs","tangentCache","meshPrimitives","texcoordSemantic","texcoord","positionID","uuid","normalID","texcoordID","prevTangent","attributeHash","tangentBuffer","tangentArray","maxWidth","maxHeight","srcWidth","srcHeight","dstWidth","dstHeight","srcPixels","dstPixels","ndarray","lanczos3","lanczos2","message","_setImage","srcPrim","dstPrim","srcTarget","dstTarget","parents","flatMap","PrimitiveTarget","MaterialsUnlit","createUnlit","TextureWebP"],"mappings":"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"}