var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import { Matrix4 } from "three";
import { WebXR } from "./WebXR";
import { InstancingUtil } from "../engine/engine_instancing";
import { serializable } from "../engine/engine_serialization_decorator";
// https://github.com/takahirox/takahirox.github.io/blob/master/js.mmdeditor/examples/js/controls/DeviceOrientationControls.js
export class WebARSessionRoot extends Behaviour {
    webAR = null;
    get rig() {
        return this.webAR?.webxr.Rig;
    }
    invertForward = false;
    get arScale() {
        return this._arScale;
    }
    set arScale(val) {
        if (val === this._arScale)
            return;
        this._arScale = val;
        this.setScale(val);
    }
    _initalMatrix = new Matrix4();
    _selectStartFn = this.onSelectStart.bind(this);
    _selectEndFn = this.onSelectEnd.bind(this);
    start() {
        const xr = GameObject.findObjectOfType(WebXR);
        if (xr) {
            xr.Rig.updateMatrix();
            this._initalMatrix.copy(xr.Rig.matrix);
        }
    }
    _arScale = 5;
    _rig = null;
    _startPose = null;
    _placementPose = null;
    _isTouching = false;
    _rigStartPose = null;
    onBegin(session) {
        this._placementPose = null;
        this.gameObject.visible = false;
        this.gameObject.matrixAutoUpdate = false;
        this._startPose = this.gameObject.matrix.clone();
        this._rigStartPose = this.rig?.matrix.clone();
        session.addEventListener('selectstart', this._selectStartFn);
        session.addEventListener('selectend', this._selectEndFn);
        // setTimeout(() => this.gameObject.visible = false, 1000); // TODO test on phone AR and Hololens if this was still needed
        // console.log(this.rig?.position, this.rig?.quaternion, this.rig?.scale);
        this.gameObject.visible = false;
        if (this.rig) {
            // reset rig to initial pose, this is helping the mix of immersive AR and immersive VR that we now have on quest
            // where the rig can be moved and scaled by the user in VR mode and we use the rig position when entering
            // immersive Ar right now to place the user/offset the session
            this.rig.matrixAutoUpdate = true;
            this._initalMatrix.decompose(this.rig.position, this.rig.quaternion, this.rig.scale);
        }
    }
    onUpdate(rig, _session, pose) {
        if (pose && !this._placementPose) {
            if (this._isTouching) {
                if (this.webAR)
                    this.webAR.setReticleActive(false);
                this.placeAt(rig, new Matrix4().fromArray(pose.transform.matrix).invert());
                return true;
            }
        }
        return false;
        // if (this._placementPose) {
        //     this.gameObject.matrixAutoUpdate = false;
        //     const matrix = pose?.transform.matrix;
        //     if (matrix) {
        //         this.gameObject.matrix.fromArray(matrix);
        //     }
        //     this.gameObject.visible = true;
        // }
    }
    placeAt(rig, mat) {
        if (!this._placementPose)
            this._placementPose = new Matrix4();
        this._placementPose.copy(mat);
        if (rig) {
            if (this.invertForward) {
                const rot = new Matrix4().makeRotationY(Math.PI);
                this._placementPose.premultiply(rot);
            }
            this._rig = rig;
            this.setScale(this.arScale);
        }
        else
            this._rig = null;
        // this.gameObject.matrix.copy(this._placementPose);
        // if (rig) {
        //     this.gameObject.matrix.premultiply(rig.matrixWorld)
        // }
        this.gameObject.visible = true;
    }
    onEnd(rig, _session) {
        this._placementPose = null;
        this.gameObject.visible = false;
        this.gameObject.matrixAutoUpdate = false;
        if (this._startPose) {
            this.gameObject.matrix.copy(this._startPose);
        }
        if (rig) {
            rig.matrixAutoUpdate = true;
            if (this._rigStartPose) {
                this._rigStartPose.decompose(rig.position, rig.quaternion, rig.scale);
                // console.log(rig.position, rig.quaternion, rig.scale);
            }
        }
        InstancingUtil.markDirty(this.gameObject, true);
        // HACK to fix physics being not in correct place after exiting AR
        setTimeout(() => {
            this.gameObject.matrixAutoUpdate = true;
            this.gameObject.visible = true;
        }, 100);
    }
    onSelectStart() {
        this._isTouching = true;
    }
    onSelectEnd() {
        this._isTouching = false;
    }
    setScale(scale) {
        const rig = this._rig;
        if (!rig || !this._placementPose) {
            return;
        }
        if (!this._rigStartPose) {
            this._rigStartPose = rig.matrix.clone();
        }
        rig.matrixAutoUpdate = false;
        rig.matrix.multiplyMatrices(new Matrix4().makeScale(scale, scale, scale), this._placementPose);
        rig.matrix.decompose(rig.position, rig.quaternion, rig.scale);
        rig.updateMatrixWorld();
        console.log("Place", rig.position);
    }
}
__decorate([
    serializable()
], WebARSessionRoot.prototype, "invertForward", void 0);
__decorate([
    serializable()
], WebARSessionRoot.prototype, "arScale", null);
//# sourceMappingURL=WebARSessionRoot.js.map