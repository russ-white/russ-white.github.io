var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import * as THREE from 'three';
import { getWorldPosition } from "../engine/engine_three_utils";
import { serializable } from "../engine/engine_serialization_decorator";
import { Watch } from "../engine/engine_utils";
import { Matrix4, Vector3 } from "three";
import { CollisionDetectionMode, RigidbodyConstraints } from "../engine/engine_physics.types";
import { validate } from "../engine/engine_util_decorator";
import { FrameEvent } from "../engine/engine_setup";
class TransformWatch {
    get isDirty() {
        return this.positionChanged || this.rotationChanged;
    }
    positionChanged = false;
    rotationChanged = false;
    position;
    quaternion;
    _positionKeys = ["x", "y", "z"];
    _quaternionKeys = ["_x", "_y", "_z", "_w"];
    reset(clearPreviousValues = false) {
        this.positionChanged = false;
        this.rotationChanged = false;
        this.mute = false;
        if (clearPreviousValues) {
            if (this.position)
                for (const key of this._positionKeys)
                    delete this.position[key];
            if (this.quaternion)
                for (const key of this._quaternionKeys)
                    delete this.quaternion[key];
        }
    }
    syncValues() {
        for (const key of this._positionKeys) {
            this.position[key] = this.obj.position[key];
        }
        for (const key of this._quaternionKeys) {
            this.quaternion[key] = this.obj.quaternion[key];
        }
    }
    mute = false;
    applyValues() {
        // only apply the values that actually changed
        // since we want to still control all the other values via physics 
        if (this.positionChanged && this.position) {
            for (const key of this._positionKeys) {
                const val = this.position[key];
                if (val !== undefined)
                    this.obj.position[key] = val;
            }
        }
        if (this.rotationChanged) {
            if (this.quaternion) {
                for (const key of this._quaternionKeys) {
                    const val = this.quaternion[key];
                    if (val !== undefined)
                        this.obj.quaternion[key] = val;
                }
            }
        }
    }
    context;
    obj;
    _positionWatch;
    _rotationWatch;
    constructor(obj, context) {
        this.context = context;
        this.obj = obj;
    }
    start(position, rotation) {
        this.reset();
        if (position) {
            if (!this._positionWatch)
                this._positionWatch = new Watch(this.obj.position, ["x", "y", "z"]);
            this._positionWatch.apply();
            this.position = {};
            // this.position = this.obj.position.clone();
            this._positionWatch.subscribeWrite((val, prop) => {
                if (this.context.physics.isUpdating || this.mute)
                    return;
                const prev = this.position[prop];
                if (Math.abs(prev - val) < .00001)
                    return;
                this.position[prop] = val;
                this.positionChanged = true;
            });
        }
        if (rotation) {
            if (!this._rotationWatch)
                this._rotationWatch = new Watch(this.obj.quaternion, ["_x", "_y", "_z", "_w"]);
            this._rotationWatch.apply();
            this.quaternion = {};
            // this.quaternion = this.obj.quaternion.clone();
            this._rotationWatch.subscribeWrite((val, prop) => {
                if (this.context.physics.isUpdating || this.mute)
                    return;
                const prev = this.quaternion[prop];
                if (Math.abs(prev - val) < .00001)
                    return;
                this.quaternion[prop] = val;
                this.rotationChanged = true;
            });
        }
        // detect changes in the parent matrix
        const original = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld);
        const lastParentMatrix = new Matrix4();
        this.obj.matrixWorld["multiplyMatrices"] = (parent, matrix) => {
            if (!lastParentMatrix.equals(parent)) {
                this.positionChanged = true;
                this.rotationChanged = true;
                lastParentMatrix.copy(parent);
            }
            return original(parent, matrix);
            ;
        };
    }
    stop() {
        this._positionWatch?.revoke();
        this._rotationWatch?.revoke();
    }
}
export class Rigidbody extends Behaviour {
    mass = 1;
    useGravity = true;
    constraints = RigidbodyConstraints.None;
    isKinematic = false;
    drag = 0;
    angularDrag = 1;
    detectCollisions = true;
    sleepThreshold = 0.01;
    collisionDetectionMode = CollisionDetectionMode.Discrete;
    get lockPositionX() {
        return (this.constraints & RigidbodyConstraints.FreezePositionX) !== 0;
    }
    get lockPositionY() {
        return (this.constraints & RigidbodyConstraints.FreezePositionY) !== 0;
    }
    get lockPositionZ() {
        return (this.constraints & RigidbodyConstraints.FreezePositionZ) !== 0;
    }
    get lockRotationX() {
        return (this.constraints & RigidbodyConstraints.FreezeRotationX) !== 0;
    }
    get lockRotationY() {
        return (this.constraints & RigidbodyConstraints.FreezeRotationY) !== 0;
    }
    get lockRotationZ() {
        return (this.constraints & RigidbodyConstraints.FreezeRotationZ) !== 0;
    }
    set lockPositionX(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezePositionX;
        else
            this.constraints &= ~RigidbodyConstraints.FreezePositionX;
    }
    set lockPositionY(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezePositionY;
        else
            this.constraints &= ~RigidbodyConstraints.FreezePositionY;
    }
    set lockPositionZ(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezePositionZ;
        else
            this.constraints &= ~RigidbodyConstraints.FreezePositionZ;
    }
    set lockRotationX(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezeRotationX;
        else
            this.constraints &= ~RigidbodyConstraints.FreezeRotationX;
    }
    set lockRotationY(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezeRotationY;
        else
            this.constraints &= ~RigidbodyConstraints.FreezeRotationY;
    }
    set lockRotationZ(v) {
        if (v)
            this.constraints |= RigidbodyConstraints.FreezeRotationZ;
        else
            this.constraints &= ~RigidbodyConstraints.FreezeRotationZ;
    }
    static tempPosition = new THREE.Vector3();
    _propertiesChanged = false;
    _currentVelocity = new THREE.Vector3();
    _smoothedVelocity = new THREE.Vector3();
    _smoothedVelocityGetter = new THREE.Vector3();
    _lastPosition = new THREE.Vector3();
    _watch;
    awake() {
        this._watch = undefined;
        this._propertiesChanged = false;
    }
    onEnable() {
        if (!this._watch) {
            this._watch = new TransformWatch(this.gameObject, this.context);
        }
        this._watch.start(true, true);
        this.startCoroutine(this.beforePhysics(), FrameEvent.LateUpdate);
    }
    onDisable() {
        this._watch?.stop();
        this.context.physics.removeBody(this);
    }
    onDestroy() {
        this.context.physics.removeBody(this);
    }
    onValidate() {
        this._propertiesChanged = true;
    }
    // need to do this right before updating physics to prevent rendered object glitching through physical bodies
    *beforePhysics() {
        while (true) {
            if (this._propertiesChanged) {
                this._propertiesChanged = false;
                this.context.physics.updateProperties(this);
            }
            if (this._watch?.isDirty) {
                this._watch.mute = true;
                this._watch.applyValues();
                this.context.physics.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged);
                this._watch.reset();
            }
            else
                this._watch?.syncValues();
            this.captureVelocity();
            yield;
        }
    }
    get body() {
        return this.context.physics.internal_getRigidbody(this);
    }
    teleport(pt, localspace = true) {
        this._watch?.reset(true);
        if (localspace)
            this.gameObject.position.set(pt.x, pt.y, pt.z);
        else
            this.setWorldPosition(pt.x, pt.y, pt.z);
        this.resetForcesAndTorques();
        this.resetVelocities();
    }
    resetForces() {
        this.body?.resetForces(true);
    }
    resetTorques() {
        this.body?.resetTorques(true);
    }
    resetVelocities() {
        this.setVelocity(0, 0, 0);
        this.setAngularVelocity(0, 0, 0);
    }
    resetForcesAndTorques() {
        this.resetForces();
        this.resetTorques();
    }
    wakeUp() {
        this.body?.wakeUp();
    }
    applyForce(vec, _rel) {
        this.body?.addForce(vec, true);
    }
    applyImpulse(vec) {
        this.body?.applyImpulse(vec, true);
    }
    setForce(x, y, z) {
        this.body?.resetForces(true);
        this.body?.addForce({ x, y, z }, true);
    }
    getVelocity() {
        const vel = this.body?.linvel();
        if (!vel)
            return this._currentVelocity.set(0, 0, 0);
        this._currentVelocity.x = vel.x;
        this._currentVelocity.y = vel.y;
        this._currentVelocity.z = vel.z;
        return this._currentVelocity;
    }
    setVelocity(x, y, z) {
        if (x instanceof Vector3) {
            const vec = x;
            this.body?.setLinvel(vec, true);
            return;
        }
        if (y === undefined || z === undefined)
            return;
        this.body?.setLinvel({ x: x, y: y, z: z }, true);
    }
    setAngularVelocity(x, y, z) {
        if (x instanceof Vector3) {
            const vec = x;
            this.body?.setAngvel(vec, true);
            return;
        }
        if (y === undefined || z === undefined)
            return;
        this.body?.setAngvel({ x: x, y: y, z: z }, true);
    }
    setTorque(x, y, z) {
        this.setAngularVelocity(x, y, z);
    }
    get smoothedVelocity() {
        this._smoothedVelocityGetter.copy(this._smoothedVelocity);
        return this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime);
    }
    // public get smoothedVelocity() { return this._smoothedVelocity; }
    /**d
     * @deprecated not used anymore
     */
    setBodyFromGameObject(_velocity = null) {
        if (this.gameObject && !this.destroyed) {
            // this.context.physics.updateBody(this);
            // this._ignoreChange = true;
            // const wp = this.worldPosition;
            // this.body.position.set(wp.x, wp.y, wp.z);
            // const wr = this.worldQuaternion;
            // this.body.quaternion.set(wr.x, wr.y, wr.z, wr.w);
            // if (velocity) {
            //     Rigidbody.copyVector3.set(velocity.x, velocity.y, velocity.z);
            //     this._smoothedVelocity.lerp(Rigidbody.copyVector3, this.context.time.deltaTime / .1);
            //     const sm = this._smoothedVelocity;
            //     this.body.velocity.x = sm.x;
            //     this.body.velocity.y = sm.y;
            //     this.body.velocity.z = sm.z;
            // }
            // this._ignoreChange = false;
        }
    }
    captureVelocity() {
        if (this.body) {
            const wp = getWorldPosition(this.gameObject);
            Rigidbody.tempPosition.copy(wp);
            const vel = wp.sub(this._lastPosition);
            this._lastPosition.copy(Rigidbody.tempPosition);
            this._smoothedVelocity.lerp(vel, this.context.time.deltaTime / .1);
            // this._smoothedVelocity.set(0, 1 / this.context.time.deltaTime, 0);
        }
    }
}
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "mass", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "useGravity", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "constraints", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "isKinematic", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "drag", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "angularDrag", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "detectCollisions", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "sleepThreshold", void 0);
__decorate([
    validate(),
    serializable()
], Rigidbody.prototype, "collisionDetectionMode", void 0);
//# sourceMappingURL=RigidBody.js.map