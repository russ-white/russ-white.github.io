var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import { Rigidbody } from "./RigidBody";
import { serializable } from "../engine/engine_serialization_decorator";
import { Mesh, Vector3 } from "three";
import { getWorldScale } from "../engine/engine_three_utils";
export class Collider extends Behaviour {
    get isCollider() {
        return true;
    }
    attachedRigidbody = null;
    isTrigger = false;
    awake() {
        super.awake();
        if (!this.attachedRigidbody)
            this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
    }
    start() {
        if (!this.attachedRigidbody)
            this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
    }
    onEnable() {
        // a rigidbody is not assigned if we export an asset
        if (!this.attachedRigidbody)
            this.attachedRigidbody = this.gameObject.getComponentInParent(Rigidbody);
    }
    onDisable() {
        this.context.physics.removeBody(this);
    }
}
__decorate([
    serializable(Rigidbody)
], Collider.prototype, "attachedRigidbody", void 0);
__decorate([
    serializable()
], Collider.prototype, "isTrigger", void 0);
export class SphereCollider extends Collider {
    radius = .5;
    center = new Vector3(0, 0, 0);
    onEnable() {
        super.onEnable();
        this.context.physics.addSphereCollider(this, this.center, this.radius);
    }
}
__decorate([
    serializable()
], SphereCollider.prototype, "radius", void 0);
__decorate([
    serializable(Vector3)
], SphereCollider.prototype, "center", void 0);
export class BoxCollider extends Collider {
    size = new Vector3(1, 1, 1);
    center = new Vector3(0, 0, 0);
    onEnable() {
        super.onEnable();
        this.context.physics.addBoxCollider(this, this.center, this.size);
    }
}
__decorate([
    serializable(Vector3)
], BoxCollider.prototype, "size", void 0);
__decorate([
    serializable(Vector3)
], BoxCollider.prototype, "center", void 0);
export class MeshCollider extends Collider {
    sharedMesh;
    convex = false;
    onEnable() {
        super.onEnable();
        if (!this.sharedMesh?.isMesh) {
            // HACK using the renderer mesh
            if (this.gameObject instanceof Mesh) {
                this.sharedMesh = this.gameObject;
            }
        }
        if (this.sharedMesh?.isMesh)
            this.context.physics.addMeshCollider(this, this.sharedMesh, this.convex, getWorldScale(this.gameObject));
    }
}
__decorate([
    serializable()
], MeshCollider.prototype, "convex", void 0);
export class CapsuleCollider extends Collider {
    center = new Vector3(0, 0, 0);
    radius = .5;
    height = 2;
    onEnable() {
        super.onEnable();
        this.context.physics.addCapsuleCollider(this, this.center, this.height, this.radius);
    }
}
__decorate([
    serializable(Vector3)
], CapsuleCollider.prototype, "center", void 0);
__decorate([
    serializable()
], CapsuleCollider.prototype, "radius", void 0);
__decorate([
    serializable()
], CapsuleCollider.prototype, "height", void 0);
//# sourceMappingURL=Collider.js.map