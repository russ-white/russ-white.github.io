var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import * as THREE from "three";
import { getParam } from "../engine/engine_utils";
import { setWorldPositionXYZ } from "../engine/engine_three_utils";
import { FrameEvent } from "../engine/engine_setup";
import { serializable } from "../engine/engine_serialization_decorator";
import { Color } from "three";
import { WebXR, WebXREvent } from "./WebXR";
import { WebARSessionRoot } from "./WebARSessionRoot";
// https://threejs.org/examples/webgl_shadowmap_csm.html
function toDegrees(radians) {
    return radians * 180 / Math.PI;
}
function toRadians(degrees) {
    return degrees * Math.PI / 180;
}
const shadowMaxDistance = 300;
const debug = getParam("debuglights");
/// <summary>
///   <para>The type of a Light.</para>
/// </summary>
export var LightType;
(function (LightType) {
    /// <summary>
    ///   <para>The light is a spot light.</para>
    /// </summary>
    LightType[LightType["Spot"] = 0] = "Spot";
    /// <summary>
    ///   <para>The light is a directional light.</para>
    /// </summary>
    LightType[LightType["Directional"] = 1] = "Directional";
    /// <summary>
    ///   <para>The light is a point light.</para>
    /// </summary>
    LightType[LightType["Point"] = 2] = "Point";
    LightType[LightType["Area"] = 3] = "Area";
    /// <summary>
    ///   <para>The light is a rectangle shaped area light. It affects only baked lightmaps and lightprobes.</para>
    /// </summary>
    LightType[LightType["Rectangle"] = 3] = "Rectangle";
    /// <summary>
    ///   <para>The light is a disc shaped area light. It affects only baked lightmaps and lightprobes.</para>
    /// </summary>
    LightType[LightType["Disc"] = 4] = "Disc";
})(LightType || (LightType = {}));
export var LightmapBakeType;
(function (LightmapBakeType) {
    /// <summary>
    ///   <para>Realtime lights cast run time light and shadows. They can change position, orientation, color, brightness, and many other properties at run time. No lighting gets baked into lightmaps or light probes..</para>
    /// </summary>
    LightmapBakeType[LightmapBakeType["Realtime"] = 4] = "Realtime";
    /// <summary>
    ///   <para>Baked lights cannot move or change in any way during run time. All lighting for static objects gets baked into lightmaps. Lighting and shadows for dynamic objects gets baked into Light Probes.</para>
    /// </summary>
    LightmapBakeType[LightmapBakeType["Baked"] = 2] = "Baked";
    /// <summary>
    ///   <para>Mixed lights allow a mix of realtime and baked lighting, based on the Mixed Lighting Mode used. These lights cannot move, but can change color and intensity at run time. Changes to color and intensity only affect direct lighting as indirect lighting gets baked. If using Subtractive mode, changes to color or intensity are not calculated at run time on static objects.</para>
    /// </summary>
    LightmapBakeType[LightmapBakeType["Mixed"] = 1] = "Mixed";
})(LightmapBakeType || (LightmapBakeType = {}));
/// <summary>
///   <para>Shadow casting options for a Light.</para>
/// </summary>
var LightShadows;
(function (LightShadows) {
    /// <summary>
    ///   <para>Do not cast shadows (default).</para>
    /// </summary>
    LightShadows[LightShadows["None"] = 0] = "None";
    /// <summary>
    ///   <para>Cast "hard" shadows (with no shadow filtering).</para>
    /// </summary>
    LightShadows[LightShadows["Hard"] = 1] = "Hard";
    /// <summary>
    ///   <para>Cast "soft" shadows (with 4x PCF filtering).</para>
    /// </summary>
    LightShadows[LightShadows["Soft"] = 2] = "Soft";
})(LightShadows || (LightShadows = {}));
export class Light extends Behaviour {
    type = 0;
    range = 1;
    spotAngle = 1;
    innerSpotAngle = 1;
    color = new THREE.Color(0xffffff);
    set shadowNearPlane(val) {
        if (val === this._shadowNearPlane)
            return;
        this._shadowNearPlane = val;
        if (this.light?.shadow?.camera !== undefined) {
            const cam = this.light.shadow.camera;
            cam.near = val;
        }
    }
    get shadowNearPlane() { return this._shadowNearPlane; }
    _shadowNearPlane = .1;
    set shadowBias(val) {
        if (val === this._shadowBias)
            return;
        this._shadowBias = val;
        if (this.light?.shadow?.bias !== undefined) {
            this.light.shadow.bias = val;
            this.light.shadow.needsUpdate = true;
        }
    }
    get shadowBias() { return this._shadowBias; }
    _shadowBias = 0;
    set shadowNormalBias(val) {
        if (val === this._shadowNormalBias)
            return;
        this._shadowNormalBias = val;
        if (this.light?.shadow?.normalBias !== undefined) {
            this.light.shadow.normalBias = val;
            this.light.shadow.needsUpdate = true;
        }
    }
    get shadowNormalBias() { return this._shadowNormalBias; }
    _shadowNormalBias = 1;
    /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
    _overrideShadowBiasSettings = false;
    set shadows(val) {
        this._shadows = val;
        if (this.light) {
            this.light.castShadow = val !== LightShadows.None;
            this.updateShadowSoftHard();
        }
    }
    get shadows() { return this._shadows; }
    _shadows = 1;
    lightmapBakeType = LightmapBakeType.Realtime;
    set intensity(val) {
        this._intensity = val;
        if (this.light) {
            let factor = 1;
            if (this.context.isInXR && this._webARRoot) {
                const scaleFactor = this._webARRoot?.arScale;
                if (typeof scaleFactor === "number" && scaleFactor > 0) {
                    factor /= scaleFactor;
                }
            }
            this.light.intensity = val * factor;
        }
    }
    get intensity() { return this._intensity; }
    _intensity = -1;
    get shadowDistance() {
        const light = this.light;
        if (light) {
            const cam = light.shadow.camera;
            return cam.far;
        }
        return -1;
    }
    set shadowDistance(val) {
        this._shadowDistance = val;
        const light = this.light;
        if (light) {
            const cam = light.shadow.camera;
            cam.far = val;
            cam.updateProjectionMatrix();
        }
    }
    _shadowDistance;
    // set from additional component
    shadowWidth;
    shadowHeight;
    get shadowResolution() {
        const light = this.light;
        if (light) {
            return light.shadow.mapSize.x;
        }
        return -1;
    }
    set shadowResolution(val) {
        if (val === this._shadowResolution)
            return;
        this._shadowResolution = val;
        const light = this.light;
        if (light) {
            light.shadow.mapSize.set(val, val);
            light.shadow.needsUpdate = true;
        }
    }
    _shadowResolution = undefined;
    get isBaked() {
        return this.lightmapBakeType === LightmapBakeType.Baked;
    }
    get selfIsLight() {
        if (this.gameObject["isLight"] === true)
            return true;
        switch (this.gameObject.type) {
            case "SpotLight":
            case "PointLight":
            case "DirectionalLight":
                return true;
        }
        return false;
    }
    light = undefined;
    getWorldPosition(vec) {
        if (this.light) {
            if (this.type === LightType.Directional) {
                return this.light.getWorldPosition(vec).multiplyScalar(1);
            }
            return this.light.getWorldPosition(vec);
        }
        return vec;
    }
    updateIntensity() {
        this.intensity = this._intensity;
    }
    awake() {
        this.color = new THREE.Color(this.color ?? 0xffffff);
    }
    onEnable() {
        this.createLight();
        if (this.isBaked)
            return;
        else if (this.light) {
            if (this.selfIsLight) {
                // nothing to do
            }
            else if (this.light.parent !== this.gameObject)
                this.gameObject.add(this.light);
        }
        if (this.type === LightType.Directional)
            this.startCoroutine(this.updateMainLightRoutine(), FrameEvent.LateUpdate);
        this._webXRStartedListener = WebXR.addEventListener(WebXREvent.XRStarted, this.onWebXRStarted.bind(this));
        this._webXREndedListener = WebXR.addEventListener(WebXREvent.XRStopped, this.onWebXREnded.bind(this));
    }
    onDisable() {
        WebXR.removeEventListener(WebXREvent.XRStarted, this._webXRStartedListener);
        WebXR.removeEventListener(WebXREvent.XRStopped, this._webXREndedListener);
    }
    _webXRStartedListener;
    _webXREndedListener;
    _webARRoot;
    onWebXRStarted() {
        this._webARRoot = GameObject.getComponentInParent(this.gameObject, WebARSessionRoot) ?? undefined;
        this.startCoroutine(this._updateLightIntensityInARRoutine());
    }
    *_updateLightIntensityInARRoutine() {
        while (this.context.isInAR) {
            yield;
            this.updateIntensity();
            for (let i = 0; i < 30; i++)
                yield;
        }
    }
    onWebXREnded() {
        this.updateIntensity();
    }
    createLight() {
        const lightAlreadyCreated = this.selfIsLight;
        if (lightAlreadyCreated && !this.light) {
            this.light = this.gameObject;
            this._intensity = this.light.intensity;
            switch (this.type) {
                case LightType.Directional:
                    this.setDirectionalLight(this.light);
                    break;
            }
        }
        else if (!this.light) {
            switch (this.type) {
                case LightType.Directional:
                    // console.log(this);
                    const dirLight = new THREE.DirectionalLight(this.color, this.intensity * Math.PI);
                    // directional light target is at 0 0 0 by default
                    dirLight.position.set(0, 0, -shadowMaxDistance * .5).applyQuaternion(this.gameObject.quaternion);
                    this.gameObject.add(dirLight.target);
                    setWorldPositionXYZ(dirLight.target, 0, 0, 0);
                    this.light = dirLight;
                    this.gameObject.position.set(0, 0, 0);
                    this.gameObject.rotation.set(0, 0, 0);
                    if (debug) {
                        const spotLightHelper = new THREE.DirectionalLightHelper(this.light, .2, this.color);
                        this.context.scene.add(spotLightHelper);
                        // const bh = new THREE.BoxHelper(this.context.scene, 0xfff0000);
                        // this.context.scene.add(bh);
                    }
                    break;
                case LightType.Spot:
                    const spotLight = new THREE.SpotLight(this.color, this.intensity * Math.PI, this.range, toRadians(this.spotAngle / 2), 1 - toRadians(this.innerSpotAngle / 2) / toRadians(this.spotAngle / 2), 2);
                    spotLight.position.set(0, 0, 0);
                    spotLight.rotation.set(0, 0, 0);
                    this.light = spotLight;
                    const spotLightTarget = spotLight.target;
                    spotLight.add(spotLightTarget);
                    spotLightTarget.position.set(0, 0, this.range);
                    spotLightTarget.rotation.set(0, 0, 0);
                    break;
                case LightType.Point:
                    const pointLight = new THREE.PointLight(this.color, this.intensity * Math.PI, this.range);
                    this.light = pointLight;
                    // const pointHelper = new THREE.PointLightHelper(pointLight, this.range, this.color);
                    // scene.add(pointHelper);
                    break;
            }
        }
        if (this.light) {
            if (this._intensity >= 0)
                this.light.intensity = this._intensity;
            else
                this._intensity = this.light.intensity;
            if (this.shadows !== LightShadows.None) {
                this.light.castShadow = true;
            }
            else
                this.light.castShadow = false;
            // shadow intensity is currently not a thing: https://github.com/mrdoob/three.js/pull/14087
            if (this._shadowResolution !== undefined && this._shadowResolution > 4) {
                this.light.shadow.mapSize.width = this._shadowResolution;
                this.light.shadow.mapSize.height = this._shadowResolution;
            }
            else {
                this.light.shadow.mapSize.width = 2048;
                this.light.shadow.mapSize.height = 2048;
            }
            // this.light.shadow.needsUpdate = true;
            // console.log(this.light.shadow.mapSize);
            // return;
            if (debug)
                console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias);
            // shadow bias settings
            if (this._overrideShadowBiasSettings === true) {
                this.light.shadow.bias = this.shadowBias;
                this.light.shadow.normalBias = this.shadowNormalBias;
            }
            else {
                this.light.shadow.bias = this.shadowBias * 0.00001;
                this.light.shadow.normalBias = this.shadowNormalBias * .0001;
            }
            this.updateShadowSoftHard();
            const cam = this.light.shadow.camera;
            cam.near = this.shadowNearPlane;
            // use shadow distance that was set explictly (if any)
            if (this._shadowDistance !== undefined && typeof this._shadowDistance === "number")
                cam.far = this._shadowDistance;
            else // otherwise fallback to object scale and max distance
                cam.far = shadowMaxDistance * Math.abs(this.gameObject.scale.z);
            // width and height
            this.gameObject.scale.set(1, 1, 1);
            if (this.shadowWidth !== undefined) {
                cam.left = -this.shadowWidth / 2;
                cam.right = this.shadowWidth / 2;
            }
            else {
                const sx = this.gameObject.scale.x;
                cam.left *= sx;
                cam.right *= sx;
            }
            if (this.shadowHeight !== undefined) {
                cam.top = this.shadowHeight / 2;
                cam.bottom = -this.shadowHeight / 2;
            }
            else {
                const sy = this.gameObject.scale.y;
                cam.top *= sy;
                cam.bottom *= sy;
            }
            this.light.shadow.needsUpdate = true;
            if (debug)
                this.context.scene.add(new THREE.CameraHelper(cam));
            if (this.isBaked) {
                this.light.removeFromParent();
            }
            else if (!lightAlreadyCreated)
                this.gameObject.add(this.light);
        }
    }
    *updateMainLightRoutine() {
        while (true) {
            if (this.type === LightType.Directional) {
                if (!this.context.mainLight || this.intensity > this.context.mainLight.intensity) {
                    this.context.mainLight = this;
                }
                yield;
            }
            break;
        }
    }
    static allowChangingRendererShadowMapType = true;
    updateShadowSoftHard() {
        if (!this.light)
            return;
        if (this.shadows === LightShadows.Soft) {
            // const radius = this.light.shadow.mapSize.width / 1024 * 5;
            // const samples = Mathf.clamp(Math.round(radius), 2, 10);
            // this.light.shadow.radius = radius;
            // this.light.shadow.blurSamples = samples;
            // if (isMobileDevice()) {
            //     this.light.shadow.radius *= .5;
            //     this.light.shadow.blurSamples = Math.floor(this.light.shadow.blurSamples * .5);
            // }
            // if (Light.allowChangingRendererShadowMapType) {
            //     if(this.context.renderer.shadowMap.type !== THREE.VSMShadowMap){
            //         if(isLocalNetwork()) console.warn("Changing renderer shadow map type to VSMShadowMap because a light with soft shadows enabled was found (this will cause all shadow receivers to also cast shadows). If you don't want this behaviour either set the shadow type to hard or set Light.allowChangingRendererShadowMapType to false.", this);
            //         this.context.renderer.shadowMap.type = THREE.VSMShadowMap;
            //     }
            // }
        }
        else {
            this.light.shadow.radius = 1;
            this.light.shadow.blurSamples = 1;
        }
    }
    setDirectionalLight(dirLight) {
        dirLight.add(dirLight.target);
        dirLight.target.position.set(0, 0, -1);
        // dirLight.position.add(vec.set(0,0,1).multiplyScalar(shadowMaxDistance*.1).applyQuaternion(this.gameObject.quaternion));
    }
}
__decorate([
    serializable()
], Light.prototype, "type", void 0);
__decorate([
    serializable(Color)
], Light.prototype, "color", void 0);
__decorate([
    serializable()
], Light.prototype, "shadowNearPlane", null);
__decorate([
    serializable()
], Light.prototype, "shadowBias", null);
__decorate([
    serializable()
], Light.prototype, "shadowNormalBias", null);
__decorate([
    serializable()
], Light.prototype, "shadows", null);
__decorate([
    serializable()
], Light.prototype, "lightmapBakeType", void 0);
__decorate([
    serializable()
], Light.prototype, "intensity", null);
__decorate([
    serializable()
], Light.prototype, "shadowDistance", null);
__decorate([
    serializable()
], Light.prototype, "shadowResolution", null);
const vec = new THREE.Vector3(0, 0, 0);
//# sourceMappingURL=Light.js.map