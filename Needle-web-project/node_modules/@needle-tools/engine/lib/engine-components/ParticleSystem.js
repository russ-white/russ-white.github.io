var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "./Component";
import * as THREE from "three";
import { MainModule, EmissionModule, ShapeModule, ColorOverLifetimeModule, SizeOverLifetimeModule, NoiseModule, ParticleSystemSimulationSpace, ParticleBurst, ParticleSystemRenderMode, TrailModule, VelocityOverLifetimeModule, TextureSheetAnimationModule, RotationOverLifetimeModule, LimitVelocityOverLifetimeModule, RotationBySpeedModule, InheritVelocityModule, SizeBySpeedModule, ColorBySpeedModule } from "./ParticleSystemModules";
import { getParam } from "../engine/engine_utils";
// https://github.dev/creativelifeform/three-nebula
// import System, { Emitter, Position, Life, SpriteRenderer, Particle, Body, MeshRenderer, } from 'three-nebula';
import { serializable } from "../engine/engine_serialization";
import { RGBAColor } from "./js-extensions/RGBAColor";
import { AxesHelper, Material, Mesh, Object3D, Quaternion, Vector3, Vector4 } from "three";
import { getWorldPosition, getWorldQuaternion, getWorldScale } from "../engine/engine_three_utils";
import { assign } from "../engine/engine_serialization_core";
import { BatchedParticleRenderer, ConstantColor, ConstantValue, ParticleSystem as _ParticleSystem, RenderMode, TrailParticle } from "three.quarks";
import { createFlatTexture } from "../engine/engine_shaders";
import { Mathf } from "../engine/engine_math";
import { ParticleSubEmitter } from "./ParticleSystemSubEmitter";
const debug = getParam("debugparticles");
export class SubEmitterSystem {
    particleSystem;
    _deserialize(context) {
        const ps = this.particleSystem;
        if (ps && !(ps instanceof ParticleSystem) && typeof ps["guid"] === "string") {
            if (debug)
                console.log("DESERIALIZE SUBEMITTER", ps);
            this.particleSystem = undefined;
            this.particleSystem = GameObject.findByGuid(ps["guid"], context.scene);
        }
    }
}
export class ParticleSystemRenderer extends Behaviour {
    renderMode;
    particleMaterial;
    trailMaterial;
    // @serializable(Mesh)
    particleMesh;
    get transparent() {
        const res = this.particleMaterial?.transparent ?? false;
        // console.log(res, this.particleMaterial);
        return res;
    }
    getMaterial(trailEnabled = false) {
        if (trailEnabled === true && this.trailMaterial)
            return this.trailMaterial;
        return this.particleMaterial;
    }
    getMesh() {
        let geo = null;
        if (this.particleMesh instanceof Mesh) {
            geo = this.particleMesh.geometry;
        }
        if (geo === null)
            geo = new THREE.BoxGeometry(1, 1, 1);
        const res = new Mesh(geo, this.getMaterial());
        return res;
    }
}
__decorate([
    serializable()
], ParticleSystemRenderer.prototype, "renderMode", void 0);
__decorate([
    serializable(Material)
], ParticleSystemRenderer.prototype, "particleMaterial", void 0);
__decorate([
    serializable(Material)
], ParticleSystemRenderer.prototype, "trailMaterial", void 0);
class MinMaxCurveFunction {
    _curve;
    constructor(curve) { this._curve = curve; }
    type = "function";
    genValue(t) {
        return this._curve.evaluate(t, Math.random());
    }
    toJSON() {
        throw new Error("Method not implemented.");
    }
    clone() {
        throw new Error("Method not implemented.");
    }
}
class MinMaxGradientFunction {
    _curve;
    constructor(curve) { this._curve = curve; }
    type = "function";
    genColor(color, t) {
        const col = this._curve.evaluate(t, Math.random());
        // TODO: incoming color should probably be blended?
        color.set(col.r, col.g, col.b, col.alpha);
        return color;
    }
    toJSON() {
        throw new Error("Method not implemented.");
    }
    clone() {
        throw new Error("Method not implemented.");
    }
}
class BaseValueGenerator {
    type = "value";
    toJSON() {
        throw new Error("Method not implemented.");
    }
    clone() {
        throw new Error("Method not implemented.");
    }
    system;
    constructor(system) {
        this.system = system;
    }
}
class TextureSheetStartFrameGenerator extends BaseValueGenerator {
    genValue() {
        return this.system.textureSheetAnimation.getStartIndex();
    }
}
class ParticleSystemEmissionOverTime extends BaseValueGenerator {
    _lastPosition = new Vector3();
    _lastDistance = 0;
    update() {
        const currentPosition = getWorldPosition(this.system.gameObject);
        this._lastDistance = this._lastPosition.distanceTo(currentPosition);
        this._lastPosition.copy(currentPosition);
    }
    genValue() {
        if (this.system.currentParticles >= this.system.maxParticles)
            return 0;
        // emission over time
        let emission = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random());
        // if(this.system.currentParticles + emission > this.system.maxParticles) 
        //     emission = (this.system.maxParticles - this.system.currentParticles);
        // const res = Mathf.clamp(emission, 0, this.system.maxParticles - this.system.currentParticles);
        if (this.system.deltaTime > 0) {
            const distanceEmission = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
            const meterPerSecond = this._lastDistance / this.system.deltaTime;
            let distanceEmissionValue = meterPerSecond * distanceEmission;
            if (!Number.isFinite(distanceEmissionValue))
                distanceEmissionValue = 0;
            emission += distanceEmissionValue;
        }
        const burst = this.system.emission.getBurst();
        if (burst > 0)
            emission += burst / this.system.deltaTime;
        const maxEmission = (this.system.maxParticles - this.system.currentParticles);
        return Mathf.clamp(emission, 0, maxEmission / this.system.deltaTime);
    }
}
class ParticleSystemEmissionOverDistance extends BaseValueGenerator {
    genValue() {
        // this seems not be called yet
        return 0;
        // if (this.system.currentParticles >= this.system.maxParticles) return 0;
        // const emission = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
        // return emission;
    }
}
class ParticleSystemBaseBehaviour {
    system;
    get scaleFactorDiff() {
        return this.system.worldScale.x - this.system.scale;
    }
    constructor(ps) {
        this.system = ps;
    }
    initialize(_particle) {
    }
    update(_particle, _delta) {
    }
    frameUpdate(_delta) {
    }
    toJSON() { throw new Error("Method not implemented."); }
    clone() { throw new Error("Method not implemented."); }
}
class TextureSheetAnimationBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleTextureSheet";
    update(particle, _delta) {
        const sheet = this.system.textureSheetAnimation;
        if (sheet.enabled) {
            const t01 = particle.age / particle.life;
            const index = sheet.evaluate(t01);
            ;
            if (index !== undefined)
                particle.uvTile = index;
        }
    }
}
class RotationBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleRotation";
    update(particle, delta) {
        if (particle.rotation === undefined)
            return;
        const t = particle.age / particle.life;
        if (typeof particle.rotation === "number") {
            if (this.system.rotationOverLifetime.enabled) {
                particle.rotation += this.system.rotationOverLifetime.evaluate(t) * delta;
            }
            else {
                if (this.system.renderer.renderMode === ParticleSystemRenderMode.Billboard)
                    particle.rotation = Math.PI;
            }
            if (this.system.rotationBySpeed.enabled) {
                const speed = particle.velocity.length();
                particle.rotation += this.system.rotationBySpeed.evaluate(t, speed) * delta;
            }
        }
        else {
            // const quat = particle.rotation as Quaternion;
            // TODO: implement rotation by speed for quaternions
        }
    }
}
const $sizeLerpFactor = Symbol("sizeLerpFactor");
class SizeBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleSize";
    initialize(particle) {
        particle[$sizeLerpFactor] = Math.random();
    }
    update(particle, _delta) {
        if (this.system.renderer.renderMode === ParticleSystemRenderMode.Mesh) {
        }
        else {
            const age01 = particle.age / particle.life;
            let size = 1;
            if (this.system.sizeOverLifetime.enabled)
                size *= this.system.sizeOverLifetime.evaluate(age01, undefined, particle[$sizeLerpFactor]).x;
            const scaleFactor = this.system.worldScale.x / this.system.cameraScale;
            particle.size = particle.startSize * size * scaleFactor;
        }
    }
}
const $particleLife = Symbol("particleLife");
const $trailLifetime = Symbol("trailLifetime");
const $trailStartLength = Symbol("trailStartLength");
class TrailBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleTrail";
    initialize(particle) {
        if (particle instanceof TrailParticle) {
            particle[$particleLife] = particle.life;
            particle[$trailLifetime] = particle.life;
            if (this.system.trails.enabled && this.system.trails.dieWithParticles === false) {
                particle[$trailLifetime] = this.system.trails.lifetime.evaluate(Math.random(), Math.random());
                particle.life += particle[$trailLifetime];
            }
            particle[$trailStartLength] = particle.length;
        }
    }
    update(particle) {
        if (this.system.trails?.enabled && particle instanceof TrailParticle) {
            const trailParticle = particle;
            const age01 = particle.age / particle[$particleLife];
            const iter = particle.previous.values();
            const length = particle.previous.length;
            // const maxAge = this.system.trails.lifetime.
            for (let i = 0; i < length; i++) {
                const cur = iter.next();
                const state = cur.value;
                const pos01 = 1 - (i / (length - 1));
                state.size = this.system.trails.getWidth(particle.size, age01, pos01);
                state.color.copy(particle.color);
                this.system.trails.getColor(state.color, age01, pos01);
            }
            // particle.life = particle.age + .1;
            if (particle.age > particle[$particleLife]) {
                particle.velocity.set(0, 0, 0);
                const t = (particle.age - particle[$particleLife]) / particle[$trailLifetime];
                trailParticle.length = Mathf.lerp(particle[$trailStartLength], 0, t);
            }
        }
    }
}
const $startVelocity = Symbol("startVelocity");
const $gravityFactor = Symbol("gravityModifier");
const $velocityLerpFactor = Symbol("velocity lerp factor");
const temp3 = new Vector3();
const temp4 = new Quaternion();
class VelocityBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleVelocity";
    _gravityDirection = new Vector3();
    initialize(particle) {
        const factor = 1 + this.scaleFactorDiff;
        particle.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random()) * factor;
        particle.velocity.copy(this.system.shape.getDirection(particle.position)).multiplyScalar(particle.startSpeed);
        if (this.system.inheritVelocity?.enabled) {
            this.system.inheritVelocity.applyInitial(particle.velocity);
        }
        if (!particle[$startVelocity])
            particle[$startVelocity] = particle.velocity.clone();
        else
            particle[$startVelocity].copy(particle.velocity);
        const gravityFactor = this.system.main.gravityModifier.evaluate(Math.random(), Math.random()) / (9.81 * 2);
        particle[$gravityFactor] = gravityFactor;
        particle[$velocityLerpFactor] = Math.random();
        this._gravityDirection.set(0, -1, 0);
        if (this.system.main.simulationSpace === ParticleSystemSimulationSpace.Local)
            this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted);
    }
    update(particle, delta) {
        //////////////////////
        // calculate speed
        const baseVelocity = particle[$startVelocity];
        let gravityFactor = particle[$gravityFactor];
        if (gravityFactor !== 0) {
            // gravityFactor *= -1;
            temp3.copy(this._gravityDirection).multiplyScalar(gravityFactor);
            // Gizmos.DrawDirection(particle.position, temp3, 0xff0000, 0, false, 10);
            baseVelocity.add(temp3);
        }
        particle.velocity.copy(baseVelocity);
        const t01 = particle.age / particle.life;
        if (this.system.inheritVelocity?.enabled) {
            this.system.inheritVelocity.applyCurrent(particle.velocity, t01, particle[$velocityLerpFactor]);
        }
        const noise = this.system.noise;
        if (noise.enabled) {
            noise.apply(0, particle.position, particle.velocity, delta, particle.age, particle.life);
        }
        //////////////////////
        // evaluate by speed modules
        const sizeBySpeed = this.system.sizeBySpeed;
        if (sizeBySpeed?.enabled) {
            particle.size = sizeBySpeed.evaluate(particle.velocity, t01, particle[$velocityLerpFactor], particle.size);
        }
        const colorBySpeed = this.system.colorBySpeed;
        if (colorBySpeed?.enabled) {
            colorBySpeed.evaluate(particle.velocity, particle[$velocityLerpFactor], particle.color);
        }
        //////////////////////
        // limit or modify speed
        const velocity = this.system.velocityOverLifetime;
        if (velocity.enabled) {
            velocity.apply(0, particle.position, particle.velocity, delta, particle.age, particle.life);
        }
        const limitVelocityOverLifetime = this.system.limitVelocityOverLifetime;
        if (limitVelocityOverLifetime.enabled) {
            // const factor = this.system.worldScale.x;
            limitVelocityOverLifetime.apply(particle.position, baseVelocity, particle.velocity, particle.size, t01, delta, 1);
        }
    }
}
const $colorLerpFactor = Symbol("colorLerpFactor");
class ColorBehaviour extends ParticleSystemBaseBehaviour {
    type = "NeedleColor";
    initialize(particle) {
        const col = this.system.main.startColor.evaluate(particle.age / particle.life, Math.random());
        particle.startColor.set(col.r, col.g, col.b, col.alpha);
        particle.color.copy(particle.startColor);
        particle[$colorLerpFactor] = Math.random();
    }
    update(particle, _delta) {
        if (this.system.colorOverLifetime.enabled) {
            const t = particle.age / particle.life;
            const col = this.system.colorOverLifetime.color.evaluate(t, particle[$colorLerpFactor]);
            particle.color.set(col.r, col.g, col.b, col.alpha).multiply(particle.startColor);
        }
        else {
            particle.color.copy(particle.startColor);
        }
    }
}
class ParticleSystemInterface {
    system;
    emission;
    get anim() {
        return this.system.textureSheetAnimation;
    }
    constructor(system) {
        this.system = system;
        this.emission = new ParticleSystemEmissionOverTime(this.system);
    }
    update() {
        this.emission.update();
    }
    autoDestroy;
    get looping() { return this.system.main.loop; }
    get duration() { return this.system.duration; }
    get shape() { return this.system.shape; }
    get startLife() { return new MinMaxCurveFunction(this.system.main.startLifetime); }
    get startSpeed() { return new MinMaxCurveFunction(this.system.main.startSpeed); }
    get startRotation() { return new MinMaxCurveFunction(this.system.main.startRotation); }
    get startSize() { return new MinMaxCurveFunction(this.system.main.startSize); }
    startLength; /** start length is for trails */
    get startColor() { return new ConstantColor(new Vector4(1, 1, 1, 1)); }
    get emissionOverTime() { return this.emission; }
    /** this is not supported yet */
    get emissionOverDistance() { return new ParticleSystemEmissionOverDistance(this.system); }
    /** not used - burst is controled via emissionOverTime */
    emissionBursts;
    onlyUsedByOther;
    behaviors = [];
    get instancingGeometry() {
        return this.system.renderer.getMesh().geometry;
    }
    get renderMode() {
        if (this.system.trails["enabled"] === true) {
            return RenderMode.Trail;
        }
        switch (this.system.renderer.renderMode) {
            case ParticleSystemRenderMode.Billboard: return RenderMode.BillBoard;
            // case ParticleSystemRenderMode.Stretch: return RenderMode.Stretch;
            // case ParticleSystemRenderMode.HorizontalBillboard: return RenderMode.HorizontalBillboard;
            // case ParticleSystemRenderMode.VerticalBillboard: return RenderMode.VerticalBillboard;
            case ParticleSystemRenderMode.Mesh: return RenderMode.LocalSpace;
        }
        return RenderMode.BillBoard;
    }
    rendererEmitterSettings = {
        startLength: new ConstantValue(220),
        followLocalOrigin: false,
    };
    get speedFactor() { return this.system.main.simulationSpeed; }
    get texture() {
        const mat = this.system.renderer.getMaterial(this.system.trails.enabled);
        if (mat && mat["map"]) {
            const tex = mat["map"];
            tex.premultiplyAlpha = false;
            tex.encoding = THREE.LinearEncoding;
            return tex;
        }
        return createFlatTexture(new RGBAColor(1, 1, 1, 1), 1);
    }
    get startTileIndex() { return new TextureSheetStartFrameGenerator(this.system); }
    get uTileCount() { return this.anim.enabled ? this.anim?.numTilesX : undefined; }
    get vTileCount() { return this.anim.enabled ? this.anim?.numTilesY : undefined; }
    get renderOrder() { return 1; }
    get blending() { return this.system.renderer.particleMaterial?.blending ?? THREE.NormalBlending; }
    get transparent() { return this.system.renderer.transparent; }
    get worldSpace() { return this.system.main.simulationSpace === ParticleSystemSimulationSpace.World; }
}
class ParticlesEmissionState {
    burstIndex = 0;
    burstWaveIndex = 0;
    time = 0;
    waitEmiting = 0;
}
export class ParticleSystem extends Behaviour {
    play(includeChildren = false) {
        if (includeChildren) {
            GameObject.foreachComponent(this.gameObject, comp => {
                if (comp instanceof ParticleSystem && comp !== this) {
                    comp.play(false);
                }
            }, true);
        }
        this._isPlaying = true;
        this._time = 0;
        // https://github.com/Alchemist0823/three.quarks/pull/35
        if (this._particleSystem) {
            this._particleSystem["emissionState"].time = 0;
            this._particleSystem["emitEnded"] = false;
        }
        this.emission?.reset();
    }
    pause() {
        this._isPlaying = false;
    }
    stop() {
        this._isPlaying = false;
        this._time = 0;
    }
    _state;
    emit(count) {
        if (this._particleSystem) {
            count = Math.min(count, this.maxParticles - this.currentParticles);
            if (!this._state)
                this._state = new ParticlesEmissionState();
            this._state.waitEmiting = count;
            this._state.time = 0;
            const emitEndedState = this._particleSystem["emitEnded"];
            this._particleSystem["emitEnded"] = false;
            this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld);
            this._particleSystem["emitEnded"] = emitEndedState;
        }
    }
    colorOverLifetime;
    main;
    emission;
    sizeOverLifetime;
    shape;
    noise;
    trails;
    velocityOverLifetime;
    limitVelocityOverLifetime;
    inheritVelocity;
    colorBySpeed;
    textureSheetAnimation;
    rotationOverLifetime;
    rotationBySpeed;
    sizeBySpeed;
    get renderer() {
        return this._renderer;
    }
    get isPlaying() { return this._isPlaying; }
    get currentParticles() {
        return this._particleSystem?.particleNum ?? 0;
    }
    get maxParticles() {
        return this.main.maxParticles;
    }
    get time() {
        return this._time;
    }
    get duration() {
        return this.main.duration;
    }
    get deltaTime() {
        return this.context.time.deltaTime * this.main.simulationSpeed;
    }
    get scale() {
        return this.gameObject.scale.x;
    }
    get cameraScale() {
        return this._cameraScale;
    }
    _cameraScale = 1;
    get container() {
        return this._container;
    }
    get worldspace() {
        return this.main.simulationSpace === ParticleSystemSimulationSpace.World;
    }
    __worldQuaternion = new Quaternion();
    get worldQuaternion() {
        return this.__worldQuaternion;
    }
    _worldQuaternionInverted = new Quaternion();
    get worldQuaternionInverted() {
        return this._worldQuaternionInverted;
    }
    _worldScale = new Vector3();
    get worldScale() {
        return this._worldScale;
    }
    _worldPositionFrame = -1;
    _worldPos = new Vector3();
    get worldPos() {
        if (this._worldPositionFrame !== this.context.time.frame) {
            this._worldPositionFrame = this.context.time.frame;
            getWorldPosition(this.gameObject, this._worldPos);
        }
        return this._worldPos;
    }
    get matrixWorld() {
        return this._container.matrixWorld;
    }
    get isSubsystem() {
        return this._isUsedAsSubsystem;
    }
    _renderer;
    _batchSystem;
    _particleSystem;
    _interface;
    // private _system!: System;
    // private _emitter: Emitter;
    // private _size!: SizeBehaviour;
    _container;
    _time = 0;
    _isPlaying = true;
    _isUsedAsSubsystem = false;
    /** called from deserialization */
    set bursts(arr) {
        for (let i = 0; i < arr.length; i++) {
            const burst = arr[i];
            if ((burst instanceof ParticleBurst) === false) {
                const instance = new ParticleBurst();
                assign(instance, burst);
                arr[i] = instance;
            }
        }
        this._bursts = arr;
    }
    _bursts;
    /** called from deserialization */
    set subEmitterSystems(arr) {
        for (let i = 0; i < arr.length; i++) {
            const sub = arr[i];
            if ((sub instanceof SubEmitterSystem) === false) {
                const instance = new SubEmitterSystem();
                assign(instance, sub);
                arr[i] = instance;
            }
        }
        this._subEmitterSystems = arr;
    }
    _subEmitterSystems;
    awake() {
        if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems)) {
            for (const sub of this._subEmitterSystems) {
                sub._deserialize(this.context);
            }
        }
        this._renderer = this.gameObject.getComponent(ParticleSystemRenderer);
        this._container = new Object3D();
        this._container.matrixAutoUpdate = false;
        if (this.main.simulationSpace == ParticleSystemSimulationSpace.Local) {
            this.gameObject.add(this._container);
        }
        else {
            this.context.scene.add(this._container);
        }
        // else this._container = this.context.scene;
        this._batchSystem = new BatchedParticleRenderer();
        this._batchSystem.name = this.gameObject.name;
        this._container.add(this._batchSystem);
        this._interface = new ParticleSystemInterface(this);
        this._particleSystem = new _ParticleSystem(this._batchSystem, this._interface);
        this._particleSystem.addBehavior(new SizeBehaviour(this));
        this._particleSystem.addBehavior(new ColorBehaviour(this));
        this._particleSystem.addBehavior(new TextureSheetAnimationBehaviour(this));
        this._particleSystem.addBehavior(new RotationBehaviour(this));
        this._particleSystem.addBehavior(new VelocityBehaviour(this));
        this._particleSystem.addBehavior(new TrailBehaviour(this));
        const emitter = this._particleSystem.emitter;
        this.context.scene.add(emitter);
        if (debug) {
            console.log(this);
            this.gameObject.add(new AxesHelper(1));
        }
    }
    start() {
        this.addSubParticleSystems();
    }
    onEnable() {
        if (this.inheritVelocity)
            this.inheritVelocity.system = this;
        this.play();
    }
    onDisable() {
    }
    onBeforeRender() {
        if (this._bursts) {
            this.emission.bursts = this._bursts;
            delete this._bursts;
        }
        if (!this._isPlaying)
            return;
        // sprite materials must be scaled in AR
        const cam = this.context.mainCamera;
        if (cam) {
            const scale = getWorldScale(cam);
            this._cameraScale = scale.x;
        }
        let source = this._container;
        if (this.worldspace)
            source = this.gameObject;
        getWorldQuaternion(source, this.__worldQuaternion);
        this._worldQuaternionInverted.copy(this.__worldQuaternion).invert();
        getWorldScale(this.gameObject, this._worldScale);
        if (!this.worldspace && this._container && this.gameObject?.parent) {
            const scale = getWorldScale(this.gameObject.parent);
            scale.x = 1 / scale.x;
            scale.y = 1 / scale.y;
            scale.z = 1 / scale.z;
            this._container.matrix.identity();
            this._container.matrix.scale(scale);
        }
        this.emission.system = this;
        const dt = this.deltaTime;
        this._interface.update();
        this.shape.update(this, this.context, this.main.simulationSpace, this.gameObject);
        this.noise.update(this.context);
        this.inheritVelocity?.update(this.context);
        this.velocityOverLifetime.update(this);
        this._batchSystem?.update(dt);
        this._time += dt;
        if (this._time > this.duration)
            this._time = 0;
    }
    addSubParticleSystems() {
        if (this._subEmitterSystems && this._particleSystem) {
            for (const sys of this._subEmitterSystems) {
                const system = sys.particleSystem?._particleSystem;
                if (system) {
                    sys.particleSystem._isUsedAsSubsystem = true;
                    // sys.particleSystem!.main.simulationSpace = ParticleSystemSimulationSpace.World;
                    const sub = new ParticleSubEmitter(this, this._particleSystem, sys.particleSystem, system);
                    this._particleSystem.addBehavior(sub);
                }
            }
        }
    }
}
__decorate([
    serializable(ColorOverLifetimeModule)
], ParticleSystem.prototype, "colorOverLifetime", void 0);
__decorate([
    serializable(MainModule)
], ParticleSystem.prototype, "main", void 0);
__decorate([
    serializable(EmissionModule)
], ParticleSystem.prototype, "emission", void 0);
__decorate([
    serializable(SizeOverLifetimeModule)
], ParticleSystem.prototype, "sizeOverLifetime", void 0);
__decorate([
    serializable(ShapeModule)
], ParticleSystem.prototype, "shape", void 0);
__decorate([
    serializable(NoiseModule)
], ParticleSystem.prototype, "noise", void 0);
__decorate([
    serializable(TrailModule)
], ParticleSystem.prototype, "trails", void 0);
__decorate([
    serializable(VelocityOverLifetimeModule)
], ParticleSystem.prototype, "velocityOverLifetime", void 0);
__decorate([
    serializable(LimitVelocityOverLifetimeModule)
], ParticleSystem.prototype, "limitVelocityOverLifetime", void 0);
__decorate([
    serializable(InheritVelocityModule)
], ParticleSystem.prototype, "inheritVelocity", void 0);
__decorate([
    serializable(ColorBySpeedModule)
], ParticleSystem.prototype, "colorBySpeed", void 0);
__decorate([
    serializable(TextureSheetAnimationModule)
], ParticleSystem.prototype, "textureSheetAnimation", void 0);
__decorate([
    serializable(RotationOverLifetimeModule)
], ParticleSystem.prototype, "rotationOverLifetime", void 0);
__decorate([
    serializable(RotationBySpeedModule)
], ParticleSystem.prototype, "rotationBySpeed", void 0);
__decorate([
    serializable(SizeBySpeedModule)
], ParticleSystem.prototype, "sizeBySpeed", void 0);
//# sourceMappingURL=ParticleSystem.js.map