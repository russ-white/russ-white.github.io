var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Graphic } from "./Graphic";
import { FrameEvent } from "../../engine/engine_setup";
import { Behaviour, GameObject } from "../Component";
import { serializable } from "../../engine/engine_serialization_decorator";
export class CanvasGroup extends Behaviour {
    get alpha() {
        return this._alpha;
    }
    set alpha(val) {
        if (val === this._alpha)
            return;
        this._alpha = val;
        this.markDirty();
    }
    get isCanvasGroup() { return true; }
    _alpha = 1;
    interactable = true;
    blocksRaycasts = true;
    _isDirty = false;
    markDirty() {
        if (this._isDirty)
            return;
        this._isDirty = true;
        this.startCoroutine(this.applyChangesDelayed(), FrameEvent.OnBeforeRender);
    }
    *applyChangesDelayed() {
        this._isDirty = false;
        this.applyChangesNow();
    }
    _buffer = [];
    applyChangesNow() {
        for (const ch of GameObject.getComponentsInChildren(this.gameObject, Graphic, this._buffer)) {
            const col = ch.color;
            col.alpha = this._alpha;
            ch.color = col;
        }
    }
}
__decorate([
    serializable()
], CanvasGroup.prototype, "alpha", null);
__decorate([
    serializable()
], CanvasGroup.prototype, "interactable", void 0);
__decorate([
    serializable()
], CanvasGroup.prototype, "blocksRaycasts", void 0);
//# sourceMappingURL=CanvasGroup.js.map