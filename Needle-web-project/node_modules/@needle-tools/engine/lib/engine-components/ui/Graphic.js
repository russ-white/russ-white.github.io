var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { RGBAColor } from "../js-extensions/RGBAColor";
import { BaseUIComponent } from "./BaseUIComponent";
import { serializable } from '../../engine/engine_serialization_decorator';
import { LinearEncoding, sRGBEncoding } from 'three';
import { RectTransform } from './RectTransform';
import { onChange, scheduleAction } from "./Utils";
import { GameObject } from '../Component';
export class Graphic extends BaseUIComponent {
    get isGraphic() { return true; }
    get color() {
        if (!this._color)
            this._color = new RGBAColor(1, 1, 1, 1);
        return this._color;
    }
    set color(col) {
        const changed = !this._color || this._color.r !== col.r || this._color.g !== col.g || this._color.b !== col.b || this._color.alpha !== col.alpha;
        if (!changed)
            return;
        if (!this._color) {
            this._color = new RGBAColor(1, 1, 1, 1);
        }
        this._color.copy(col);
    }
    onColorChanged() {
        const newcolor = this.color;
        this.setOptions({ backgroundColor: newcolor, backgroundOpacity: newcolor.alpha, borderOpacity: newcolor.alpha });
    }
    // used via animations
    get m_Color() {
        return this._color;
    }
    raycastTarget = true;
    uiObject = null;
    _color = null;
    _rect = null;
    get rectTransform() {
        if (!this._rect) {
            this._rect = GameObject.getComponent(this.gameObject, RectTransform);
        }
        return this._rect;
    }
    setState(state) {
        this.makePanel();
        if (this.uiObject) {
            //@ts-ignore
            this.uiObject.setState(state);
        }
    }
    setupState(state) {
        this.makePanel();
        if (this.uiObject) {
            //@ts-ignore
            this.uiObject.setupState(state);
        }
    }
    setOptions(opts) {
        this.makePanel();
        if (this.uiObject) {
            //@ts-ignore
            this.uiObject.set(opts);
            if (opts["backgroundColor"] !== undefined || opts["backgroundOpacity"] !== undefined)
                this.uiObject["updateBackgroundMaterial"]?.call(this.uiObject);
        }
    }
    awake() {
        super.awake();
        this.makePanel();
        // when _color is written to
        onChange(this, "_color", () => scheduleAction(this, this.onColorChanged));
    }
    onEnable() {
        super.onEnable();
        if (this.uiObject) {
            this.rectTransform.shadowComponent?.add(this.uiObject);
            this.addShadowComponent(this.uiObject, this.rectTransform);
        }
    }
    onDisable() {
        super.onDisable();
        if (this.uiObject)
            this.removeShadowComponent();
    }
    _currentlyCreatingPanel = false;
    makePanel() {
        if (this.uiObject)
            return;
        if (this._currentlyCreatingPanel)
            return;
        this._currentlyCreatingPanel = true;
        const opts = {
            backgroundColor: this.color,
            backgroundOpacity: this.color.alpha,
            offset: 1, // without a tiny offset we get z fighting
        };
        this.onBeforeCreate(opts);
        this.onCreate(opts);
        this.controlsChildLayout = false;
        this._currentlyCreatingPanel = false;
        this.onAfterCreated();
    }
    onBeforeCreate(_opts) { }
    onCreate(opts) {
        this.uiObject = this.rectTransform.createNewBlock(opts);
        this.uiObject.name = this.name;
    }
    onAfterCreated() { }
    /** used internally to ensure textures assigned to UI use linear encoding */
    static textureCache = new Map();
    async setTexture(tex) {
        if (!tex)
            return;
        this.setOptions({ backgroundOpacity: 0 });
        if (tex) {
            // workaround for https://github.com/needle-tools/needle-engine-support/issues/109
            if (tex.encoding === sRGBEncoding) {
                if (Graphic.textureCache.has(tex)) {
                    tex = Graphic.textureCache.get(tex);
                }
                else {
                    const clone = tex.clone();
                    clone.encoding = LinearEncoding;
                    Graphic.textureCache.set(tex, clone);
                    tex = clone;
                }
            }
            this.setOptions({ backgroundTexture: tex, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" });
        }
    }
    onAfterAddedToScene() {
        super.onAfterAddedToScene();
        if (this.shadowComponent) {
            //@ts-ignore
            this.shadowComponent.offset = this.shadowComponent.position.z;
            // console.log(this.shadowComponent);
            // setTimeout(()=>{
            //     this.shadowComponent?.traverse(c => {
            //         console.log(c);
            //         if(c.material) c.material.depthTest = false;
            //     });
            // },1000);
        }
    }
}
__decorate([
    serializable(RGBAColor)
], Graphic.prototype, "color", null);
__decorate([
    serializable()
], Graphic.prototype, "raycastTarget", void 0);
export class MaskableGraphic extends Graphic {
    onAfterCreated() {
        // flip image
        if (this.uiObject)
            this.uiObject.scale.y *= -1;
    }
}
//# sourceMappingURL=Graphic.js.map