var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { updateRenderSettings as updateRenderSettingsRecursive } from "./Utils";
import { serializable } from "../../engine/engine_serialization_decorator";
import { FrameEvent } from "../../engine/engine_setup";
import { BaseUIComponent, UIRootComponent } from "./BaseUIComponent";
import { Mathf } from "../../engine/engine_math";
import { GameObject } from "../Component";
export var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
    RenderMode[RenderMode["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
    RenderMode[RenderMode["WorldSpace"] = 2] = "WorldSpace";
})(RenderMode || (RenderMode = {}));
export class Canvas extends UIRootComponent {
    set renderOnTop(val) {
        if (val === this._renderOnTop) {
            return;
        }
        this._renderOnTop = val;
        this.onRenderSettingsChanged();
    }
    get renderOnTop() { return this._renderOnTop; }
    _renderOnTop = false;
    set depthWrite(val) {
        if (this._depthWrite === val)
            return;
        this._depthWrite = val;
        this.onRenderSettingsChanged();
    }
    get depthWrite() { return this._depthWrite; }
    _depthWrite = false;
    set doubleSided(val) {
        if (this._doubleSided === val)
            return;
        this._doubleSided = val;
        this.onRenderSettingsChanged();
    }
    get doubleSided() { return this._doubleSided; }
    _doubleSided = true;
    set castShadows(val) {
        if (this._castShadows === val)
            return;
        this._castShadows = val;
        this.onRenderSettingsChanged();
    }
    get castShadows() { return this._castShadows; }
    _castShadows = true;
    set receiveShadows(val) {
        if (this._receiveShadows === val)
            return;
        this._receiveShadows = val;
        this.onRenderSettingsChanged();
    }
    get receiveShadows() { return this._receiveShadows; }
    _receiveShadows = true;
    get renderMode() {
        return this._renderMode;
    }
    set renderMode(val) {
        if (this._renderMode === val)
            return;
        this._renderMode = val;
        this.onRenderSettingsChanged();
    }
    _renderMode = -1;
    _rootCanvas;
    set rootCanvas(val) {
        if (this._rootCanvas instanceof Canvas)
            return;
        this._rootCanvas = val;
    }
    get rootCanvas() {
        return this._rootCanvas;
    }
    _scaleFactor = 1;
    get scaleFactor() {
        return this._scaleFactor;
    }
    set scaleFactor(val) {
        this._scaleFactor = val;
    }
    awake() {
        this.shadowComponent = this.gameObject;
        super.awake();
    }
    onEnable() {
        super.onEnable();
        this._updateRenderSettingsRoutine = undefined;
        this.onRenderSettingsChanged();
    }
    previousAspect = -1;
    onBeforeRender() {
        if (this.isScreenSpace && this.context.mainCameraComponent && this.context.mainCameraComponent.aspect !== this.previousAspect) {
            this.previousAspect = this.context.mainCameraComponent.aspect;
            this.updateRenderMode();
        }
    }
    _updateRenderSettingsRoutine;
    onRenderSettingsChanged() {
        if (this._updateRenderSettingsRoutine)
            return;
        this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), FrameEvent.OnBeforeRender);
    }
    *_updateRenderSettingsDelayed() {
        yield;
        this._updateRenderSettingsRoutine = undefined;
        if (this.shadowComponent) {
            this.updateRenderMode();
            // this.onWillUpdateRenderSettings();
            updateRenderSettingsRecursive(this.shadowComponent, this);
            for (const ch of GameObject.getComponentsInChildren(this.gameObject, BaseUIComponent)) {
                updateRenderSettingsRecursive(ch.shadowComponent, this);
            }
        }
    }
    _activeRenderMode = -1;
    get isScreenSpace() {
        return this._activeRenderMode === RenderMode.ScreenSpaceCamera || this._activeRenderMode === RenderMode.ScreenSpaceOverlay;
    }
    updateRenderMode() {
        if (this.renderMode === this._activeRenderMode)
            return;
        switch (this.renderMode) {
            case RenderMode.ScreenSpaceOverlay:
            case RenderMode.ScreenSpaceCamera:
                const camera = this.context.mainCameraComponent;
                if (!camera)
                    return;
                const canvas = this.gameObject;
                const camObj = camera.gameObject;
                camObj?.add(canvas);
                const pos = camera.farClipPlane;
                canvas.position.x = 0;
                canvas.position.y = 0;
                canvas.position.z = -pos;
                // console.log(this.shadowComponent)
                const w = Math.tan(Mathf.toRadians(camera.fieldOfView) * pos) * (camera.aspect * 1.333333);
                const h = w * (this.context.domHeight / this.context.domWidth);
                canvas.scale.x = -w;
                canvas.scale.y = h;
                // const rects = this.gameObject.getComponentsInChildren(BaseUIComponent);
                // for (const rect of rects) {
                //     rect.set({ width: this.context.domWidth * .5, height: 100 })
                // }
                break;
            case RenderMode.WorldSpace:
                break;
        }
    }
}
__decorate([
    serializable()
], Canvas.prototype, "renderOnTop", null);
__decorate([
    serializable()
], Canvas.prototype, "depthWrite", null);
__decorate([
    serializable()
], Canvas.prototype, "doubleSided", null);
__decorate([
    serializable()
], Canvas.prototype, "castShadows", null);
__decorate([
    serializable()
], Canvas.prototype, "receiveShadows", null);
__decorate([
    serializable()
], Canvas.prototype, "renderMode", null);
__decorate([
    serializable(Canvas)
], Canvas.prototype, "rootCanvas", null);
__decorate([
    serializable()
], Canvas.prototype, "scaleFactor", null);
//# sourceMappingURL=Canvas.js.map