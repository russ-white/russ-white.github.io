var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour, GameObject } from "../Component";
import { EventList } from "../EventList";
import { Image } from "./Image";
import { RGBAColor } from "../js-extensions/RGBAColor";
import { serializable } from "../../engine/engine_serialization_decorator";
import { Animator } from "../Animator";
import { getParam } from "../../engine/engine_utils";
const debug = getParam("debugbutton");
/// <summary>
///Transition mode for a Selectable.
/// </summary>
export var Transition;
(function (Transition) {
    /// <summary>
    /// No Transition.
    /// </summary>
    Transition[Transition["None"] = 0] = "None";
    /// <summary>
    /// Use an color tint transition.
    /// </summary>
    Transition[Transition["ColorTint"] = 1] = "ColorTint";
    /// <summary>
    /// Use a sprite swap transition.
    /// </summary>
    Transition[Transition["SpriteSwap"] = 2] = "SpriteSwap";
    /// <summary>
    /// Use an animation transition.
    /// </summary>
    Transition[Transition["Animation"] = 3] = "Animation";
})(Transition || (Transition = {}));
export class Button extends Behaviour {
    onClick;
    _isHovered = false;
    onPointerEnter(_) {
        if (debug)
            console.log("Button Enter", this.animationTriggers?.highlightedTrigger, this.animator);
        this._isHovered = true;
        if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
            this.animator.SetTrigger(this.animationTriggers.highlightedTrigger);
        }
        else if (this.transition === Transition.ColorTint && this.colors) {
            this._image?.setState("hovered");
        }
        this.context.input.setCursorPointer();
    }
    onPointerExit() {
        if (debug)
            console.log("Button Exit", this.animationTriggers?.highlightedTrigger, this.animator);
        this._isHovered = false;
        if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
            this.animator.SetTrigger(this.animationTriggers.normalTrigger);
        }
        else if (this.transition === Transition.ColorTint && this.colors) {
            this._image?.setState("normal");
        }
        this.context.input.setCursorNormal();
    }
    onPointerDown(_) {
        if (debug)
            console.log("Button Down", this.animationTriggers?.highlightedTrigger, this.animator);
        if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
            this.animator.SetTrigger(this.animationTriggers.pressedTrigger);
        }
        else if (this.transition === Transition.ColorTint && this.colors) {
            this._image?.setState("pressed");
        }
    }
    onPointerUp(_) {
        if (debug)
            console.log("Button Down", this.animationTriggers?.highlightedTrigger, this.animator);
        if (this.transition == Transition.Animation && this.animationTriggers && this.animator) {
            this.animator.SetTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger);
        }
        else if (this.transition === Transition.ColorTint && this.colors) {
            this._image?.setState(this._isHovered ? "hovered" : "normal");
        }
    }
    onPointerClick(_args) {
        if (debug)
            console.trace("Button Click", this.onClick);
        this.onClick?.invoke();
    }
    colors;
    transition;
    animationTriggers;
    animator;
    // @serializable(Image)
    // image? : Image;
    set interactable(value) {
        this._interactable = value;
        if (this._image) {
            this._image.setInteractable(value);
            if (value)
                this._image.setState("normal");
            else
                this._image.setState("disabled");
        }
    }
    get interactable() { return this._interactable; }
    _interactable = true;
    set_interactable(value) {
        this.interactable = value;
    }
    awake() {
        super.awake();
        if (debug)
            console.log(this);
        this.init();
    }
    start() {
        this._image?.setInteractable(this.interactable);
    }
    onEnable() {
        super.onEnable();
    }
    _requestedAnimatorTrigger;
    *setAnimatorTriggerAtEndOfFrame(requestedTriggerId) {
        this._requestedAnimatorTrigger = requestedTriggerId;
        yield;
        yield;
        if (this._requestedAnimatorTrigger == requestedTriggerId) {
            this.animator?.SetTrigger(requestedTriggerId);
        }
    }
    _isInit = false;
    _image;
    init() {
        if (this._isInit)
            return;
        this._isInit = true;
        this._image = GameObject.getComponent(this.gameObject, Image);
        if (this._image) {
            this.stateSetup(this._image);
            if (this.interactable)
                this._image.setState("normal");
            else
                this._image.setState("disabled");
        }
    }
    stateSetup(image) {
        image.setInteractable(this.interactable);
        const normal = this.getFinalColor(image.color, this.colors?.normalColor);
        const normalState = {
            state: "normal",
            attributes: {
                backgroundColor: normal,
                backgroundOpacity: normal.alpha,
            },
        };
        image.setupState(normalState);
        const hover = this.getFinalColor(image.color, this.colors?.highlightedColor);
        const hoverState = {
            state: "hovered",
            attributes: {
                backgroundColor: hover,
                backgroundOpacity: hover.alpha,
            },
        };
        image.setupState(hoverState);
        const pressed = this.getFinalColor(image.color, this.colors?.pressedColor);
        const pressedState = {
            state: "pressed",
            attributes: {
                backgroundColor: pressed,
                backgroundOpacity: pressed.alpha,
            }
        };
        image.setupState(pressedState);
        const selected = this.getFinalColor(image.color, this.colors?.selectedColor);
        const selectedState = {
            state: "selected",
            attributes: {
                backgroundColor: selected,
                backgroundOpacity: selected.alpha,
            }
        };
        image.setupState(selectedState);
        const disabled = this.getFinalColor(image.color, this.colors?.disabledColor);
        const disabledState = {
            state: "disabled",
            attributes: {
                backgroundColor: disabled,
                backgroundOpacity: disabled.alpha,
            }
        };
        image.setupState(disabledState);
    }
    getFinalColor(col, col2) {
        if (col2) {
            return col.clone().multiply(col2);
        }
        return col.clone();
    }
}
__decorate([
    serializable(EventList)
], Button.prototype, "onClick", void 0);
__decorate([
    serializable()
], Button.prototype, "colors", void 0);
__decorate([
    serializable()
], Button.prototype, "transition", void 0);
__decorate([
    serializable()
], Button.prototype, "animationTriggers", void 0);
__decorate([
    serializable(Animator)
], Button.prototype, "animator", void 0);
__decorate([
    serializable()
], Button.prototype, "interactable", null);
//# sourceMappingURL=Button.js.map