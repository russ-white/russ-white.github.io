var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Behaviour } from "./Component";
import * as THREE from 'three';
import { AnimationClip } from "three";
import { serializable } from "../engine/engine_serialization_decorator";
import { InstancingUtil } from "../engine/engine_instancing";
import { Mathf } from "../engine/engine_math";
import { getParam } from "../engine/engine_utils";
const debug = getParam("debuganimation");
export class Animation extends Behaviour {
    playAutomatically = true;
    randomStartTime = true;
    minMaxSpeed;
    minMaxOffsetNormalized;
    loop = true;
    clampWhenFinished = false;
    _tempAnimationClipBeforeGameObjectExisted = null;
    get clip() {
        return this.animations?.length ? this.animations[0] : null;
    }
    set clip(val) {
        if (!this.__didAwake) {
            if (debug)
                console.log("Assign clip during serialization", val);
            this._tempAnimationClipBeforeGameObjectExisted = val;
            return;
        }
        if (!val)
            return;
        if (debug)
            console.log("Assign clip", val, Boolean(this.gameObject));
        if (!this.gameObject.animations)
            this.gameObject.animations = [];
        if (this.animations.includes(val))
            return;
        if (this.animations.length > 0) {
            this.animations.splice(0, 0, val);
        }
        else
            this.animations.push(val);
    }
    set clips(animations) {
        this.animations = animations;
    }
    set animations(animations) {
        if (debug)
            console.log("assign animations", animations);
        this.gameObject.animations = animations;
    }
    get animations() {
        return this.gameObject.animations;
    }
    /**
     * @deprecated Currently unsupported
     */
    get currentAction() {
        return this._currentActions[0];
    }
    /**
     * @deprecated Currently unsupported
     */
    get currentActions() {
        return this._currentActions;
    }
    mixer = undefined;
    get actions() {
        return this._actions;
    }
    set actions(val) {
        this._actions = val;
    }
    _actions = [];
    // private _currentAction: THREE.AnimationAction | null = null;
    _currentActions = [];
    _handles = [];
    awake() {
        if (debug)
            console.log(this);
        if (this._tempAnimationClipBeforeGameObjectExisted) {
            this.clip = this._tempAnimationClipBeforeGameObjectExisted;
            this._tempAnimationClipBeforeGameObjectExisted = null;
        }
        // console.log(...this.animations.map(m => m.name))
        if (this.playAutomatically)
            this.init();
    }
    onEnable() {
        if (this.playAutomatically && this.animations?.length > 0 && this.currentActions.length <= 0) {
            const index = Math.floor(Math.random() * this.actions.length);
            this.play(index);
        }
    }
    start() {
        if (this.randomStartTime && this.currentAction)
            this.currentAction.time = Math.random() * this.currentAction.getClip().duration;
    }
    update() {
        if (!this.mixer)
            return;
        this.mixer.update(this.context.time.deltaTime);
        for (const handle of this._handles) {
            handle._update();
        }
        if (this._handles?.length > 0)
            InstancingUtil.markDirty(this.gameObject);
    }
    getAction(name) {
        return this.actions?.find(a => a.getClip().name === name);
    }
    get isPlaying() {
        for (let i = 0; i < this._currentActions.length; i++) {
            if (this._currentActions[i].isRunning())
                return true;
        }
        return false;
    }
    play(clipOrNumber, options) {
        this.init();
        if (!this.mixer)
            return;
        if (clipOrNumber === undefined)
            clipOrNumber = 0;
        let clip = clipOrNumber;
        if (typeof clipOrNumber === 'number') {
            if (clipOrNumber >= this.animations.length)
                return;
            clip = this.animations[clipOrNumber];
        }
        else if (typeof clipOrNumber === "string") {
            clip = this.animations.find(a => a.name === clipOrNumber);
        }
        if (!clip) {
            console.error("Could not find clip", clipOrNumber);
            return;
        }
        if (!options)
            options = {};
        if (!options.minMaxOffsetNormalized)
            options.minMaxOffsetNormalized = this.minMaxOffsetNormalized;
        if (!options.minMaxSpeed)
            options.minMaxSpeed = this.minMaxSpeed;
        if (!options.loop)
            options.loop = this.loop;
        if (!options.clampWhenFinished)
            options.clampWhenFinished = this.clampWhenFinished;
        for (const act of this.actions) {
            if (act.getClip() === clip) {
                return this.internalOnPlay(act, options);
            }
        }
        const act = this.mixer.clipAction(clip);
        this.actions.push(act);
        return this.internalOnPlay(act, options);
    }
    internalOnPlay(action, options) {
        var prev = this.currentAction;
        if (prev === action && prev.isRunning() && prev.time < prev.getClip().duration) {
            const handle = this.tryFindHandle(action);
            if (handle)
                return handle.getPromise();
        }
        const stopOther = options?.exclusive ?? true;
        if (options?.fadeDuration) {
            if (stopOther)
                prev?.fadeOut(options.fadeDuration);
            action.fadeIn(options.fadeDuration);
        }
        else {
            if (stopOther)
                prev?.stop();
        }
        action.reset();
        action.enabled = true;
        action.time = 0;
        action.timeScale = 1;
        const clip = action.getClip();
        if (options?.minMaxOffsetNormalized)
            action.time = Mathf.lerp(options.minMaxOffsetNormalized.x, options.minMaxOffsetNormalized.y, Math.random()) * clip.duration;
        if (options?.minMaxSpeed)
            action.timeScale = Mathf.lerp(options.minMaxSpeed.x, options.minMaxSpeed.y, Math.random());
        if (options?.clampWhenFinished)
            action.clampWhenFinished = true;
        if (options?.startTime !== undefined)
            action.time = options.startTime;
        if (options?.loop !== undefined)
            action.loop = options.loop ? THREE.LoopRepeat : THREE.LoopOnce;
        else
            action.loop = THREE.LoopOnce;
        action.play();
        // console.log("PLAY", action.getClip().name, action)
        const handle = new AnimationHandle(action, this.mixer, options, _ => {
            this._handles.splice(this._handles.indexOf(handle), 1);
            // console.log(this._handles);
        });
        this._handles.push(handle);
        return handle.getPromise();
    }
    tryFindHandle(action) {
        for (const handle of this._handles) {
            if (handle.action === action)
                return handle;
        }
        return undefined;
    }
    _didInit = false;
    init() {
        if (this._didInit)
            return;
        this._didInit = true;
        if (!this.gameObject)
            return;
        this.actions = [];
        this.mixer = new THREE.AnimationMixer(this.gameObject);
    }
}
__decorate([
    serializable()
], Animation.prototype, "playAutomatically", void 0);
__decorate([
    serializable()
], Animation.prototype, "randomStartTime", void 0);
__decorate([
    serializable()
], Animation.prototype, "loop", void 0);
__decorate([
    serializable()
], Animation.prototype, "clampWhenFinished", void 0);
__decorate([
    serializable(AnimationClip)
], Animation.prototype, "clips", null);
class AnimationHandle {
    mixer;
    action;
    promise = null;
    resolve = null;
    reject = null;
    _options;
    _resolveCallback = null;
    _rejectCallback = null;
    _loopCallback;
    _finishedCallback;
    _resolvedOrRejectedCallback;
    constructor(action, mixer, opts, cb) {
        this.action = action;
        this.mixer = mixer;
        this._resolvedOrRejectedCallback = cb;
        this._options = opts;
    }
    getPromise() {
        if (this.promise)
            return this.promise;
        this.promise = new Promise((res, rej) => {
            this._resolveCallback = res;
            this._rejectCallback = rej;
            this.resolve = this.onResolve.bind(this);
            this.reject = this.onReject.bind(this);
        });
        this._loopCallback = this.onLoop.bind(this);
        this._finishedCallback = this.onFinished.bind(this);
        this.mixer.addEventListener('loop', this._loopCallback);
        this.mixer.addEventListener('finished', this._finishedCallback);
        return this.promise;
    }
    _update() {
        if (!this._options)
            return;
        if (this._options.endTime !== undefined && this.action.time > this._options.endTime) {
            if (this._options.loop === true) {
                this.action.time = this._options.startTime ?? 0;
            }
            else {
                // this.action.stop();
                this.action.time = this._options.endTime;
                this.action.timeScale = 0;
                // if (!this._options.clampWhenFinished)
                //     this.action.stop();
                this.onResolve();
            }
        }
    }
    onResolve() {
        this.dispose();
        this._resolvedOrRejectedCallback?.call(this, this);
        this._resolveCallback?.call(this, this.action);
    }
    onReject(reason) {
        this.dispose();
        this._resolvedOrRejectedCallback?.call(this, this);
        this._rejectCallback?.call(this, reason);
    }
    onLoop(_evt) {
        // console.log("LOOP");
    }
    onFinished(evt) {
        if (evt.action === this.action) {
            // console.log("FINISHED", evt, this.action);
            this.onResolve();
        }
    }
    dispose() {
        if (this._loopCallback)
            this.mixer.removeEventListener('loop', this._loopCallback);
        if (this._finishedCallback)
            this.mixer.removeEventListener('finished', this._finishedCallback);
        this._loopCallback = undefined;
        this._finishedCallback = undefined;
    }
}
//# sourceMappingURL=Animation.js.map