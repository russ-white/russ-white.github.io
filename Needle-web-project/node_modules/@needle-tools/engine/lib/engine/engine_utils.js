// https://schneidenbach.gitbooks.io/typescript-cookbook/content/nameof-operator.html
export const nameofFactory = () => (name) => name;
export function nameof(name) {
    return nameofFactory()(name);
}
export function isDebugMode() {
    return getParam("debug") ? true : false;
}
export class CircularBuffer {
    _factory;
    _cache = [];
    _maxSize;
    _index = 0;
    constructor(factory, maxSize) {
        this._factory = factory;
        this._maxSize = maxSize;
    }
    get() {
        let i = this._index++;
        if (i >= this._cache.length) {
            if (i >= this._maxSize) {
                i = this._index = 0;
            }
            else {
                this._cache.push(this._factory());
            }
        }
        return this._cache[i];
    }
}
let saveParams = false;
const requestedParams = [];
setTimeout(() => {
    if (saveParams)
        console.log(requestedParams);
}, 100);
export function getUrlParams() {
    return new URLSearchParams(window.location.search);
}
export function getParam(paramName) {
    if (saveParams && !requestedParams.includes(paramName))
        requestedParams.push(paramName);
    const urlParams = getUrlParams();
    if (urlParams.has(paramName)) {
        const val = urlParams.get(paramName);
        if (val) {
            return val;
        }
        else
            return true;
    }
    return false;
}
saveParams = getParam("help") === true;
export function setParam(paramName, paramValue) {
    const urlParams = getUrlParams();
    if (urlParams.has(paramName)) {
        urlParams.set(paramName, paramValue);
    }
    else
        urlParams.append(paramName, paramValue);
    document.location.search = urlParams.toString();
}
export function setParamWithoutReload(paramName, paramValue, appendHistory = true) {
    const urlParams = getUrlParams();
    if (urlParams.has(paramName)) {
        urlParams.set(paramName, paramValue);
    }
    else
        urlParams.append(paramName, paramValue);
    if (appendHistory)
        pushState(paramName, urlParams);
    else
        setState(paramName, urlParams);
}
export function setOrAddParamsToUrl(url, paramName, paramValue) {
    if (url.has(paramName)) {
        url.set(paramName, paramValue.toString());
    }
    else
        url.append(paramName, paramValue.toString());
}
export function pushState(title, urlParams) {
    window.history.pushState(null, title, "?" + urlParams.toString());
}
export function setState(title, urlParams) {
    window.history.replaceState(null, title, "?" + urlParams.toString());
}
// for room id
export function makeId(length) {
    var result = '';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() *
            charactersLength));
    }
    return result;
}
export function randomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
const adjectives = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"];
const nouns = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"];
export function makeIdFromRandomWords() {
    const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
    return randomAdjective + "_" + randomNoun;
}
// for url parameters
export function sanitizeString(str) {
    str = str.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, "");
    return str.trim();
}
// TODO: taken from scene utils
export function tryFindObject(globalObjectIdentifier, obj, recursive = true, searchComponents = false) {
    if (obj === undefined || obj === null)
        return null;
    if (obj.userData && obj.userData.guid === globalObjectIdentifier)
        return obj;
    else if (obj.guid == globalObjectIdentifier)
        return obj;
    if (searchComponents) {
        if (obj.userData?.components) {
            for (const comp of obj.userData.components) {
                if (comp.guid === globalObjectIdentifier)
                    return comp;
            }
        }
    }
    if (recursive) {
        if (obj.scenes) {
            for (const i in obj.scenes) {
                const scene = obj.scenes[i];
                const found = tryFindObject(globalObjectIdentifier, scene, recursive, searchComponents);
                if (found)
                    return found;
            }
        }
        if (obj.children) {
            for (const i in obj.children) {
                const child = obj.children[i];
                const found = tryFindObject(globalObjectIdentifier, child, recursive, searchComponents);
                if (found)
                    return found;
            }
        }
    }
}
export function deepClone(obj, predicate) {
    if (obj !== null && obj !== undefined && typeof obj === "object") {
        let clone;
        if (Array.isArray(obj))
            clone = [];
        else {
            clone = Object.create(obj);
            Object.assign(clone, obj);
        }
        for (const key of Object.keys(obj)) {
            const val = obj[key];
            if (predicate && !predicate(obj, key, val)) {
                // console.log("SKIP", val);
                clone[key] = val;
            }
            else if (val?.clone !== undefined && typeof val.clone === "function")
                clone[key] = val.clone();
            else
                clone[key] = deepClone(val, predicate);
        }
        return clone;
    }
    return obj;
}
export function delay(milliseconds) {
    return new Promise((res, _) => {
        setTimeout(res, milliseconds);
    });
}
// if a timeline is exported via menu item the audio clip path is relative to the glb (same folder)
// we need to detect that here and build the new audio source path relative to the new glb location
// the same is/might be true for any file that is/will be exported via menu item
const debugGetPath = getParam("debugsourcepath");
export function getPath(source, uri) {
    if (source === undefined) {
        if (debugGetPath)
            console.warn("getPath: source is undefined, returning uri", uri);
        return uri;
    }
    if (uri.startsWith("http")) {
        if (debugGetPath)
            console.warn("getPath: uri is absolute, returning uri", uri);
        return uri;
    }
    const pathIndex = source.lastIndexOf("/");
    if (pathIndex >= 0) {
        let newUri = source.substring(0, pathIndex + 1);
        const uriDirectoryIndex = uri.lastIndexOf("/");
        if (uriDirectoryIndex >= 0) {
            newUri += uri.substring(uriDirectoryIndex + 1);
        }
        else {
            newUri += uri;
        }
        if (debugGetPath)
            console.log("getPath:", source, " - changed uri from\n", uri, "\n→ ", newUri);
        return newUri;
    }
    return uri;
}
// TODO: make it possible to add multiple watches to the same object property
class WatchImpl {
    subscribeWrite(callback) {
        this.writeCallbacks.push(callback);
    }
    writeCallbacks = [];
    constructor(object, prop) {
        this._object = object;
        this._prop = prop;
        this._wrapperProp = Symbol("$" + prop);
        this.apply();
    }
    _applied = false;
    _object;
    _prop;
    _wrapperProp;
    apply() {
        if (this._applied)
            return;
        if (!this._object)
            return;
        const object = this._object;
        const prop = this._prop;
        if (object[prop] === undefined)
            return;
        this._applied = true;
        if (object[this._wrapperProp] !== undefined) {
            console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported");
        }
        // create a wrapper property
        const current = object[prop];
        object[this._wrapperProp] = current;
        // create wrapper methods
        const getter = () => {
            return object[this._wrapperProp];
        };
        const setter = (value) => {
            object[this._wrapperProp] = value;
            for (const write of this.writeCallbacks) {
                write(value, this._prop);
            }
        };
        // add the wrapper to the object
        Object.defineProperty(object, prop, {
            get: getter,
            set: setter
        });
    }
    revoke() {
        if (!this._applied)
            return;
        if (!this._object)
            return;
        this._applied = false;
        const object = this._object;
        const prop = this._prop;
        Reflect.deleteProperty(object, prop);
        const current = object[this._wrapperProp];
        object[prop] = current;
        Reflect.deleteProperty(object, this._wrapperProp);
    }
    dispose() {
        this.revoke();
        this.writeCallbacks.length = 0;
        this._object = null;
    }
}
export class Watch {
    _watches = [];
    constructor(object, str) {
        if (Array.isArray(str)) {
            for (const s of str) {
                this._watches.push(new Watch(object, s));
            }
        }
        else {
            this._watches.push(new WatchImpl(object, str));
        }
    }
    subscribeWrite(callback) {
        for (const w of this._watches) {
            w.subscribeWrite(callback);
        }
    }
    apply() {
        for (const w of this._watches) {
            w.apply();
        }
    }
    revoke() {
        for (const w of this._watches) {
            w.revoke();
        }
    }
    dispose() {
        for (const w of this._watches) {
            w.dispose();
        }
        this._watches.length = 0;
    }
}
export function isMobileDevice() {
    return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
}
export function isMozillaXR() {
    return /WebXRViewer\//i.test(navigator.userAgent);
}
const iosDevices = ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'];
export function isiOS() {
    return iosDevices.includes(navigator.platform)
        // iPad on iOS 13 detection
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
}
export function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
//# sourceMappingURL=engine_utils.js.map