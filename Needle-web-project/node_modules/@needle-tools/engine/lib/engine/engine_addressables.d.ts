import { Context } from "./engine_setup";
import { SourceIdentifier } from "./engine_types";
import { InstantiateOptions } from "./engine_gameobject";
import { IGameObject } from "./engine_types";
export declare class Addressables {
    private _context;
    constructor(context: Context);
    private preUpdate;
    private _assetReferences;
    findAssetReference(uri: string): AssetReference | null;
    registerAssetReference(ref: AssetReference): AssetReference;
}
export type ProgressCallback = (asset: AssetReference, prog: ProgressEvent) => void;
export declare class AssetReference {
    static getOrCreate(sourceId: SourceIdentifier, uri: string, context: Context): AssetReference;
    private static currentlyInstantiating;
    get asset(): any;
    protected set asset(val: any);
    private _loading?;
    get uri(): string;
    get rawAsset(): any;
    private _asset;
    private _glbRoot?;
    private _uri;
    private _progressListeners;
    private _hash?;
    private _hashedUri;
    private _isLoadingRawBinary;
    private _rawBinary?;
    constructor(uri: string, hash?: string);
    private onResolvePrefab;
    private get mustLoad();
    isLoaded(): boolean | ArrayBuffer;
    unload(): void;
    preload(): Promise<ArrayBuffer | null>;
    loadAssetAsync(prog?: ProgressCallback | null): Promise<any>;
    instantiate(parent?: THREE.Object3D | InstantiateOptions): Promise<IGameObject | null>;
    instantiateSynced(parent?: THREE.Object3D | InstantiateOptions, saveOnServer?: boolean): Promise<IGameObject | null>;
    beginListenDownload(evt: ProgressCallback): void;
    endListenDownload(evt: ProgressCallback): void;
    private raiseProgressEvent;
    private onInstantiate;
    /**
     * try to ignore the intermediate created object
     * because it causes trouble if we instantiate an assetreference per player
     * and call destroy on the player marker root
     * @returns the scene root object if the asset was a glb/gltf
     */
    private tryGetActualGameObjectRoot;
}
