import { Context } from './engine_setup';
import * as flatbuffers from 'flatbuffers';
import { PeerNetworking } from './engine_networking_peer';
import { IModel, INetworkConnection, SendQueue } from './engine_networking_types';
export declare const debugNet: boolean;
export declare const debugOwner: boolean;
export interface INetworkingWebsocketUrlProvider {
    getWebsocketUrl(): string | null;
}
export declare interface IConnectionData {
    id: string;
}
export declare enum ConnectionEvents {
    ConnectionInfo = "connection-start-info"
}
export declare enum RoomEvents {
    Join = "join-room",
    Leave = "leave-room",
    JoinedRoom = "joined-room",
    LeftRoom = "left-room",
    UserJoinedRoom = "user-joined-room",
    UserLeftRoom = "user-left-room"
}
export declare class JoinedRoomResponse {
    room: string;
    viewId: string;
    allowEditing: boolean;
    inRoom: string[];
}
export declare class LeftRoomResponse {
    room: string;
}
export declare class UserJoinedOrLeftRoomModel {
    userId: string;
}
export declare enum OwnershipEvent {
    RequestHasOwner = "request-has-owner",
    ResponseHasOwner = "response-has-owner",
    RequestIsOwner = "request-is-owner",
    ResponseIsOwner = "response-is-owner",
    RequestOwnership = "request-ownership",
    GainedOwnership = "gained-ownership",
    RemoveOwnership = "remove-ownership",
    LostOwnership = "lost-ownership",
    GainedOwnershipBroadcast = "gained-ownership-broadcast",
    LostOwnershipBroadcast = "lost-ownership-broadcast"
}
export declare class OwnershipModel {
    guid: string;
    private connection;
    get hasOwnership(): boolean;
    get isOwned(): boolean | undefined;
    get isConnected(): boolean;
    private _hasOwnership;
    private _isOwned;
    private _gainSubscription;
    private _lostSubscription;
    private _hasOwnerResponse;
    constructor(connection: NetworkConnection, guid: string);
    private _isWaitingForOwnershipResponseCallback;
    updateIsOwned(): void;
    private onHasOwnerResponse;
    requestOwnershipIfNotOwned(): OwnershipModel;
    private waitForHasOwnershipRequestResponse;
    requestOwnershipAsync(): Promise<OwnershipModel>;
    requestOwnership(): OwnershipModel;
    freeOwnership(): OwnershipModel;
    destroy(): void;
    private onGainedOwnership;
    private onLostOwnership;
}
export declare type BinaryCallback = {
    (data: any | flatbuffers.ByteBuffer): void;
};
export declare class NetworkConnection implements INetworkConnection {
    private context;
    private _peer;
    constructor(context: Context);
    get peer(): PeerNetworking;
    tryGetState(guid: string): IModel | null;
    get connectionId(): string | null;
    get isDebugEnabled(): boolean;
    get isConnected(): boolean;
    get currentRoomName(): string | null;
    get allowEditing(): boolean;
    get currentRoomViewId(): string | null;
    get isInRoom(): boolean;
    get currentLatency(): number;
    userIsInRoom(id: string): boolean;
    private _usersInRoomCopy;
    usersInRoom(target?: string[] | null): string[];
    joinRoom(room: string, viewOnly?: boolean): void;
    leaveRoom(room?: string | null): void;
    send(key: string | OwnershipEvent, data?: IModel | object | boolean | null | string | number, queue?: SendQueue): void;
    sendDeleteRemoteState(guid: string): void;
    sendDeleteRemoteStateAll(): void;
    sendBinary(bin: Uint8Array): void;
    private _defaultMessagesBuffer;
    private _defaultMessagesBufferArray;
    sendBufferedMessagesNow(): void;
    beginListen(key: string | OwnershipEvent, callback: Function): Function;
    stopListening(key: string | OwnershipEvent, callback: Function | null): void;
    beginListenBinrary(identifier: string, callback: BinaryCallback): BinaryCallback;
    stopListenBinary(identifier: string, callback: any): void;
    private netWebSocketUrlProvider?;
    registerProvider(prov: INetworkingWebsocketUrlProvider): void;
    connect(): void;
    private _listeners;
    private _listenersBinary;
    private connected;
    private channelId;
    private _connectionId;
    private _isConnectingToWebsocket;
    private _ws;
    private _waitingForSocket;
    private _isInRoom;
    private _currentRoomName;
    private _currentRoomViewId;
    private _currentRoomAllowEditing;
    private _currentInRoom;
    private _state;
    private _currentDelay;
    private connectWebsocket;
    private onMessage;
    private handleIncomingBinaryMessage;
    private handleIncomingStringMessage;
    private toMessage;
    private sendWithWebsocket;
    private onSendQueued;
}
