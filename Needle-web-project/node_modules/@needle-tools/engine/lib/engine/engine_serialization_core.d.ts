import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import { Object3D } from "three";
import { Context } from "./engine_setup";
import { SourceIdentifier } from "./engine_types";
export type Constructor<T> = {
    new (...args: any[]): T;
};
export declare type NodeToObjectMap = {
    [nodeId: string]: Object3D;
};
export declare type ObjectToNodeMap = {
    [uuid: string]: number;
};
declare class SerializationHelper {
    register(type: string, ser: ITypeSerializer): void;
    typeMap: {
        [type: string]: ITypeSerializer;
    };
    getSerializer(type: string): ITypeSerializer | undefined;
    getSerializerForConstructor(type: any, level?: number): ITypeSerializer | undefined;
}
export declare const helper: SerializationHelper;
export interface ITypeSerializer {
    onSerialize(data: any, context: SerializationContext): any;
    onDeserialize(data: any, context: SerializationContext): any;
}
/**
 * implement and call super(<type string or array>) with the type names this serializer can handle
 * for example:
 * class ColorSerializer extends TypeSerializer {
 *  constructor() {
 *      super("Color")
 *  }
 * }
*/
export declare abstract class TypeSerializer implements ITypeSerializer {
    constructor(type: Constructor<any> | Constructor<any>[]);
    abstract onSerialize(data: any, context: SerializationContext): any | void;
    abstract onDeserialize(data: any, context: SerializationContext): any | void;
}
export interface ITypeInformation {
    type?: Constructor<any>;
}
/** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
export declare class ImplementationInformation {
    private isDevMode;
    private cache;
    /** only call when assigning values for the very first time */
    registerDefinedKeys(typeName: string, type: object): void;
    getDefinedKey(typeName: string, key: string): boolean;
}
export declare class SerializationContext {
    root: THREE.Object3D;
    gltf?: GLTF;
    gltfId?: SourceIdentifier;
    object: THREE.Object3D;
    target?: object;
    nodeId?: number;
    nodeToObject?: NodeToObjectMap;
    objectToNode?: ObjectToNodeMap;
    context?: Context;
    path?: string;
    type?: Constructor<any>;
    /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
    implementationInformation?: ImplementationInformation;
    constructor(root: THREE.Object3D);
}
export interface ISerializable {
    $serializedTypes?: {
        [key: string]: Constructor<any> | ITypeInformation | null;
    };
    onBeforeDeserialize?(data: any, context: SerializationContext): void | undefined | boolean;
    onBeforeDeserializeMember?(key: string, data: any, context: SerializationContext): void | undefined | boolean;
    onAfterDeserializeMember?(key: string, data: any, context: SerializationContext): void;
    onAfterDeserialize?(data: any, context: SerializationContext): void;
}
export declare function serializeObject(obj: ISerializable, context: SerializationContext): object | null;
export declare function deserializeObject(obj: ISerializable, serializedData: object, context: SerializationContext): boolean;
/** set to true while assigning properties during instantiation.
 * Used for validate decorator to not invoke callbacks on components that are currently in the process of being built */
export declare const $isAssigningProperties: unique symbol;
/** Object.assign behaviour but check if property is writeable (e.g. getter only properties are skipped) */
export declare function assign(target: any, source: any, info?: ImplementationInformation): void;
export {};
