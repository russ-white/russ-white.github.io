import { Camera, Intersection, Layers, Mesh, Object3D, Ray, Raycaster, Vector2, Vector3 } from 'three';
import { Context } from './engine_setup';
import { IComponent, ICollider, IRigidbody, Vec3, Vec2 } from './engine_types';
import RAPIER, { RigidBody } from '@dimforge/rapier3d-compat';
export type Rapier = typeof RAPIER;
export declare class RaycastOptions {
    ray: Ray | undefined;
    cam: Camera | undefined | null;
    screenPoint: Vector2 | undefined;
    raycaster: Raycaster | undefined;
    results: Array<Intersection> | undefined;
    targets: Array<Object3D> | undefined;
    recursive: boolean | undefined;
    minDistance: number | undefined;
    maxDistance: number | undefined;
    lineThreshold: number | undefined;
    layerMask: Layers | number | undefined;
    ignore: Object3D[] | undefined;
    screenPointFromOffset(ox: number, oy: number): void;
    setMask(mask: number): void;
    static AllLayers: number;
}
export declare class SphereIntersection implements Intersection {
    distance: number;
    point: Vector3;
    object: Object3D;
    constructor(object: Object3D, distance: number, point: Vector3);
}
export declare class Physics {
    private readonly raycaster;
    private readonly defaultRaycastOptions;
    private readonly targetBuffer;
    private readonly defaultThresholds;
    private sphereResults;
    private sphereMask;
    sphereOverlap(spherePos: Vector3, radius: number, traverseChildsAfterHit?: boolean): Array<Intersection>;
    private tempBoundingBox;
    private onSphereOverlap;
    raycastFromRay(ray: Ray, options?: RaycastOptions | null): Array<Intersection>;
    /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
     * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
     * Raycasting SkinnedMeshes is specially expensive.
     */
    raycast(options?: RaycastOptions | null): Array<Intersection>;
    private rapierRay;
    private raycastVectorsBuffer;
    /** raycast against colliders */
    raycastPhysicsFast(origin: Vec2 | Vec3, direction?: Vec3 | undefined, maxDistance?: number, solid?: boolean): null | {
        point: Vector3;
        collider: ICollider;
    };
    private getPhysicsRay;
    private _tempPosition;
    private _tempQuaternion;
    private _tempScale;
    private _tempMatrix;
    private static _didLoadPhysicsEngine;
    private _isUpdatingPhysicsWorld;
    get isUpdating(): boolean;
    private context;
    private world?;
    private _hasCreatedWorld;
    private eventQueue?;
    private collisionHandler?;
    private objects;
    private bodies;
    private _meshCache;
    constructor(context: Context);
    createWorld(): Promise<void>;
    clearCaches(): void;
    addBoxCollider(collider: ICollider, center: Vector3, size: Vector3): void;
    addSphereCollider(collider: ICollider, center: Vector3, radius: number): void;
    addCapsuleCollider(collider: ICollider, center: Vector3, height: number, radius: number): void;
    addMeshCollider(collider: ICollider, mesh: Mesh, convex: boolean, scale: Vector3): void;
    private createCollider;
    private getRigidbody;
    removeBody(obj: IComponent): void;
    updateBody(comp: ICollider | IRigidbody, translation: boolean, rotation: boolean): void;
    updateProperties(rigidbody: IRigidbody): void;
    internal_getRigidbody(rb: IRigidbody): RigidBody | null;
    private internalUpdateProperties;
    private lines?;
    step(_deltaTime?: number): void;
    private updateDebugRendering;
    postStep(): void;
    /** sync rendered objects with physics world (except for colliders without rigidbody) */
    private syncObjects;
    private syncPhysicsBody;
    private static _matricesBuffer;
    private getRigidbodyRelativeMatrix;
    private static centerConnectionPos;
    private static centerConnectionRot;
    addFixedJoint(body1: IRigidbody, body2: IRigidbody): void;
    addHingeJoint(body1: IRigidbody, body2: IRigidbody, anchor: {
        x: number;
        y: number;
        z: number;
    }, axis: {
        x: number;
        y: number;
        z: number;
    }): void;
    private calculateJointRelativeMatrices;
}
