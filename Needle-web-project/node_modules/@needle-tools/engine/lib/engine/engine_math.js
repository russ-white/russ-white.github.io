class MathHelper {
    random() {
        return Math.random();
    }
    clamp(value, min, max) {
        if (value < min) {
            return min;
        }
        else if (value > max) {
            return max;
        }
        return value;
    }
    clamp01(value) {
        return this.clamp(value, 0, 1);
    }
    lerp(value1, value2, t) {
        t = t < 0 ? 0 : t;
        t = t > 1 ? 1 : t;
        return value1 + (value2 - value1) * t;
    }
    inverseLerp(value1, value2, t) {
        return (t - value1) / (value2 - value1);
    }
    remap(value, min1, max1, min2, max2) {
        return min2 + (max2 - min2) * (value - min1) / (max1 - min1);
    }
    moveTowards(value1, value2, amount) {
        value1 += amount;
        if (amount < 0 && value1 < value2)
            value1 = value2;
        else if (amount > 0 && value1 > value2)
            value1 = value2;
        return value1;
    }
    toDegrees(radians) {
        return radians * 180 / Math.PI;
    }
    toRadians(degrees) {
        return degrees * Math.PI / 180;
    }
    gammaToLinear(gamma) {
        return Math.pow(gamma, 2.2);
    }
    linearToGamma(linear) {
        return Math.pow(linear, 1 / 2.2);
    }
}
;
const Mathf = new MathHelper();
export { Mathf };
//# sourceMappingURL=engine_math.js.map