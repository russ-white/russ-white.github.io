import { Material, Texture, TextureLoader } from "three";
import { GLTF, GLTFLoader, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
import { SourceIdentifier } from "../engine_types";
import { Context } from "../engine_setup";
import { addDracoAndKTX2Loaders } from "../engine_loaders";
import { getParam, getPath } from "../engine_utils";

export const EXTENSION_NAME = "NEEDLE_progressive";

const debug = getParam("debugprogressive");

declare type ProgressiveTextureSchema = {
    uri: string;
    guid: string;
}

const debug_toggle_maps: Map<Material, { [key: string]: { original: Texture, lod0: Texture } }> = new Map();
let show_lod0 = false;
if (debug) {
    window.addEventListener("keyup", evt => {
        if (evt.key === "p") {
            debug_toggle_maps.forEach((map, material) => {
                Object.entries(map).forEach(([key, value]) => {
                    if (show_lod0) {
                        material[key] = value.lod0;
                    } else {
                        material[key] = value.original;
                    }
                    material.needsUpdate = true;
                });
            });
            show_lod0 = !show_lod0;
        }
    });
}

export class NEEDLE_progressive implements GLTFLoaderPlugin {

    static assignTextureLOD(context: Context, source: SourceIdentifier | undefined, material: Material, level: number = 0) {
        if (!material) return;
        for (let slot of Object.keys(material)) {
            const val = material[slot];
            if (val?.isTexture === true) {

                if (debug) console.log("-----------\n", "FIND", material.name, slot, val?.name, val?.userData, val, material);

                NEEDLE_progressive.getOrLoadTexture(context, source, material, slot, val, level).then(t => {
                    if (t?.isTexture === true) {

                        if (debug) console.log("Assign LOD", material.name, slot, t.name, t["guid"], material, "Prev:", val, "Now:", t, "\n--------------");

                        material[slot] = t;
                        t.needsUpdate = true;
                        material.needsUpdate = true;

                        if (debug) {
                            let debug_map = debug_toggle_maps.get(material);
                            if (!debug_map) {
                                debug_map = {};
                                debug_toggle_maps.set(material, debug_map);
                            }
                            let entry = debug_map[slot];
                            if (!entry) {
                                entry = debug_map[slot] = { original: val, lod0: t };
                            }
                            entry.lod0 = t;
                        }
                    }
                });
            }
        }
    }


    get name(): string {
        return EXTENSION_NAME;
    }

    private parser: GLTFParser;
    private sourceId: SourceIdentifier;
    private context: Context;

    constructor(parser: GLTFParser, sourceId: SourceIdentifier, context: Context) {
        this.parser = parser;
        this.sourceId = sourceId;
        this.context = context;
    }

    private _loading: number[] = [];

    // beforeRoot(): null {
    //     console.log("BEFORE ROOT", this.parser);
    //     return null;
    // }

    // loadTexture(index: number): Promise<Texture> | null {
    //     console.log(index, this._loading);
    //     if (this._loading.includes(index)) return null;
    //     const textureInfo = this.parser.json.textures[index];
    //     if (debug)
    //         console.log(index, textureInfo);
    //     return null;
    // }

    afterRoot(gltf: GLTF): null {
        if (debug)
            console.log("AFTER", this.sourceId, gltf);
        this.parser.json.textures?.forEach((textureInfo, index) => {
            if (textureInfo?.extensions) {
                const ext: ProgressiveTextureSchema = textureInfo?.extensions[EXTENSION_NAME];
                if (ext) {
                    const prom = this.parser.getDependency("texture", index);
                    this._loading.splice(this._loading.indexOf(index), 1);
                    prom.then(t => {
                        if (debug) console.log("register texture", t.name, t.uuid, ext);
                        t.userData.deferred = ext;
                        NEEDLE_progressive.cache.set(t.uuid, ext);
                    });
                }
            }
        });

        return null;
    }

    private static cache = new Map<string, ProgressiveTextureSchema>();
    private static resolved: { [key: string]: Texture } = {};

    private static async getOrLoadTexture(context: Context, source: SourceIdentifier | undefined, material: Material, slot: string, current: Texture, _level: number): Promise<Texture | null> {

        const key = current.uuid;
        const ext: ProgressiveTextureSchema | undefined = NEEDLE_progressive.cache.get(key);// || current.userData.deferred;
        if (ext) {
            if (debug)
                console.log(key, ext.uri, ext.guid);
            const uri = getPath(source, ext.uri);
            if (uri.endsWith(".glb") || uri.endsWith(".gltf")) {
                if (!ext.guid) {
                    console.warn("missing pointer for glb/gltf texture", ext);
                    return null;
                }
                const resolveKey = uri + "_" + ext.guid;
                if (this.resolved[resolveKey]) {
                    if (debug) console.log("Texture has already been loaded: " + resolveKey, material.name, slot, current.name);
                    return this.resolved[resolveKey];
                }

                const loader = new GLTFLoader();
                addDracoAndKTX2Loaders(loader, context);
                if (debug) console.log("Load " + uri, material.name, slot, ext.guid);
                const gltf = await loader.loadAsync(uri);
                const parser = gltf.parser;
                if (debug) console.log("Loading finished " + uri, material.name, slot, ext.guid);
                let index = -1;
                let found = false;
                for (const tex of gltf.parser.json.textures) {
                    index++;
                    if (tex?.extensions) {
                        const other: ProgressiveTextureSchema = tex?.extensions[EXTENSION_NAME];
                        if (other?.guid) {
                            if (other.guid === ext.guid) {
                                found = true;
                                break;
                                // if (debug)
                                //     console.log(material.name, slot, "change \"" + current.name + "\" → \"" + tex.name + "\"", uri, index, tex, material);
                                // this.resolved[resolveKey] = tex as Texture;
                                // return tex;
                            }
                        }
                    }
                }
                if (!found)
                    return null;

                // const index = Number.parseInt(ext.pointer.substring("textures/".length));
                const tex = await parser.getDependency("texture", index);
                tex.encoding = current.encoding;
                if (tex) {
                    tex.guid = ext.guid;
                }
                this.resolved[resolveKey] = tex as Texture;
                if (debug)
                    console.log(material.name, slot, "change \"" + current.name + "\" → \"" + tex.name + "\"", uri, index, tex, material, resolveKey);
                return tex;
            }
            else {
                if (debug) console.log("Load texture from uri: " + uri);
                const loader = new TextureLoader();
                const loaded = await loader.loadAsync(uri);
                if (loaded && debug) {
                    console.log(ext, loaded);
                }
                else console.warn("failed loading", uri);
                return loaded;
            }
            // loader.then((h: Texture) => {
            //     // console.log(t, h);
            //     // t.image = h.image;
            //     // // this.context.renderer.copyTextureToTexture(new Vector2(0, 0), h, t);
            //     // // console.log(h);

            //     // // t.source = h.source;
            //     // // t.version++;
            //     // t.width = h.width;
            //     // t.height = h.height;
            //     // t.needsUpdate = true;
            // });
        }
        else {
            if (debug)
                console.warn("unknown uuid", current.name, current.uuid, current);
        }
        return null;
    }
}