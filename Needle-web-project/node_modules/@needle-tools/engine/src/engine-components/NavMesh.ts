
// import { Behaviour, GameObject } from "./Component";
// /*
// import { Pathfinding, PathfindingHelper } from 'three-pathfinding';
// import * as THREE from 'three';
// import { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils'
// */
// export class NavMesh extends Behaviour {
// /*
//     public meshes: THREE.Object3D[] = [];

//     private pathfinding: Pathfinding | null = null;
//     private zones: string[] = [];

//     onEnable(): void {

//         this.pathfinding = new Pathfinding();
//         const ZONE = 'zone';
//         const geometries : THREE.BufferGeometry[] = [];
//         if (this.meshes && this.meshes.length > 0) {
//             for (let i = 0; i < this.meshes.length; i++) {
//                 const obj = this.meshes[i] as THREE.Mesh;
//                 if (!obj) continue;
//                 const geo = obj.geometry;
//                 if (!geo) continue;
//                 const copy : THREE.BufferGeometry = {...geo};
//                 // const copy = geo;
//                 const attributesCopy = {...copy.attributes};
//                 copy.attributes = attributesCopy;
//                 if(attributesCopy.uv2) delete attributesCopy.uv2;
//                 // copy.applyMatrix4(obj.matrixWorld);
//                 geometries.push(copy);
//                 // obj.updateMatrixWorld();
//                 // singleGeometry.merge(geo);
//                 // console.log(singleGeometry, geo);
//             }
//         }
//         const mesh = mergeBufferGeometries(geometries);
//         const zone = Pathfinding.createZone(mesh);
//         const name = ZONE;
//         this.zones.push(name);
//         this.pathfinding.setZoneData(name, zone);

//         // const target = new THREE.Vector3(2, 0, 2);
//         // const groupID = this.pathfinding.getGroup(ZONE, target);
//         // const path = this.pathfinding.findPath(this.worldPosition, target, ZONE, groupID);
//         // console.log(path, this.pathfinding);
//     }

//     public tryFindPath(from: THREE.Vector3, to: THREE.Vector3): THREE.Vector3[] | null {
//         const zone = this.zones[0];
//         const groupId = this.pathfinding.getGroup(zone, to);
//         const path = this.pathfinding.findPath(from, to, zone, groupId);
//         return path;
//     }
//     */
// }

// // import { input } from "../engine/engine_input";
// import { Physics, RaycastOptions } from "../engine/engine_physics"
// // import { time } from "../engine/engine_time";
// // import { scene } from "../engine/engine_setup";
// import {SyncedTransform} from "./SyncedTransform";

// export class NavMeshAgent extends Behaviour {
//     /*
//     public navMesh: NavMesh | null = null;

//     private currentPath: THREE.Vector3[] | null = null;
//     private helper : PathfindingHelper | null = null;

//     onEnable(): void {
//         this.helper = new PathfindingHelper();
//         scene.add(this.helper);
//     }

//     update(): void {
//         if (input.mouseClick) {
//             if (this.navMesh) {
//                 const from = this.worldPosition;
//                 const opts = new RaycastOptions();
//                 opts.setMask(RaycastOptions.AllLayers);
//                 const hits = Physics.raycast(opts);
//                 if (hits.length > 0) {
//                     const to = hits[0].point;
//                     this.helper.setPlayerPosition(from);
//                     this.helper.setTargetPosition(to);
//                     this.currentPath = this.navMesh.tryFindPath(from, to);
//                     this.helper.setPath(this.currentPath);
//                     // console.log(...this.currentPath);

//                     const sync = GameObject.getComponent(this.gameObject, SyncedTransform);
//                     if(sync) sync.requestOwnership();
//                 }
//             }
//         }

//         if (this.currentPath && this.currentPath.length > 0) {

//             const wp = this.worldPosition;
//             const target = this.currentPath[0];
//             this.worldPosition = wp.lerp(target, time.deltaTime*2);

//             this.gameObject.lookAt(target);
//             // const vec = target.clone().sub(wp);
//             // const wr = this.worldQuaternion;
//             // wr.slerp(rot, time.deltaTime*5);
//             // this.worldQuaternion = wr;

//             if (wp.distanceTo(this.currentPath[0]) < 0.1)
//                 this.currentPath.shift();

            
//         }
//     }
//     */
// }