/// <reference types="webxr" />
declare module "engine/engine_math" {
    class MathHelper {
        random(): number;
        clamp(value: number, min: number, max: number): number;
        clamp01(value: number): number;
        lerp(value1: number, value2: number, t: number): number;
        inverseLerp(value1: number, value2: number, t: number): number;
        remap(value: number, min1: number, max1: number, min2: number, max2: number): number;
        moveTowards(value1: number, value2: number, amount: number): number;
        toDegrees(radians: number): number;
        toRadians(degrees: number): number;
        gammaToLinear(gamma: number): number;
        linearToGamma(linear: number): number;
    }
    const Mathf: MathHelper;
    export { Mathf };
}
declare module "engine-components/js-extensions/RGBAColor" {
    import { Color } from "three";
    export class RGBAColor extends Color {
        alpha: number;
        get isRGBAColor(): boolean;
        constructor(r: number, g: number, b: number, a: number);
        clone(): this;
        copy(col: RGBAColor | Color): this;
        lerp(color: Color, alpha: number): this;
        lerpColors(color1: Color, color2: Color, alpha: number): this;
        multiply(color: Color): this;
    }
}
declare module "engine/engine_physics.types" {
    export enum CollisionDetectionMode {
        Discrete = 0,
        Continuous = 1
    }
    export enum RigidbodyConstraints {
        None = 0,
        FreezePositionX = 2,
        FreezePositionY = 4,
        FreezePositionZ = 8,
        FreezePosition = 14,
        FreezeRotationX = 16,
        FreezeRotationY = 32,
        FreezeRotationZ = 64,
        FreezeRotation = 112,
        FreezeAll = 126
    }
    export enum Axes {
        None = 0,
        X = 2,
        Y = 4,
        Z = 8,
        All = -1
    }
}
declare module "engine/engine_three_utils" {
    import * as THREE from "three";
    import { Vector3, Texture, ShaderMaterial } from "three";
    export function slerp(vec: Vector3, end: Vector3, t: number): THREE.Vector3;
    export function lookAtInverse(obj: THREE.Object3D, target: Vector3): void;
    export function getWorldPosition(obj: THREE.Object3D, vec?: THREE.Vector3 | null, updateParents?: boolean): THREE.Vector3;
    export function setWorldPosition(obj: THREE.Object3D, val: THREE.Vector3): void;
    export function setWorldPositionXYZ(obj: THREE.Object3D, x: number, y: number, z: number): void;
    export function getWorldQuaternion(obj: THREE.Object3D, target?: THREE.Quaternion | null): THREE.Quaternion;
    export function setWorldQuaternion(obj: THREE.Object3D, val: THREE.Quaternion): void;
    export function setWorldQuaternionXYZW(obj: THREE.Object3D, x: number, y: number, z: number, w: number): void;
    export function getWorldScale(obj: THREE.Object3D, vec?: THREE.Vector3 | null): THREE.Vector3;
    export function setWorldScale(obj: THREE.Object3D, vec: THREE.Vector3): void;
    export function forward(obj: THREE.Object3D): THREE.Vector3;
    export function getWorldEuler(obj: THREE.Object3D): THREE.Euler;
    export function setWorldEuler(obj: THREE.Object3D, val: THREE.Euler): void;
    export function getWorldRotation(obj: THREE.Object3D): THREE.Vector3;
    export function setWorldRotation(obj: THREE.Object3D, val: THREE.Vector3): void;
    export function setWorldRotationXYZ(obj: THREE.Object3D, x: number, y: number, z: number, degrees?: boolean): void;
    export function logHierarchy(root: THREE.Object3D | null | undefined, collapsible?: boolean): void;
    export function isAnimationAction(obj: object): boolean;
    export class Graphics {
        private static planeGeometry;
        private static renderer;
        private static perspectiveCam;
        private static scene;
        private static readonly vertex;
        private static readonly fragment;
        private static readonly blipMaterial;
        static createBlitMaterial(fragment: string): ShaderMaterial;
        private static readonly mesh;
        static copyTexture(texture: Texture, blitMaterial?: ShaderMaterial): THREE.Texture;
        static textureToCanvas(texture: Texture, force: boolean): HTMLCanvasElement | null;
    }
    /**@obsolete use Graphics.copyTexture */
    export function copyTexture(texture: THREE.Texture): THREE.Texture;
    /**@obsolete use Graphics.textureToCanvas */
    export function textureToCanvas(texture: THREE.Texture, force?: boolean): HTMLCanvasElement | null;
}
declare module "engine/engine_types" {
    import { Camera, Color, Material, Object3D, Vector3, Quaternion, Ray } from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { CollisionDetectionMode, RigidbodyConstraints } from "engine/engine_physics.types";
    /** used to find data registered via gltf files e.g. find lightmaps for a Renderer component that were shipped inside a gltf */
    export type SourceIdentifier = string;
    export type Constructor<T> = abstract new (...args: any[]) => T;
    export type ConstructorConcrete<T> = new (...args: any[]) => T;
    export type GuidsMap = {
        [key: string]: string;
    };
    export interface UIDProvider {
        seed: number;
        generateUUID(): string;
    }
    export interface INeedleEngineComponent extends HTMLElement {
        getAROverlayContainer(): HTMLElement;
        onEnterAR(session: XRSession, overlayContainer: HTMLElement): any;
        onExitAR(session: XRSession): any;
    }
    export interface IGameObject extends Object3D {
        guid: string | undefined;
        activeSelf: boolean;
        addNewComponent<T>(type: Constructor<T>): T | null;
        removeComponent(comp: IComponent): IComponent;
        getOrAddComponent<T>(typeName: Constructor<T> | null): T;
        getComponent<T>(type: Constructor<T>): T | null;
        getComponents<T>(type: Constructor<T>, arr?: T[]): Array<T>;
        getComponentInChildren<T>(type: Constructor<T>): T | null;
        getComponentsInChildren<T>(type: Constructor<T>, arr?: T[]): Array<T>;
        getComponentInParent<T>(type: Constructor<T>): T | null;
        getComponentsInParent<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    }
    export interface IComponent {
        get isComponent(): boolean;
        gameObject: IGameObject;
        guid: string;
        enabled: boolean;
        sourceId?: SourceIdentifier;
        get name(): string;
        get layer(): number;
        get destroyed(): boolean;
        get tag(): string;
        context: any;
        get activeAndEnabled(): boolean;
        __internalNewInstanceCreated(): any;
        __internalAwake(): any;
        __internalStart(): any;
        __internalEnable(): any;
        __internalDisable(): any;
        __internalDestroy(): any;
        resolveGuids?(guidsMap: GuidsMap): void;
        awake(): any;
        onEnable(): any;
        onDisable(): any;
        onDestroy(): any;
        destroy(): any;
        /** called for properties decorated with the @validate decorator */
        onValidate?(property?: string): any;
        /** called when this.context.isPaused changes or when rendering loop changes due to changing DOM element visibility
         * e.g. when the DOM element becomes hidden or out ot view
         */
        onPausedChanged?(isPaused: boolean, wasPaused: boolean): any;
        start?(): void;
        earlyUpdate?(): void;
        update?(): void;
        lateUpdate?(): void;
        onBeforeRender?(frame: XRFrame | null): void;
        onAfterRender?(): void;
        onCollisionEnter?(col: Collision): any;
        onCollisionExit?(col: Collision): any;
        onCollisionStay?(col: Collision): any;
        onTriggerEnter?(col: ICollider): any;
        onTriggerStay?(col: ICollider): any;
        onTriggerExit?(col: ICollider): any;
        get forward(): Vector3;
        get worldPosition(): Vector3;
        get worldQuaternion(): Quaternion;
    }
    export interface ICamera extends IComponent {
        get isCamera(): boolean;
        applyClearFlagsIfIsActiveCamera(): unknown;
        buildCamera(): any;
        get cam(): Camera;
        nearClipPlane: number;
        farClipPlane: number;
        backgroundColor: RGBAColor | null;
        clearFlags: number;
        aspect: number;
        fieldOfView: number;
        screenPointToRay(x: number, y: number, ray?: Ray): Ray;
    }
    export interface ILight extends IComponent {
        intensity: number;
        color: Color;
    }
    export interface ISharedMaterials {
        [num: number]: Material;
        get length(): number;
    }
    export interface IRenderer extends IComponent {
        sharedMaterial: Material;
        get sharedMaterials(): ISharedMaterials;
    }
    export interface ICollider extends IComponent {
        get isCollider(): any;
        attachedRigidbody: IRigidbody | null;
        isTrigger: boolean;
    }
    export interface IRigidbody extends IComponent {
        constraints: RigidbodyConstraints;
        isKinematic: boolean;
        mass: number;
        drag: number;
        angularDrag: number;
        useGravity: boolean;
        collisionDetectionMode: CollisionDetectionMode;
        lockPositionX: boolean;
        lockPositionY: boolean;
        lockPositionZ: boolean;
        lockRotationX: boolean;
        lockRotationY: boolean;
        lockRotationZ: boolean;
    }
    export const $physicsKey: unique symbol;
    export type ICollisionContext = {
        getCollider(obj: Object3D): ICollider;
    };
    export type Vec2 = {
        x: number;
        y: number;
    };
    export type Vec3 = {
        x: number;
        y: number;
        z: number;
    };
    export type Vec4 = {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    export class ContactPoint {
        private readonly _point;
        private readonly _normal;
        readonly distance: number;
        readonly impulse: number;
        readonly friction: number;
        /** worldspace point */
        get point(): Vector3;
        /** worldspace normal */
        get normal(): Vector3;
        constructor(point: Vec3, dist: number, normal: Vec3, impulse: number, friction: number);
    }
    export class Collision {
        readonly contacts: ContactPoint[];
        constructor(obj: Object3D, otherCollider: ICollider, contacts: ContactPoint[]);
        readonly me: Object3D;
        private _collider;
        /** the collider the collision happened with */
        get collider(): ICollider;
        /** the object the collision happened with */
        private _gameObject;
        get gameObject(): Object3D;
        /** the rigidbody we hit, null if none attached */
        get rigidBody(): IRigidbody | null;
    }
}
declare module "engine/engine_utils" {
    import { SourceIdentifier } from "engine/engine_types";
    export const nameofFactory: <T>() => (name: keyof T) => keyof T;
    export function nameof<T>(name: keyof T): keyof T;
    export function isDebugMode(): boolean;
    export class CircularBuffer<T> {
        private _factory;
        private _cache;
        private _maxSize;
        private _index;
        constructor(factory: () => T, maxSize: number);
        get(): T;
    }
    export function getUrlParams(): URLSearchParams;
    export function getParam(paramName: string): string | boolean;
    export function setParam(paramName: string, paramValue: string): void;
    export function setParamWithoutReload(paramName: string, paramValue: string, appendHistory?: boolean): void;
    export function setOrAddParamsToUrl(url: URLSearchParams, paramName: string, paramValue: string | number): void;
    export function pushState(title: string, urlParams: URLSearchParams): void;
    export function setState(title: string, urlParams: URLSearchParams): void;
    export function makeId(length: any): string;
    export function randomNumber(min: any, max: any): any;
    export function makeIdFromRandomWords(): string;
    export function sanitizeString(str: any): string;
    export function tryFindObject(globalObjectIdentifier: string, obj: any, recursive?: boolean, searchComponents?: boolean): any;
    type deepClonePredicate = (owner: any, propertyName: string, current: any) => boolean;
    export function deepClone(obj: any, predicate?: deepClonePredicate): any;
    export function delay(milliseconds: number): Promise<void>;
    export function getPath(source: SourceIdentifier | undefined, uri: string): string;
    export type WriteCallback = (data: any, prop: string) => void;
    export interface IWatch {
        subscribeWrite(callback: WriteCallback): any;
        apply(): any;
        revoke(): any;
        dispose(): any;
    }
    export class Watch implements IWatch {
        private readonly _watches;
        constructor(object: object, str: string[] | string);
        subscribeWrite(callback: WriteCallback): void;
        apply(): void;
        revoke(): void;
        dispose(): void;
    }
    export function isMobileDevice(): boolean;
    export function isMozillaXR(): boolean;
    export function isiOS(): boolean;
    export function isSafari(): boolean;
}
declare module "engine/engine_networking_utils" {
    export function isLocalNetwork(hostname?: string): boolean;
    export function isHostedOnGlitch(): boolean;
}
declare module "engine/debug/debug_console" {
    export function showDebugConsole(): void;
    export function hideDebugConsole(): void;
}
declare module "engine/debug/debug" {
    import { LogType } from "engine/debug/debug_overlay";
    import { showDebugConsole } from "engine/debug/debug_console";
    export { showDebugConsole };
    export { LogType };
    export function showBalloonMessage(text: string, logType?: LogType): void;
    export function showBalloonWarning(text: string): void;
}
declare module "engine/extensions/extension_resolver" {
    import { GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    export interface IExtensionReferenceResolver {
        resolve(parser: GLTFParser, path: string): Promise<void> | null;
    }
}
declare module "engine/engine_default_parameters" {
    export const showGizmos: string | boolean;
    export const debugExtension: string | boolean;
}
declare module "engine/extensions/extension_utils" {
    import { GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    export function resolveReferences(parser: GLTFParser, obj: any): Promise<void | void[]>;
}
declare module "engine/engine_typestore" {
    class _TypeStore {
        private _types;
        add(key: any, type: any): void;
        get(key: any): any;
    }
    export const $BuiltInTypeFlag: unique symbol;
    export const TypeStore: _TypeStore;
}
declare module "engine/extensions/NEEDLE_persistent_assets" {
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { IExtensionReferenceResolver } from "engine/extensions/extension_resolver";
    export const EXTENSION_NAME = "NEEDLE_persistent_assets";
    export function isPersistentAsset(asset: any): boolean;
    export class NEEDLE_persistent_assets implements GLTFLoaderPlugin, IExtensionReferenceResolver {
        get name(): string;
        private parser;
        constructor(parser: GLTFParser);
        afterRoot(_result: GLTF): Promise<void>;
        resolve(parser: GLTFParser, path: string): Promise<void> | null | any;
    }
}
declare module "engine/engine_serialization_core" {
    import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
    import { Object3D } from "three";
    import { Context } from "engine/engine_setup";
    import { SourceIdentifier } from "engine/engine_types";
    export type Constructor<T> = {
        new (...args: any[]): T;
    };
    export type NodeToObjectMap = {
        [nodeId: string]: Object3D;
    };
    export type ObjectToNodeMap = {
        [uuid: string]: number;
    };
    class SerializationHelper {
        register(type: string, ser: ITypeSerializer): void;
        typeMap: {
            [type: string]: ITypeSerializer;
        };
        getSerializer(type: string): ITypeSerializer | undefined;
        getSerializerForConstructor(type: any, level?: number): ITypeSerializer | undefined;
    }
    export const helper: SerializationHelper;
    export interface ITypeSerializer {
        onSerialize(data: any, context: SerializationContext): any;
        onDeserialize(data: any, context: SerializationContext): any;
    }
    /**
     * implement and call super(<type string or array>) with the type names this serializer can handle
     * for example:
     * class ColorSerializer extends TypeSerializer {
     *  constructor() {
     *      super("Color")
     *  }
     * }
    */
    export abstract class TypeSerializer implements ITypeSerializer {
        constructor(type: Constructor<any> | Constructor<any>[]);
        abstract onSerialize(data: any, context: SerializationContext): any | void;
        abstract onDeserialize(data: any, context: SerializationContext): any | void;
    }
    export interface ITypeInformation {
        type?: Constructor<any>;
    }
    /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
    export class ImplementationInformation {
        private isDevMode;
        private cache;
        /** only call when assigning values for the very first time */
        registerDefinedKeys(typeName: string, type: object): void;
        getDefinedKey(typeName: string, key: string): boolean;
    }
    export class SerializationContext {
        root: THREE.Object3D;
        gltf?: GLTF;
        gltfId?: SourceIdentifier;
        object: THREE.Object3D;
        target?: object;
        nodeId?: number;
        nodeToObject?: NodeToObjectMap;
        objectToNode?: ObjectToNodeMap;
        context?: Context;
        path?: string;
        type?: Constructor<any>;
        /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
        implementationInformation?: ImplementationInformation;
        constructor(root: THREE.Object3D);
    }
    export interface ISerializable {
        $serializedTypes?: {
            [key: string]: Constructor<any> | ITypeInformation | null;
        };
        onBeforeDeserialize?(data: any, context: SerializationContext): void | undefined | boolean;
        onBeforeDeserializeMember?(key: string, data: any, context: SerializationContext): void | undefined | boolean;
        onAfterDeserializeMember?(key: string, data: any, context: SerializationContext): void;
        onAfterDeserialize?(data: any, context: SerializationContext): void;
    }
    export function serializeObject(obj: ISerializable, context: SerializationContext): object | null;
    export function deserializeObject(obj: ISerializable, serializedData: object, context: SerializationContext): boolean;
    /** set to true while assigning properties during instantiation.
     * Used for validate decorator to not invoke callbacks on components that are currently in the process of being built */
    export const $isAssigningProperties: unique symbol;
    /** Object.assign behaviour but check if property is writeable (e.g. getter only properties are skipped) */
    export function assign(target: any, source: any, info?: ImplementationInformation): void;
}
declare module "engine/engine_input" {
    import * as THREE from 'three';
    import { Context } from "engine/engine_setup";
    import { Vec2 } from "engine/engine_types";
    export type PointerEventArgs = {
        pointerType: string;
        button: number;
        clientX: number;
        clientY: number;
        movementX?: number;
        movementY?: number;
        source?: Event;
    };
    export class KeyEventArgs {
        key: string;
        keyType: string;
        source?: Event;
        constructor(evt: KeyboardEvent);
    }
    export enum InputEvents {
        PointerDown = "pointerdown",
        PointerUp = "pointerup",
        PointerMove = "pointermove",
        KeyDown = "keydown",
        KeyUp = "keyup",
        KeyPressed = "keypress"
    }
    export enum PointerType {
        Mouse = "mouse",
        Touch = "touch"
    }
    export class Input extends EventTarget {
        _doubleClickTimeThreshold: number;
        _longPressTimeThreshold: number;
        get mousePosition(): THREE.Vector2;
        get mousePositionRC(): THREE.Vector2;
        get mouseDown(): boolean;
        get mouseUp(): boolean;
        get mouseClick(): boolean;
        get mouseDoubleClick(): boolean;
        get mousePressed(): boolean;
        get mouseWheelChanged(): boolean;
        private _specialCursorTrigger;
        setCursorPointer(): void;
        setCursorNormal(): void;
        getPointerPressedCount(): number;
        getPointerPosition(i: number): THREE.Vector2 | null;
        getPointerPositionLastFrame(i: number): THREE.Vector2 | null;
        getPointerPositionDelta(i: number): THREE.Vector2 | null;
        getPointerPositionRC(i: number): THREE.Vector2 | null;
        getPointerDown(i: number): boolean;
        getPointerUp(i: number): boolean;
        getPointerPressed(i: number): boolean;
        getPointerClicked(i: number): boolean;
        getPointerDoubleClicked(i: number): boolean;
        getPointerDownTime(i: number): number;
        getPointerUpTime(i: number): number;
        getPointerLongPress(i: number): boolean;
        getIsMouse(i: number): boolean;
        getIsTouch(i: number): boolean;
        getTouchesPressedCount(): number;
        getMouseWheelChanged(i?: number): boolean;
        getMouseWheelDeltaY(i?: number): number;
        getPointerEvent(i: number): Event | undefined;
        foreachPointerId(pointerType?: string | PointerType | string[] | PointerType[]): Generator<number>;
        foreachTouchId(): Generator<number>;
        private _pointerIsActive;
        private context;
        private _pointerDown;
        private _pointerUp;
        private _pointerClick;
        private _pointerDoubleClick;
        private _pointerPressed;
        private _pointerPositions;
        private _pointerPositionsLastFrame;
        private _pointerPositionsDelta;
        private _pointerPositionsRC;
        private _pointerPositionDown;
        private _pointerDownTime;
        private _pointerUpTime;
        private _pointerIds;
        private _pointerTypes;
        private _mouseWheelChanged;
        private _mouseWheelDeltaY;
        private _pointerEvent;
        getKeyDown(): string | null;
        getKeyPressed(): string | null;
        isKeyDown(keyCode: KeyCode | string | number): any;
        isKeyUp(keyCode: KeyCode | string | number): boolean;
        isKeyPressed(keyCode: KeyCode | string | number): any;
        createPointerDown(args: PointerEventArgs): void;
        createPointerMove(args: PointerEventArgs): void;
        createPointerUp(args: PointerEventArgs): void;
        convertScreenspaceToRaycastSpace(vec2: Vec2): void;
        constructor(context: Context);
        private onLostFocus;
        private onEndOfFrame;
        private keysPressed;
        private onKeyDown;
        private onKeyPressed;
        private onKeyUp;
        private onMouseWheel;
        private onTouchStart;
        private onTouchMove;
        private onTouchUp;
        private onMouseDown;
        private onMouseMove;
        private onMouseUp;
        private isInRect;
        private onDown;
        private onMove;
        private onUp;
        private updatePointerPosition;
        /** get the next free id */
        private getPointerIndex;
        private setPointerState;
        private setPointerStateT;
        private onDispatchEvent;
    }
    export enum KeyCode {
        BACKSPACE = "Backspace",
        TAB = "Tab",
        ENTER = "Enter",
        SHIFT = "Shift",
        CTRL = "Control",
        ALT = "Alt",
        PAUSE = "Pause",
        CAPS_LOCK = "CapsLock",
        ESCAPE = "Escape",
        SPACE = " ",
        PAGE_UP = "PageUp",
        PAGE_DOWN = "PageDown",
        END = "End",
        HOME = "Home",
        LEFT_ARROW = "ArrowLeft",
        UP_ARROW = "ArrowUp",
        RIGHT_ARROW = "ArrowRight",
        DOWN_ARROW = "ArrowDown",
        INSERT = "Insert",
        DELETE = "Delete",
        KEY_0 = "0",
        KEY_1 = "1",
        KEY_2 = "2",
        KEY_3 = "3",
        KEY_4 = "4",
        KEY_5 = "5",
        KEY_6 = "6",
        KEY_7 = "7",
        KEY_8 = "8",
        KEY_9 = "9",
        KEY_A = "a",
        KEY_B = "b",
        KEY_C = "c",
        KEY_D = "d",
        KEY_E = "e",
        KEY_F = "f",
        KEY_G = "g",
        KEY_H = "h",
        KEY_I = "i",
        KEY_K = "k",
        KEY_J = "j",
        KEY_L = "l",
        KEY_M = "m",
        KEY_N = "n",
        KEY_O = "o",
        KEY_P = "p",
        KEY_Q = "q",
        KEY_R = "r",
        KEY_S = "s",
        KEY_T = "t",
        KEY_U = "u",
        KEY_V = "v",
        KEY_W = "w",
        KEY_X = "x",
        KEY_Z = "z",
        KEY_Y = "y",
        SELECT = "Select",
        NUMPAD_0 = "Numpad0",
        NUMPAD_1 = "Numpad1",
        NUMPAD_2 = "Numpad2",
        NUMPAD_3 = "Numpad3",
        NUMPAD_4 = "Numpad4",
        NUMPAD_5 = "Numpad5",
        NUMPAD_6 = "Numpad6",
        NUMPAD_7 = "Numpad7",
        NUMPAD_8 = "Numpad8",
        NUMPAD_9 = "Numpad9",
        MULTIPLY = "Multiply",
        ADD = "Add",
        SUBTRACT = "Subtract",
        DECIMAL = "Decimal",
        DIVIDE = "Divide",
        F1 = "F1",
        F2 = "F2",
        F3 = "F3",
        F4 = "F4",
        F5 = "F5",
        F6 = "F6",
        F7 = "F7",
        F8 = "F8",
        F9 = "F9",
        F10 = "F10",
        F11 = "F11",
        F12 = "F12"
    }
}
declare module "engine/engine_instancing" {
    export const NEED_UPDATE_INSTANCE_KEY: unique symbol;
    export class InstancingUtil {
        static isUsingInstancing(instance: THREE.Object3D): boolean;
        static markDirty(go: THREE.Object3D | null, recursive?: boolean): void;
    }
}
declare module "engine/engine_constants" {
    export const activeInHierarchyFieldName = "__isActiveInHierarchy";
    export const builtinComponentKeyName = "builtin_components";
}
declare module "engine/engine_mainloop_utils" {
    import { Context } from "engine/engine_setup";
    import { Object3D } from 'three';
    import { IComponent } from "engine/engine_types";
    export function processNewScripts(context: Context): void;
    export function processRemoveFromScene(script: IComponent): void;
    export function processStart(context: Context, object?: Object3D): void;
    export function addScriptToArrays(script: any, context: Context): void;
    export function removeScriptFromContext(script: any, context: Context): void;
    export function updateIsActive(obj?: Object3D): void;
    export function updateActiveInHierarchyWithoutEventCall(go: THREE.Object3D): void;
}
declare module "engine/engine_networking_types" {
    export interface IModel {
        guid: string;
        dontSave?: boolean;
    }
    export enum SendQueue {
        OnConnection = 0,
        OnRoomJoin = 1,
        Queued = 2,
        Immediate = 3
    }
    export interface INetworkConnection {
        get isConnected(): boolean;
        send(key: string, data: IModel | object | boolean | null | string | number, queue: SendQueue): unknown;
    }
}
declare module "engine/engine_networking_instantiate" {
    import { Context } from "engine/engine_setup";
    import { INetworkConnection } from "engine/engine_networking_types";
    import { IGameObject as GameObject, IComponent as Component } from "engine/engine_types";
    import { UIDProvider } from "engine/engine_types";
    import { Object3D } from "three";
    import { InstantiateOptions } from "engine/engine_gameobject";
    export class InstantiateIdProvider implements UIDProvider {
        get seed(): number;
        set seed(val: number);
        private _originalSeed;
        private _seed;
        constructor(seed: string | number);
        reset(): void;
        generateUUID(str?: string): any;
        initialize(strOrNumber: string | number): void;
        static createFromString(str: string): InstantiateIdProvider;
        private static hash;
    }
    export enum InstantiateEvent {
        NewInstanceCreated = "new-instance-created",
        InstanceDestroyed = "instance-destroyed"
    }
    export interface IBeforeNetworkedDestroy {
        onBeforeNetworkedDestroy(networkIds: string[]): void;
    }
    export function syncDestroy(obj: GameObject | Component, con: INetworkConnection, recursive?: boolean): void;
    export function sendDestroyed(guid: string, con: INetworkConnection): void;
    export function beginListenDestroy(context: Context): void;
    export class HostData {
        filename: string;
        hash: string;
        size: number;
        constructor(filename: string, hash: string, size: number);
    }
    export function syncInstantiate(object: GameObject | Object3D, opts: InstantiateOptions, hostData?: HostData, save?: boolean): GameObject | null;
    export function generateSeed(): number;
    export function beginListenInstantiate(context: Context): void;
    export type PrefabProviderCallback = (guid: string) => Promise<GameObject | null>;
    export function registerPrefabProvider(key: string, fn: PrefabProviderCallback): void;
}
declare module "engine-components/js-extensions/ExtensionUtils" {
    import { Constructor } from "engine/engine_types";
    export function applyPrototypeExtensions<T>(obj: any, prototype: Constructor<T>): void;
    export function registerPrototypeExtensions<T>(type: Constructor<T>): void;
    export interface IApplyPrototypeExtension {
        apply(object: object): void;
    }
}
declare module "engine/engine_components" {
    import { Object3D, Scene } from "three";
    import { Constructor, ConstructorConcrete, IComponent } from "engine/engine_types";
    export function removeComponent(go: Object3D, componentInstance: IComponent): void;
    export function getOrAddComponent<T extends IComponent>(go: Object3D, typeName: ConstructorConcrete<T>): T;
    export function addNewComponent<T extends IComponent>(obj: Object3D, componentInstance: T, callAwake?: boolean): IComponent;
    export function moveComponentInstance(obj: Object3D, componentInstance: IComponent): void;
    export function destroyComponentInstance(componentInstance: IComponent): void;
    export function getComponent<T>(obj: Object3D, componentType: Constructor<T>): any;
    export function getComponents<T>(obj: Object3D, componentType: Constructor<T>, arr?: T[] | null): T[];
    export function getComponentInChildren<T>(obj: Object3D, componentType: Constructor<T>, includeInactive?: boolean): any;
    export function getComponentsInChildren<T>(obj: Object3D, componentType: Constructor<T>, arr?: T[]): T[];
    export function getComponentInParent<T>(obj: Object3D, componentType: Constructor<T>): any;
    export function getComponentsInParent<T>(obj: Object3D, componentType: Constructor<T>, arr?: T[] | null): T[];
    export function findObjectOfType<T>(type: Constructor<T>, contextOrScene: Object3D | {
        scene: Scene;
    }, includeInactive: any): any;
    export function findObjectsOfType<T>(type: Constructor<T>, array: T[], contextOrScene: any): T[];
}
declare module "engine-components/js-extensions/Object3D" {
    import { Object3D } from "three";
    export function apply(object: Object3D): void;
}
declare module "engine/engine_gameobject" {
    import { Object3D } from "three";
    import { Context } from "engine/engine_setup";
    import { IComponent as Component, IComponent, IGameObject as GameObject, UIDProvider } from "engine/engine_types";
    export enum HideFlags {
        None = 0,
        HideInHierarchy = 1,
        HideInInspector = 2,
        DontSaveInEditor = 4,
        NotEditable = 8,
        DontSaveInBuild = 16,
        DontUnloadUnusedAsset = 32,
        DontSave = 52,
        HideAndDontSave = 61
    }
    export class InstantiateOptions {
        idProvider?: UIDProvider | undefined;
        parent?: string | undefined | Object3D;
        /** for duplicatable parenting */
        keepWorldPosition?: boolean;
        position?: THREE.Vector3 | undefined;
        rotation?: THREE.Quaternion | undefined;
        scale?: THREE.Vector3 | undefined;
        visible?: boolean | undefined;
        context?: Context | undefined;
    }
    export function isActiveSelf(go: Object3D): boolean;
    export function setActive(go: Object3D, active: boolean | number, setVisible?: boolean): boolean;
    export function isActiveInHierarchy(go: Object3D): boolean;
    export function markAsInstancedRendered(go: THREE.Object3D, instanced: boolean): void;
    export function isUsingInstancing(instance: THREE.Object3D): boolean;
    export function findByGuid(guid: string, hierarchy: THREE.Object3D): GameObject | IComponent | null | undefined;
    export function destroy(instance: Object3D | Component, recursive?: boolean, isRoot?: boolean): void;
    export function foreachComponent(instance: THREE.Object3D, cb: (comp: Component) => any, recursive?: boolean): any;
    export function instantiate(instance: GameObject | Object3D | null, opts?: InstantiateOptions | null): GameObject | null;
}
declare module "engine/engine_gizmos" {
    import * as THREE from 'three';
    import { ColorRepresentation, Box3 } from 'three';
    import { Vec3, Vec4 } from "engine/engine_types";
    export class Gizmos {
        static DrawRay(origin: Vec3, dir: Vec3, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
        static DrawDirection(pt: Vec3, direction: Vec3 | Vec4, color?: ColorRepresentation, duration?: number, depthTest?: boolean, lengthFactor?: number): void;
        static DrawLine(pt0: Vec3, pt1: Vec3, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
        static DrawWireSphere(center: Vec3, radius: number, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
        static DrawSphere(center: Vec3, radius: number, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
        static DrawBox(center: Vec3, size: Vec3, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
        static DrawBox3(box: Box3, color?: ColorRepresentation, duration?: number, depthTest?: boolean): void;
    }
    export function CreateWireCube(col?: THREE.ColorRepresentation | null): THREE.LineSegments;
}
declare module "engine/engine_physics" {
    import { Camera, Intersection, Layers, Mesh, Object3D, Ray, Raycaster, Vector2, Vector3 } from 'three';
    import { Context } from "engine/engine_setup";
    import { IComponent, ICollider, IRigidbody, Vec3, Vec2 } from "engine/engine_types";
    import RAPIER, { RigidBody } from '@dimforge/rapier3d-compat';
    export type Rapier = typeof RAPIER;
    export class RaycastOptions {
        ray: Ray | undefined;
        cam: Camera | undefined | null;
        screenPoint: Vector2 | undefined;
        raycaster: Raycaster | undefined;
        results: Array<Intersection> | undefined;
        targets: Array<Object3D> | undefined;
        recursive: boolean | undefined;
        minDistance: number | undefined;
        maxDistance: number | undefined;
        lineThreshold: number | undefined;
        layerMask: Layers | number | undefined;
        ignore: Object3D[] | undefined;
        screenPointFromOffset(ox: number, oy: number): void;
        setMask(mask: number): void;
        static AllLayers: number;
    }
    export class SphereIntersection implements Intersection {
        distance: number;
        point: Vector3;
        object: Object3D;
        constructor(object: Object3D, distance: number, point: Vector3);
    }
    export class Physics {
        private readonly raycaster;
        private readonly defaultRaycastOptions;
        private readonly targetBuffer;
        private readonly defaultThresholds;
        private sphereResults;
        private sphereMask;
        sphereOverlap(spherePos: Vector3, radius: number, traverseChildsAfterHit?: boolean): Array<Intersection>;
        private tempBoundingBox;
        private onSphereOverlap;
        raycastFromRay(ray: Ray, options?: RaycastOptions | null): Array<Intersection>;
        /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
         * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
         * Raycasting SkinnedMeshes is specially expensive.
         */
        raycast(options?: RaycastOptions | null): Array<Intersection>;
        private rapierRay;
        private raycastVectorsBuffer;
        /** raycast against colliders */
        raycastPhysicsFast(origin: Vec2 | Vec3, direction?: Vec3 | undefined, maxDistance?: number, solid?: boolean): null | {
            point: Vector3;
            collider: ICollider;
        };
        private getPhysicsRay;
        private _tempPosition;
        private _tempQuaternion;
        private _tempScale;
        private _tempMatrix;
        private static _didLoadPhysicsEngine;
        private _isUpdatingPhysicsWorld;
        get isUpdating(): boolean;
        private context;
        private world?;
        private _hasCreatedWorld;
        private eventQueue?;
        private collisionHandler?;
        private objects;
        private bodies;
        private _meshCache;
        constructor(context: Context);
        createWorld(): Promise<void>;
        clearCaches(): void;
        addBoxCollider(collider: ICollider, center: Vector3, size: Vector3): void;
        addSphereCollider(collider: ICollider, center: Vector3, radius: number): void;
        addCapsuleCollider(collider: ICollider, center: Vector3, height: number, radius: number): void;
        addMeshCollider(collider: ICollider, mesh: Mesh, convex: boolean, scale: Vector3): void;
        private createCollider;
        private getRigidbody;
        removeBody(obj: IComponent): void;
        updateBody(comp: ICollider | IRigidbody, translation: boolean, rotation: boolean): void;
        updateProperties(rigidbody: IRigidbody): void;
        internal_getRigidbody(rb: IRigidbody): RigidBody | null;
        private internalUpdateProperties;
        private lines?;
        step(_deltaTime?: number): void;
        private updateDebugRendering;
        postStep(): void;
        /** sync rendered objects with physics world (except for colliders without rigidbody) */
        private syncObjects;
        private syncPhysicsBody;
        private static _matricesBuffer;
        private getRigidbodyRelativeMatrix;
        private static centerConnectionPos;
        private static centerConnectionRot;
        addFixedJoint(body1: IRigidbody, body2: IRigidbody): void;
        addHingeJoint(body1: IRigidbody, body2: IRigidbody, anchor: {
            x: number;
            y: number;
            z: number;
        }, axis: {
            x: number;
            y: number;
            z: number;
        }): void;
        private calculateJointRelativeMatrices;
    }
}
declare module "engine/engine_time" {
    export class Time {
        deltaTime: number;
        time: number;
        /** same as frameCount */
        frame: number;
        get realtimeSinceStartup(): number;
        get frameCount(): number;
        get smoothedFps(): number;
        private clock;
        private _smoothedFps;
        private _fpsSamples;
        private _fpsSampleIndex;
        update(): void;
    }
}
declare module "engine-schemes/vec3" {
    import * as flatbuffers from 'flatbuffers';
    export class Vec3 {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): Vec3;
        x(): number;
        y(): number;
        z(): number;
        static sizeOf(): number;
        static createVec3(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset;
    }
}
declare module "engine-schemes/transform" {
    import * as flatbuffers from 'flatbuffers';
    import { Vec3 } from "engine-schemes/vec3";
    export class Transform {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): Transform;
        position(obj?: Vec3): Vec3 | null;
        rotation(obj?: Vec3): Vec3 | null;
        scale(obj?: Vec3): Vec3 | null;
        static sizeOf(): number;
        static createTransform(builder: flatbuffers.Builder, position_x: number, position_y: number, position_z: number, rotation_x: number, rotation_y: number, rotation_z: number, scale_x: number, scale_y: number, scale_z: number): flatbuffers.Offset;
    }
}
declare module "engine-schemes/synced-transform-model" {
    import * as flatbuffers from 'flatbuffers';
    import { Transform } from "engine-schemes/transform";
    export class SyncedTransformModel {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): SyncedTransformModel;
        static getRootAsSyncedTransformModel(bb: flatbuffers.ByteBuffer, obj?: SyncedTransformModel): SyncedTransformModel;
        static getSizePrefixedRootAsSyncedTransformModel(bb: flatbuffers.ByteBuffer, obj?: SyncedTransformModel): SyncedTransformModel;
        /**
         * the guid of the object that this transform info belongs to
         */
        guid(): string | null;
        guid(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
        /**
         * if the transform interpolation should be fast, this is true when the send interval is low and we want to have snappy transforms
         */
        fast(): boolean;
        transform(obj?: Transform): Transform | null;
        /**
         * if the server should not save this info
         */
        dontSave(): boolean;
        static startSyncedTransformModel(builder: flatbuffers.Builder): void;
        static addGuid(builder: flatbuffers.Builder, guidOffset: flatbuffers.Offset): void;
        static addFast(builder: flatbuffers.Builder, fast: boolean): void;
        static addTransform(builder: flatbuffers.Builder, transformOffset: flatbuffers.Offset): void;
        static addDontSave(builder: flatbuffers.Builder, dontSave: boolean): void;
        static endSyncedTransformModel(builder: flatbuffers.Builder): flatbuffers.Offset;
        static finishSyncedTransformModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
        static finishSizePrefixedSyncedTransformModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
    }
}
declare module "engine-schemes/schemes" {
    import * as flatbuffers from "flatbuffers";
    export function registerType(identifier: string, cast: (bin: flatbuffers.ByteBuffer) => object): void;
    export function tryCast(bin: flatbuffers.ByteBuffer): object;
    export function tryGetGuid(obj: any): string | undefined | null;
}
declare module "engine/engine_networking_peer" {
    export class PeerNetworking {
        get isHost(): boolean;
        private _host?;
        private _client;
        private _clientData?;
        constructor();
        onEnable(): void;
        private trySetupHost;
        private trySetupClient;
    }
}
declare module "engine/engine_networking" {
    import { Context } from "engine/engine_setup";
    import * as flatbuffers from 'flatbuffers';
    import { PeerNetworking } from "engine/engine_networking_peer";
    import { IModel, INetworkConnection, SendQueue } from "engine/engine_networking_types";
    export const debugNet: boolean;
    export const debugOwner: boolean;
    export interface INetworkingWebsocketUrlProvider {
        getWebsocketUrl(): string | null;
    }
    export interface IConnectionData {
        id: string;
    }
    export enum ConnectionEvents {
        ConnectionInfo = "connection-start-info"
    }
    export enum RoomEvents {
        Join = "join-room",
        Leave = "leave-room",
        JoinedRoom = "joined-room",
        LeftRoom = "left-room",
        UserJoinedRoom = "user-joined-room",
        UserLeftRoom = "user-left-room"
    }
    export class JoinedRoomResponse {
        room: string;
        viewId: string;
        allowEditing: boolean;
        inRoom: string[];
    }
    export class LeftRoomResponse {
        room: string;
    }
    export class UserJoinedOrLeftRoomModel {
        userId: string;
    }
    export enum OwnershipEvent {
        RequestHasOwner = "request-has-owner",
        ResponseHasOwner = "response-has-owner",
        RequestIsOwner = "request-is-owner",
        ResponseIsOwner = "response-is-owner",
        RequestOwnership = "request-ownership",
        GainedOwnership = "gained-ownership",
        RemoveOwnership = "remove-ownership",
        LostOwnership = "lost-ownership",
        GainedOwnershipBroadcast = "gained-ownership-broadcast",
        LostOwnershipBroadcast = "lost-ownership-broadcast"
    }
    export class OwnershipModel {
        guid: string;
        private connection;
        get hasOwnership(): boolean;
        get isOwned(): boolean | undefined;
        get isConnected(): boolean;
        private _hasOwnership;
        private _isOwned;
        private _gainSubscription;
        private _lostSubscription;
        private _hasOwnerResponse;
        constructor(connection: NetworkConnection, guid: string);
        private _isWaitingForOwnershipResponseCallback;
        updateIsOwned(): void;
        private onHasOwnerResponse;
        requestOwnershipIfNotOwned(): OwnershipModel;
        private waitForHasOwnershipRequestResponse;
        requestOwnershipAsync(): Promise<OwnershipModel>;
        requestOwnership(): OwnershipModel;
        freeOwnership(): OwnershipModel;
        destroy(): void;
        private onGainedOwnership;
        private onLostOwnership;
    }
    export type BinaryCallback = {
        (data: any | flatbuffers.ByteBuffer): void;
    };
    export class NetworkConnection implements INetworkConnection {
        private context;
        private _peer;
        constructor(context: Context);
        get peer(): PeerNetworking;
        tryGetState(guid: string): IModel | null;
        get connectionId(): string | null;
        get isDebugEnabled(): boolean;
        get isConnected(): boolean;
        get currentRoomName(): string | null;
        get allowEditing(): boolean;
        get currentRoomViewId(): string | null;
        get isInRoom(): boolean;
        get currentLatency(): number;
        userIsInRoom(id: string): boolean;
        private _usersInRoomCopy;
        usersInRoom(target?: string[] | null): string[];
        joinRoom(room: string, viewOnly?: boolean): void;
        leaveRoom(room?: string | null): void;
        send(key: string | OwnershipEvent, data?: IModel | object | boolean | null | string | number, queue?: SendQueue): void;
        sendDeleteRemoteState(guid: string): void;
        sendDeleteRemoteStateAll(): void;
        sendBinary(bin: Uint8Array): void;
        private _defaultMessagesBuffer;
        private _defaultMessagesBufferArray;
        sendBufferedMessagesNow(): void;
        beginListen(key: string | OwnershipEvent, callback: Function): Function;
        stopListening(key: string | OwnershipEvent, callback: Function | null): void;
        beginListenBinrary(identifier: string, callback: BinaryCallback): BinaryCallback;
        stopListenBinary(identifier: string, callback: any): void;
        private netWebSocketUrlProvider?;
        registerProvider(prov: INetworkingWebsocketUrlProvider): void;
        connect(): void;
        private _listeners;
        private _listenersBinary;
        private connected;
        private channelId;
        private _connectionId;
        private _isConnectingToWebsocket;
        private _ws;
        private _waitingForSocket;
        private _isInRoom;
        private _currentRoomName;
        private _currentRoomViewId;
        private _currentRoomAllowEditing;
        private _currentInRoom;
        private _state;
        private _currentDelay;
        private connectWebsocket;
        private onMessage;
        private handleIncomingBinaryMessage;
        private handleIncomingStringMessage;
        private toMessage;
        private sendWithWebsocket;
        private onSendQueued;
    }
}
declare module "engine/engine_web_api" {
    export class Upload_Result {
        success: boolean;
        filename: string | null;
        hash: string | null;
        size: number | null;
        url?: string | null;
        constructor(success: boolean, filename: string | null, hash: string | null, size: number | null);
    }
    export function upload_file(file: File, url: string): Promise<Upload_Result | null>;
    export function hash(buffer: ArrayBuffer): string;
    export function download_file(filename: string, expectedHash: string, expectedSize: number, serverUrl: string, skipChecks?: boolean): Promise<ArrayBuffer | null>;
    export function download(url: string, progressCallback: (prog: ProgressEvent) => void): Promise<Uint8Array | null>;
}
declare module "engine/engine_networking_files_default_components" {
    import { UIDProvider } from "engine/engine_types";
    import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
    export function onDynamicObjectAdded(_obj: THREE.Object3D, _idProv: UIDProvider, _gltf?: GLTF): void;
}
declare module "engine/extensions/NEEDLE_components" {
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { NodeToObjectMap, ObjectToNodeMap, SerializationContext } from "engine/engine_serialization_core";
    import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';
    export const debug: string | boolean;
    export const EXTENSION_NAME = "NEEDLE_components";
    class ExportData {
        node: THREE.Object3D;
        nodeIndex: number;
        nodeDef: any;
        constructor(node: THREE.Object3D, nodeIndex: number, nodeDef: any);
    }
    export class NEEDLE_components implements GLTFLoaderPlugin {
        get name(): string;
        parser?: GLTFParser;
        nodeToObjectMap: NodeToObjectMap;
        exportContext: {
            [nodeIndex: number]: ExportData;
        };
        objectToNodeMap: ObjectToNodeMap;
        context: SerializationContext;
        writer?: any;
        registerExport(exp: GLTFExporter): void;
        beforeParse(): void;
        serializeUserData(node: THREE.Object3D, _nodeDef: any): void;
        afterSerializeUserData(node: THREE.Object3D, _nodeDef: any): void;
        writeNode(node: THREE.Object3D, nodeDef: any): void;
        afterParse(input: any): void;
        beforeRoot(): null;
        afterRoot(result: GLTF): Promise<void>;
        private createComponents;
    }
}
declare module "engine/engine_gltf" {
    import { ConstructorConcrete, SourceIdentifier, UIDProvider } from "engine/engine_types";
    import { Context } from "engine/engine_setup";
    import { NEEDLE_components } from "engine/extensions/NEEDLE_components";
    import { SerializationContext } from "engine/engine_serialization_core";
    import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';
    export interface INeedleGltfLoader {
        createBuiltinComponents(context: Context, gltfId: SourceIdentifier, gltf: any, seed: number | null | UIDProvider, extension?: NEEDLE_components): Promise<void>;
        writeBuiltinComponentData(comp: object, context: SerializationContext): any;
        parseSync(context: Context, data: any, path: string, seed: number | UIDProvider | null): Promise<GLTF | undefined>;
        loadSync(context: Context, url: string, seed: number | UIDProvider | null, _allowAddingAnimator: boolean, prog?: (ProgressEvent: any) => void): Promise<GLTF | undefined>;
    }
    export function getLoader(): INeedleGltfLoader;
    export function registerLoader<T extends INeedleGltfLoader>(loader: ConstructorConcrete<T>): void;
}
declare module "engine/engine_networking_files" {
    import { Context } from "engine/engine_setup";
    import * as THREE from "three";
    import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { IModel } from "engine/engine_networking_types";
    export enum File_Event {
        File_Spawned = "file-spawned"
    }
    export class FileSpawnModel implements IModel {
        guid: string;
        file_name: string;
        file_hash: string;
        file_size: number;
        position: THREE.Vector3 | null;
        seed: number;
        sender: string;
        serverUrl: string;
        parentGuid?: string;
        boundsSize?: THREE.Vector3;
        constructor(connectionId: string, seed: number, guid: string, name: string, hash: string, size: number, position: THREE.Vector3 | null, serverUrl: string);
    }
    export function addFile(file: File, context: Context, backendUrl?: string): Promise<GLTF | null>;
    export function addFileFromUrl(url: URL, context: Context): Promise<GLTF | null>;
    export function beginListenFileSpawn(context: Context): void;
}
declare module "engine/engine_assetdatabase" {
    import * as THREE from 'three';
    import { Scene } from 'three';
    class TextureInfo {
        name: string;
        sampler: number;
        source: number;
        extras: {
            guid: string;
        } | undefined;
    }
    class GltfJson {
        textures: TextureInfo[];
        bufferViews: Array<{
            buffer: number;
            byteOffset: number;
            byteLength: number;
        }>;
    }
    class GltfParser {
        cache: any;
        json: GltfJson;
        associations: Map<any, any>;
        textureLoader: THREE.TextureLoader;
        loadTexture: Function;
    }
    class Gltf {
        parser: GltfParser;
        scene: Scene;
    }
    /** @deprecated */
    export class AssetDatabase {
        constructor();
        private texturesLoader;
        private textures;
        private texturesLoading;
        /** @deprecated */
        loadTexture(url: string): Promise<THREE.Texture | null>;
        /** @deprecated */
        getTexture(guid: string): THREE.Texture | null;
        /** @deprecated */
        findTexture(name: string): THREE.Texture | null;
        /** @deprecated */
        findMesh(name: string): THREE.Mesh | null;
        /** @deprecated */
        findMaterial(name: string): THREE.Material | null;
        /** @deprecated */
        registerGltf(_gltf: Gltf): Promise<void>;
        /** @deprecated */
        registerAsset(_asset: any): void;
        private _materials;
        private _meshes;
        private _textures;
    }
}
declare module "engine-components/Component" {
    import * as THREE from "three";
    import { Context, FrameEvent } from "engine/engine_setup";
    import { Object3D } from "three";
    import { ConstructorConcrete, SourceIdentifier, IComponent, IGameObject, Constructor, GuidsMap, Collision, ICollider } from "engine/engine_types";
    import { InstantiateOptions, HideFlags } from "engine/engine_gameobject";
    abstract class GameObject extends THREE.Object3D implements THREE.Object3D, IGameObject {
        guid: string | undefined;
        static setActive(go: THREE.Object3D, active: boolean, processStart?: boolean, setVisible?: boolean): void;
        static isActiveSelf(go: THREE.Object3D): boolean;
        static isActiveInHierarchy(go: THREE.Object3D): boolean;
        static markAsInstancedRendered(go: THREE.Object3D, instanced: boolean): void;
        static isUsingInstancing(instance: THREE.Object3D): boolean;
        static foreachComponent(instance: THREE.Object3D, cb: (comp: Component) => any, recursive?: boolean): any;
        static instantiateSynced(instance: GameObject | Object3D | null, opts: InstantiateOptions): GameObject | null;
        static instantiate(instance: GameObject | Object3D | null, opts?: InstantiateOptions | null): GameObject | null;
        static destroySynced(instance: THREE.Object3D | Component, context?: Context, recursive?: boolean): void;
        static destroy(instance: THREE.Object3D | Component, recursive?: boolean, isRoot?: boolean): void;
        /**
         * Add an object to parent and also ensure all components are being registered
         */
        static add(instance: THREE.Object3D | null | undefined, parent: THREE.Object3D, context?: Context): void;
        /**
         * Removes the object from its parent and deactivates all of its components
         */
        static remove(instance: THREE.Object3D | null | undefined): void;
        static invokeOnChildren(go: THREE.Object3D | null | undefined, functionName: string, ...args: any): void;
        static invoke(go: THREE.Object3D | null | undefined, functionName: string, children?: boolean, ...args: any): void;
        static addNewComponent<T>(go: GameObject | THREE.Object3D, type: ConstructorConcrete<T>, callAwake?: boolean): T;
        static addComponent(go: GameObject, instance: Component): void;
        static removeComponent(instance: Component): Component;
        static getOrAddComponent<T>(go: GameObject | THREE.Object3D, typeName: ConstructorConcrete<T>): T;
        static getComponent<T>(go: GameObject | THREE.Object3D | null, typeName: Constructor<T> | null): T | null;
        static getComponents<T>(go: GameObject | THREE.Object3D | null, typeName: Constructor<T>, arr?: T[] | null): T[];
        static findByGuid(guid: string, hierarchy: THREE.Object3D): GameObject | Component | null | undefined;
        static findObjectOfType<T>(typeName: Constructor<T>, context?: Context | THREE.Object3D, includeInactive?: boolean): T | null;
        static findObjectsOfType<T>(typeName: Constructor<T>, context?: Context | THREE.Object3D): Array<T>;
        static getComponentInChildren<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>): T | null;
        static getComponentsInChildren<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>, arr?: T[] | null): Array<T>;
        static getComponentInParent<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>): T | null;
        static getComponentsInParent<T>(go: GameObject | THREE.Object3D, typeName: Constructor<T>, arr?: Array<T> | null): Array<T>;
        static getAllComponents(go: GameObject | THREE.Object3D): Behaviour[];
        static iterateComponents(go: GameObject | THREE.Object3D): Generator<any, void, unknown>;
        abstract activeSelf: boolean;
        abstract addNewComponent<T>(type: Constructor<T>): T | null;
        abstract removeComponent(comp: Component): Component;
        abstract getOrAddComponent<T>(typeName: Constructor<T> | null): T;
        abstract getComponent<T>(type: Constructor<T>): T | null;
        abstract getComponents<T>(type: Constructor<T>, arr?: T[]): Array<T>;
        abstract getComponentInChildren<T>(type: Constructor<T>): T | null;
        abstract getComponentsInChildren<T>(type: Constructor<T>, arr?: T[]): Array<T>;
        abstract getComponentInParent<T>(type: Constructor<T>): T | null;
        abstract getComponentsInParent<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    }
    class Component implements IComponent, EventTarget {
        get isComponent(): boolean;
        private __context;
        get context(): Context;
        set context(context: Context);
        get scene(): THREE.Scene;
        get layer(): number;
        get name(): string;
        private __name?;
        set name(str: string);
        get tag(): string;
        set tag(str: string);
        get static(): any;
        get hideFlags(): HideFlags;
        get activeAndEnabled(): boolean;
        private get __isActive();
        private get __isActiveInHierarchy();
        private set __isActiveInHierarchy(value);
        gameObject: GameObject;
        guid: string;
        sourceId?: SourceIdentifier;
        /** called on a component with a map of old to new guids (e.g. when instantiate generated new guids and e.g. timeline track bindings needs to remape them) */
        resolveGuids?(guidsMap: GuidsMap): void;
        /** called once when the component becomes active for the first time */
        awake(): void;
        /** called every time when the component gets enabled (this is invoked after awake and before start) */
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /** called when you decorate fields with the @validate() decorator
         * @param field the name of the field that was changed
         */
        onValidate?(prop?: string): void;
        start?(): void;
        earlyUpdate?(): void;
        update?(): void;
        lateUpdate?(): void;
        onBeforeRender?(frame: XRFrame | null): void;
        onAfterRender?(): void;
        onCollisionEnter?(col: Collision): any;
        onCollisionExit?(col: Collision): any;
        onCollisionStay?(col: Collision): any;
        onTriggerEnter?(col: ICollider): any;
        onTriggerStay?(col: ICollider): any;
        onTriggerExit?(col: ICollider): any;
        startCoroutine(routine: Generator, evt?: FrameEvent): Generator;
        stopCoroutine(routine: Generator, evt?: FrameEvent): void;
        get destroyed(): boolean;
        destroy(): void;
        /** @internal */
        protected __didAwake: boolean;
        /** @internal */
        private __didStart;
        /** @internal */
        protected __didEnable: boolean;
        /** @internal */
        protected __isEnabled: boolean | undefined;
        /** @internal */
        private __destroyed;
        /** @internal */
        get __internalDidAwakeAndStart(): boolean;
        /** @internal */
        constructor();
        /** @internal */
        __internalNewInstanceCreated(): void;
        /** @internal */
        __internalAwake(): void;
        /** @internal */
        __internalStart(): void;
        /** @internal */
        __internalEnable(): boolean;
        /** @internal */
        __internalDisable(): void;
        /** @internal */
        __internalDestroy(): void;
        get enabled(): boolean;
        set enabled(val: boolean);
        private static _worldPositionBuffer;
        private static _worldQuaternionBuffer;
        private static _worldEulerBuffer;
        private _worldPosition;
        private _worldQuaternion;
        private static _tempQuaternionBuffer2;
        private _worldEuler;
        private _worldRotation;
        get worldPosition(): THREE.Vector3;
        set worldPosition(val: THREE.Vector3);
        setWorldPosition(x: number, y: number, z: number): void;
        get worldQuaternion(): THREE.Quaternion;
        set worldQuaternion(val: THREE.Quaternion);
        setWorldQuaternion(x: number, y: number, z: number, w: number): void;
        get worldEuler(): THREE.Euler;
        set worldEuler(val: THREE.Euler);
        get worldRotation(): THREE.Vector3;
        set worldRotation(val: THREE.Vector3);
        setWorldRotation(x: number, y: number, z: number, degrees?: boolean): void;
        private static _forward;
        get forward(): THREE.Vector3;
        private _eventListeners;
        addEventListener(type: string, listener: EventListener): void;
        removeEventListener(type: string, listener: EventListener): void;
        dispatchEvent(evt: Event): boolean;
    }
    class Behaviour extends Component {
    }
    export { Behaviour, Component, GameObject };
}
declare module "engine/engine_lightdata" {
    import { LightmapType } from "engine/extensions/NEEDLE_lightmaps";
    import { Texture } from "three";
    import { Context } from "engine/engine_setup";
    import { SourceIdentifier } from "engine/engine_types";
    export interface ILightDataRegistry {
        registerTexture(sourceId: SourceIdentifier, type: LightmapType, texture: Texture, index?: number): any;
        tryGet(sourceId: SourceIdentifier | undefined, type: LightmapType, index: number): Texture | null;
        tryGetLightmap(sourceId: SourceIdentifier | null | undefined, index: number): Texture | null;
        tryGetSkybox(sourceId?: SourceIdentifier | null): Texture | null;
        tryGetReflection(sourceId?: SourceIdentifier | null): Texture | null;
    }
    export class LightDataRegistry implements ILightDataRegistry {
        private _context;
        private _lightmaps;
        constructor(context: Context);
        registerTexture(sourceId: SourceIdentifier, type: LightmapType, tex: Texture, index: number): void;
        tryGetLightmap(sourceId: SourceIdentifier | null | undefined, index?: number): Texture | null;
        tryGetSkybox(sourceId?: SourceIdentifier | null): Texture | null;
        tryGetReflection(sourceId?: SourceIdentifier | null): Texture | null;
        tryGet(sourceId: SourceIdentifier | undefined | null, type: LightmapType, index: number): Texture | null;
    }
}
declare module "engine/extensions/NEEDLE_lightmaps" {
    import { ILightDataRegistry } from "engine/engine_lightdata";
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { SourceIdentifier } from "engine/engine_types";
    export const EXTENSION_NAME = "NEEDLE_lightmaps";
    export enum LightmapType {
        Lightmap = 0,
        Skybox = 1,
        Reflection = 2
    }
    export class NEEDLE_lightmaps implements GLTFLoaderPlugin {
        get name(): string;
        private parser;
        private registry;
        private source;
        constructor(parser: GLTFParser, reg: ILightDataRegistry, source: SourceIdentifier);
        afterRoot(_result: GLTF): Promise<void> | null;
    }
}
declare module "engine/extensions/NEEDLE_lighting_settings" {
    import { Color } from "three";
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { SourceIdentifier } from "engine/engine_types";
    import { Behaviour } from "engine-components/Component";
    import { AmbientMode, DefaultReflectionMode } from "engine/engine_rendererdata";
    import { Context } from "engine/engine_setup";
    export const EXTENSION_NAME = "NEEDLE_lighting_settings";
    export type LightingSettings = {
        ambientMode: AmbientMode;
        ambientIntensity: number;
        ambientLight: number[];
        ambientTrilight: Array<number[]>;
        environmentReflectionSource: DefaultReflectionMode;
    };
    export class NEEDLE_lighting_settings implements GLTFLoaderPlugin {
        get name(): string;
        private parser;
        private sourceId;
        private context;
        constructor(parser: GLTFParser, sourceId: SourceIdentifier, context: Context);
        afterRoot(_result: GLTF): Promise<void> | null;
    }
    export class SceneLightSettings extends Behaviour {
        ambientMode: AmbientMode;
        ambientLight?: Color;
        ambientTrilight?: Color[];
        ambientIntensity: number;
        environmentReflectionSource: DefaultReflectionMode;
        private _hasReflection;
        private _ambientLightObj?;
        private _lightProbeObj?;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
    }
}
declare module "engine/shaders/shaderData" {
    export class ShaderData {
        programs: Array<ShaderProgram>;
        shaders: Array<Shader>;
        techniques: Array<Technique>;
    }
    export class ShaderProgram {
        vertexShader: number | undefined;
        fragmentShader: number | undefined;
    }
    export enum ShaderType {
        Fragment = 35632,
        Vertex = 35633
    }
    export class Shader {
        name: string | undefined;
        type: ShaderType | undefined;
        uri: string | null | undefined;
        code: string | null | undefined;
    }
    export class Technique {
        program: number | undefined;
        attributes: Map<string, ShaderAttribute>;
        uniforms: Map<string, ShaderUniform>;
    }
    export class ShaderAttribute {
        semantic: string | undefined;
    }
    export class ShaderUniform {
        name: string;
        type: UniformType | undefined;
        semantic: string | undefined;
        count: number;
        node: number;
    }
    export enum UniformType {
        INT = 5124,
        FLOAT = 5126,
        FLOAT_VEC2 = 35664,
        FLOAT_VEC3 = 35665,
        FLOAT_VEC4 = 35666,
        INT_VEC2 = 35667,
        INT_VEC3 = 35668,
        INT_VEC4 = 35669,
        BOOL = 35670,
        BOOL_VEC2 = 35671,
        BOOL_VEC3 = 35672,
        BOOL_VEC4 = 35673,
        FLOAT_MAT2 = 35674,
        FLOAT_MAT3 = 35675,
        FLOAT_MAT4 = 35676,
        SAMPLER_2D = 35678,
        SAMPLER_3D = 35680,
        SAMPLER_CUBE = 35681,
        UNKNOWN = 0
    }
}
declare module "engine/engine_shaders" {
    import * as SHADERDATA from "engine/shaders/shaderData";
    import { DataTexture, Color } from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    export const whiteDefaultTexture: DataTexture;
    export function createFlatTexture(col: RGBAColor | Color, size?: number): DataTexture;
    export function createTrilightTexture<T extends Color>(col0: T, col1: T, col2: T, width?: number, height?: number): DataTexture;
    export enum Stage {
        Vertex = 0,
        Fragment = 1
    }
    export class UnityShaderStage {
        stage: Stage;
        code: string;
        constructor(stage: Stage, code: string);
    }
    class ShaderLib {
        loaded: Map<string, UnityShaderStage>;
        loadShader(url: string): Promise<SHADERDATA.ShaderData>;
        load(stage: Stage, url: string): Promise<UnityShaderStage>;
    }
    export const lib: ShaderLib;
    export function ToUnityMatrixArray(mat: THREE.Matrix4, buffer?: Array<THREE.Vector4>): Array<THREE.Vector4>;
    export function SetUnitySphericalHarmonics(obj: object, array?: number[]): void;
    export class ShaderBundle {
        readonly vertexShader: string;
        readonly fragmentShader: string;
        readonly technique: SHADERDATA.Technique;
        constructor(vertexShader: string, fragmentShader: string, technique: SHADERDATA.Technique);
    }
    export function FindShaderTechniques(shaderData: SHADERDATA.ShaderData, id: number): Promise<ShaderBundle | null>;
}
declare module "engine/engine_rendererdata" {
    import { Vector4, Texture, LightProbe } from "three";
    import { Context } from "engine/engine_setup";
    import { SceneLightSettings } from "engine/extensions/NEEDLE_lighting_settings";
    import { SourceIdentifier } from "engine/engine_types";
    export type SphericalHarmonicsData = {
        array: number[];
        texture: THREE.WebGLCubeRenderTarget | THREE.Texture;
        lightProbe?: LightProbe;
    };
    export enum AmbientMode {
        Skybox = 0,
        Trilight = 1,
        Flat = 3,
        Custom = 4
    }
    export enum DefaultReflectionMode {
        Skybox = 0,
        Custom = 1
    }
    export class RendererData {
        private context;
        constructor(context: Context);
        private sceneLightSettings?;
        private preUpdate;
        private _timevec4;
        get timeVec4(): Vector4;
        get environmentIntensity(): number;
        registerSceneLightSettings(sceneLightSettings: SceneLightSettings): void;
        registerReflection(sourceId: SourceIdentifier, reflectionTexture: Texture): void;
        getReflection(sourceId: SourceIdentifier): LightData | null | undefined;
        enableReflection(sourceId: SourceIdentifier): void;
        disableReflection(): void;
        getSceneLightingData(sourceId: SourceIdentifier): Promise<SphericalHarmonicsData>;
        private _waitPromise?;
        private _lighting;
    }
    export class LightData {
        get Source(): Texture;
        get Array(): number[] | undefined;
        private _context;
        private _source;
        private _sphericalHarmonics;
        private _sphericalHarmonicsArray?;
        private _ambientScale;
        private _lightProbe?;
        constructor(context: Context, tex: THREE.Texture, ambientScale?: number);
        getSphericalHarmonicsArray(intensityFactor?: number): SphericalHarmonicsData | null;
    }
}
declare module "engine/engine_addressables" {
    import { Context } from "engine/engine_setup";
    import { SourceIdentifier } from "engine/engine_types";
    import { InstantiateOptions } from "engine/engine_gameobject";
    import { IGameObject } from "engine/engine_types";
    export class Addressables {
        private _context;
        constructor(context: Context);
        private preUpdate;
        private _assetReferences;
        findAssetReference(uri: string): AssetReference | null;
        registerAssetReference(ref: AssetReference): AssetReference;
    }
    export type ProgressCallback = (asset: AssetReference, prog: ProgressEvent) => void;
    export class AssetReference {
        static getOrCreate(sourceId: SourceIdentifier, uri: string, context: Context): AssetReference;
        private static currentlyInstantiating;
        get asset(): any;
        protected set asset(val: any);
        private _loading?;
        get uri(): string;
        get rawAsset(): any;
        private _asset;
        private _glbRoot?;
        private _uri;
        private _progressListeners;
        private _hash?;
        private _hashedUri;
        private _isLoadingRawBinary;
        private _rawBinary?;
        constructor(uri: string, hash?: string);
        private onResolvePrefab;
        private get mustLoad();
        isLoaded(): boolean | ArrayBuffer;
        unload(): void;
        preload(): Promise<ArrayBuffer | null>;
        loadAssetAsync(prog?: ProgressCallback | null): Promise<any>;
        instantiate(parent?: THREE.Object3D | InstantiateOptions): Promise<IGameObject | null>;
        instantiateSynced(parent?: THREE.Object3D | InstantiateOptions, saveOnServer?: boolean): Promise<IGameObject | null>;
        beginListenDownload(evt: ProgressCallback): void;
        endListenDownload(evt: ProgressCallback): void;
        private raiseProgressEvent;
        private onInstantiate;
        /**
         * try to ignore the intermediate created object
         * because it causes trouble if we instantiate an assetreference per player
         * and call destroy on the player marker root
         * @returns the scene root object if the asset was a glb/gltf
         */
        private tryGetActualGameObjectRoot;
    }
}
declare module "engine/engine_application" {
    import { Context } from "engine/engine_setup";
    export enum ApplicationEvents {
        Visible = "application-visible",
        Hidden = "application-hidden"
    }
    export class Application extends EventTarget {
        private context;
        get hasFocus(): boolean;
        get isVisible(): boolean;
        private _isVisible;
        constructor(context: Context);
        private onVisiblityChanged;
    }
}
declare module "engine/engine_playerview" {
    import { Object3D } from "three";
    import { Context } from "engine/engine_setup";
    export enum ViewDevice {
        Browser = "browser",
        Headset = "headset",
        Handheld = "handheld"
    }
    export class PlayerView {
        readonly userId: string;
        readonly context: Context;
        viewDevice: ViewDevice;
        get currentObject(): Object3D | undefined | null;
        set currentObject(obj: Object3D | undefined | null);
        get isConnected(): boolean;
        removed: boolean;
        private _object;
        constructor(userId: string, context: Context);
    }
    export class PlayerViewManager {
        private readonly context;
        private readonly playerViews;
        constructor(context: Context);
        setPlayerView(id: string, obj: Object3D | undefined | null, device: ViewDevice): void;
        getPlayerView(id: string | null | undefined): PlayerView | undefined;
        removePlayerView(id: string, device: ViewDevice): void;
    }
}
declare module "engine/engine_setup" {
    import * as THREE from 'three';
    import { Input } from "engine/engine_input";
    import { Physics } from "engine/engine_physics";
    import { Time } from "engine/engine_time";
    import { NetworkConnection } from "engine/engine_networking";
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { AssetDatabase } from "engine/engine_assetdatabase";
    import { RendererData } from "engine/engine_rendererdata";
    import { Addressables } from "engine/engine_addressables";
    import { Application } from "engine/engine_application";
    import { ILightDataRegistry } from "engine/engine_lightdata";
    import { PlayerViewManager } from "engine/engine_playerview";
    import { ICamera, IComponent, ILight } from "engine/engine_types";
    export const build_scene_functions: {
        [name: string]: (context: Context) => Promise<void>;
    };
    type CoroutineData = {
        comp: IComponent;
        main: Generator;
        chained?: Array<Generator>;
    };
    export class LoadingProgressArgs {
        name: string;
        progress: ProgressEvent;
        index: number;
        count: number;
    }
    export class LoadingOptions {
        progress: (args: LoadingProgressArgs) => void;
    }
    export class ContextArgs {
        name: string | undefined | null;
        alias: string | undefined | null;
        domElement: HTMLElement | null;
        renderer?: THREE.WebGLRenderer;
        hash?: string;
        constructor(domElement: HTMLElement | null);
    }
    export enum FrameEvent {
        EarlyUpdate = 0,
        Update = 1,
        LateUpdate = 2,
        OnBeforeRender = 3,
        OnAfterRender = 4,
        PrePhysicsStep = 9,
        PostPhysicsStep = 10
    }
    export enum XRSessionMode {
        ImmersiveVR = "immersive-vr",
        ImmersiveAR = "immersive-ar"
    }
    export type OnBeforeRenderCallback = (renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera, geometry: THREE.BufferGeometry, material: THREE.Material, group: THREE.Group) => void;
    export function registerComponent(script: IComponent, context?: Context): void;
    export class Context {
        private static _current;
        static get Current(): Context;
        static set Current(context: Context);
        name: string;
        alias: string | undefined | null;
        isManagedExternally: boolean;
        isPaused: boolean;
        runInBackground: boolean;
        /** used to append to loaded assets */
        hash?: string;
        domElement: HTMLElement;
        get resolutionScaleFactor(): number;
        /** use to scale the resolution up or down of the renderer. default is 1 */
        set resolutionScaleFactor(val: number);
        private _resolutionScaleFactor;
        private _boundingClientRectFrame;
        private _boundingClientRect;
        private _domX;
        private _domY;
        private calculateBoundingClientRect;
        get domWidth(): number;
        get domHeight(): number;
        get domX(): number;
        get domY(): number;
        get isInXR(): boolean;
        xrSessionMode: XRSessionMode | undefined;
        get isInVR(): boolean;
        get isInAR(): boolean;
        get xrSession(): XRSession | null;
        get arOverlayElement(): HTMLElement;
        /** Current event of the update cycle */
        get currentFrameEvent(): FrameEvent;
        private _currentFrameEvent;
        scene: THREE.Scene;
        renderer: THREE.WebGLRenderer;
        composer: EffectComposer | null;
        scripts: IComponent[];
        scripts_pausedChanged: IComponent[];
        scripts_earlyUpdate: IComponent[];
        scripts_update: IComponent[];
        scripts_lateUpdate: IComponent[];
        scripts_onBeforeRender: IComponent[];
        scripts_onAfterRender: IComponent[];
        scripts_WithCorroutines: IComponent[];
        coroutines: {
            [FrameEvent: number]: Array<CoroutineData>;
        };
        get mainCamera(): THREE.Camera | null;
        mainCameraComponent: ICamera | undefined;
        post_setup_callbacks: Function[];
        pre_update_callbacks: Function[];
        pre_render_callbacks: Function[];
        post_render_callbacks: Function[];
        new_scripts: IComponent[];
        new_script_start: IComponent[];
        new_scripts_pre_setup_callbacks: Function[];
        new_scripts_post_setup_callbacks: Function[];
        application: Application;
        time: Time;
        input: Input;
        physics: Physics;
        connection: NetworkConnection;
        /**
         * @deprecated AssetDataBase is deprecated
         */
        assets: AssetDatabase;
        mainLight: ILight | null;
        rendererData: RendererData;
        addressables: Addressables;
        lightmaps: ILightDataRegistry;
        players: PlayerViewManager;
        private _sizeChanged;
        private _isCreated;
        private _isVisible;
        private _stats;
        constructor(args: ContextArgs | undefined);
        private _disposeCallbacks;
        private updateSize;
        updateAspect(camera: THREE.PerspectiveCamera): void;
        onCreate(buildScene?: (context: Context, loadingOptions?: LoadingOptions) => Promise<void>, opts?: LoadingOptions): Promise<void> | null;
        onDestroy(): void;
        registerCoroutineUpdate(script: IComponent, coroutine: Generator, evt: FrameEvent): Generator;
        unregisterCoroutineUpdate(coroutine: Generator, evt: FrameEvent): void;
        stopAllCoroutinesFrom(script: IComponent): void;
        private _cameraStack;
        setCurrentCamera(cam: ICamera): void;
        removeCamera(cam?: ICamera | null): void;
        private _onBeforeRenderListeners;
        /** use this to subscribe to onBeforeRender events on threejs objects */
        addBeforeRenderListener(target: THREE.Object3D, callback: OnBeforeRenderCallback): void;
        removeBeforeRenderListener(target: THREE.Object3D, callback: OnBeforeRenderCallback): void;
        private _requireDepthTexture;
        private _requireColorTexture;
        private _renderTarget?;
        private _isRendering;
        get isRendering(): boolean;
        setRequireDepth(val: boolean): void;
        setRequireColor(val: boolean): void;
        get depthTexture(): THREE.DepthTexture | null;
        get opaqueColorTexture(): THREE.Texture | null;
        /** returns true if the dom element is visible on screen */
        get isVisibleToUser(): boolean;
        private internalOnCreate;
        private render;
        /** returns true if we should return out of the frame loop */
        private _wasPaused;
        private onHandlePaused;
        private evaluatePaused;
        private renderRequiredTextures;
        private executeCoroutines;
    }
}
declare module "engine/engine_element_overlay" {
    import { Context } from "engine/engine_setup";
    export const arContainerClassName = "ar";
    export const quitARClassName = "quit-ar";
    export class AROverlayHandler {
        get ARContainer(): HTMLElement | null;
        constructor();
        private arContainer;
        closeARCallback: any;
        currentSession: XRSession | null;
        registeredCloseEventElements: Element[];
        private _createdAROnlyElements;
        private _reparentedObjects;
        requestEndAR(): void;
        onBegin(context: Context, overlayContainer: HTMLElement, session: XRSession): void;
        onEnd(_context: Context): void;
        findOrCreateARContainer(element: HTMLElement): HTMLElement;
        private onRequestedEndAR;
        private createFallbackCloseARButton;
    }
}
declare module "engine/debug/debug_overlay" {
    export enum LogType {
        Log = 0,
        Warn = 1,
        Error = 2
    }
    export function getErrorCount(): number;
    export function makeErrorsVisibleForDevelopment(): void;
    export function addLog(type: LogType, message: string | any[], _file?: string | null, _line?: number | null): void;
}
declare module "engine/engine_util_decorator" {
    import { Constructor, IComponent } from "engine/engine_types";
    type setter = (v: any) => void;
    type getter = () => any;
    /** create accessor callbacks for a field */
    export const validate: (set?: setter, get?: getter) => (target: IComponent | any, propertyKey: string, descriptor?: undefined) => void;
    /** experimental attribute - use to hook into another type's methods and run before the other methods run (similar to Harmony prefixes).
     * Return false to prevent the original method from running.
     */
    export const prefix: <T>(type: Constructor<T>) => (target: IComponent | any, propertyKey: string, _PropertyDescriptor: PropertyDescriptor) => void;
}
declare module "engine/api" {
    export { TypeStore } from "engine/engine_typestore";
    export { InstancingUtil } from "engine/engine_instancing";
    export * from "engine/engine_gameobject";
    export * from "engine/engine_components";
    export { AssetReference } from "engine/engine_addressables";
    export { FrameEvent } from "engine/engine_setup";
    export * from "engine/debug/debug";
    export { validate } from "engine/engine_util_decorator";
    export { Gizmos } from "engine/engine_gizmos";
}
declare module "engine/engine_element_loading" {
    import { LoadingProgressArgs } from "engine/engine_setup";
    export class LoadingElementOptions {
        className?: string;
        additionalClasses?: string[];
    }
    export interface ILoadingViewHandler {
        onLoadingBegin(message?: string): any;
        onLoadingUpdate(progress: LoadingProgressArgs, message?: string): any;
        onLoadingFinished(message?: string): any;
    }
    export function calculateProgress01(progress: LoadingProgressArgs): number;
    export class EngineLoadingView implements ILoadingViewHandler {
        loadingProgress: number;
        private container;
        private _progress;
        private _allowCustomLoadingElement;
        private _loadingElement?;
        private _loadingTextContainer;
        private _loadingBar;
        private _messageContainer;
        private _loadingElementOptions?;
        constructor(container: HTMLElement, opts?: LoadingElementOptions);
        onLoadingBegin(message?: string): void;
        onLoadingUpdate(progress: LoadingProgressArgs | ProgressEvent | number, message?: string): void;
        onLoadingFinished(message?: string): void;
        setMessage(message: string): void;
        private _progressLoop;
        private smoothProgressLoop;
        private updateDisplay;
        private createLoadingElement;
    }
}
declare module "engine/engine_loaders" {
    import { Context } from "engine/engine_setup";
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    export function setDracoDecoderPath(path: string | undefined): void;
    export function setDracoDecoderType(type: string | undefined): void;
    export function setKtx2TranscoderPath(path: string): void;
    export function addDracoAndKTX2Loaders(loader: GLTFLoader, context: Context): void;
}
declare module "engine/extensions/NEEDLE_animator_controller_model" {
    import { Animator } from "engine-components/Animator";
    import { AnimationAction, AnimationClip, Object3D } from "three";
    import { Context } from "engine/engine_setup";
    import { InstantiateIdProvider } from "engine/engine_networking_instantiate";
    export type AnimatorControllerModel = {
        name: string;
        guid: string;
        parameters: Parameter[];
        layers: Layer[];
    };
    export type Parameter = {
        name: string;
        /** the animator string to hash result, test against this if a number is used to get a param value */
        hash: number;
        type: AnimatorControllerParameterType;
        value: number | boolean | string;
    };
    export type Layer = {
        name: string;
        stateMachine: StateMachine;
    };
    export type StateMachine = {
        defaultState: number;
        states: State[];
    };
    export type State = {
        name: string;
        hash: number;
        motion: Motion;
        transitions: Transition[];
        behaviours: StateMachineBehaviourModel[];
    };
    export type StateMachineBehaviourModel = {
        typeName: string;
        properties: object;
        instance?: StateMachineBehaviour;
    };
    export abstract class StateMachineBehaviour {
        _context?: Context;
        get context(): Context;
        get isStateMachineBehaviour(): boolean;
        onStateEnter?(animator: Animator, _animatorStateInfo: AnimatorStateInfo, layerIndex: number): any;
        onStateUpdate?(animator: Animator, animatorStateInfo: AnimatorStateInfo, _layerIndex: number): any;
        onStateExit?(animator: Animator, animatorStateInfo: AnimatorStateInfo, layerIndex: number): any;
    }
    export class AnimatorStateInfo {
        private _name;
        get name(): string;
        private _nameHash;
        get nameHash(): number;
        private _normalizedTime;
        get normalizedTime(): number;
        private _length;
        get length(): number;
        private _speed;
        get speed(): number;
        constructor(state: State, normalizedTime: number, length: number, speed: number);
    }
    export type Motion = {
        name: string;
        isLooping: boolean;
        guid: string;
        /** clip index in gltf animations array */
        index: number;
        /** the resolved clip */
        clip?: AnimationClip;
        /** the clip mapping -> which object has which animationclip */
        clips?: ClipMapping[];
        action?: AnimationAction;
        /** used when a transition points to the same state we need another action to blend */
        action_loopback?: AnimationAction;
    };
    export function createMotion(name: string, id?: InstantiateIdProvider): Motion;
    export type ClipMapping = {
        /** the object this clip is for */
        node: Object3D;
        /** the animationclip we resolve from a json ptr */
        clip: AnimationClip;
    };
    export type Transition = {
        isExit: boolean;
        exitTime: number;
        hasFixedDuration: boolean;
        offset: number;
        duration: number;
        hasExitTime: number;
        destinationState: number | State;
        conditions: Condition[];
    };
    export type Condition = {
        parameter: string;
        mode: AnimatorConditionMode;
        threshold: number;
    };
    export enum AnimatorConditionMode {
        If = 1,
        IfNot = 2,
        Greater = 3,
        Less = 4,
        Equals = 6,
        NotEqual = 7
    }
    export enum AnimatorControllerParameterType {
        Float = 1,
        Int = 3,
        Bool = 4,
        Trigger = 9
    }
}
declare module "engine-components/AnimatorController" {
    import { Animator } from "engine-components/Animator";
    import { AnimatorControllerModel, State } from "engine/extensions/NEEDLE_animator_controller_model";
    import { AnimationAction } from "three";
    import { Context } from "engine/engine_setup";
    export class AnimatorController {
        Play(name: string | number, layerIndex?: number, normalizedTime?: number, durationInSec?: number): void;
        Reset(): void;
        SetBool(name: string | number, value: boolean): void;
        GetBool(name: string | number): boolean;
        SetFloat(name: string | number, val: number): void;
        GetFloat(name: string | number): number;
        SetInteger(name: string | number, val: number): void;
        GetInteger(name: string | number): number;
        SetTrigger(name: string | number): void;
        ResetTrigger(name: string | number): void;
        IsInTransition(): boolean;
        SetSpeed(speed: number): void;
        FindState(name: string | undefined | null): State | null;
        normalizedStartOffset: number;
        private _speed;
        animator?: Animator;
        model: AnimatorControllerModel;
        get context(): Context | undefined | null;
        bind(animator: Animator): void;
        clone(): AnimatorController;
        update(): void;
        private _mixer;
        private _activeState?;
        constructor(model: AnimatorControllerModel);
        private _activeStates;
        private updateActiveStates;
        private setStartTransition;
        private evaluateTransitions;
        private getState;
        private transitionTo;
        private createAction;
        private evaluateCondition;
        private createActions;
        enumerateActions(): Generator<AnimationAction, void, unknown>;
        private rootMotionHandler?;
    }
}
declare module "engine/engine_serialization_decorator" {
    import { Constructor } from "engine/engine_types";
    export type TypeResolver<T> = (data: any) => Constructor<T> | null;
    /** Please use "@serializable" - this version has a typo and will be removed in future versions */
    export const serializeable: <T>(type?: Constructor<T> | TypeResolver<T> | (Constructor<any> | TypeResolver<T>)[] | null | undefined) => (_target: any, _propertyKey: string) => void;
    export const serializable: <T>(type?: Constructor<T> | TypeResolver<T> | (Constructor<any> | TypeResolver<T>)[] | null | undefined) => (_target: any, _propertyKey: string) => void;
    export const ALL_PROPERTIES_MARKER = "__NEEDLE__ALL_PROPERTIES";
    /** @deprecated current not used */
    export function allProperties(constructor: Function): void;
    export const STRICT_MARKER = "__NEEDLE__STRICT";
    /** @deprecated  current not used */
    export function strict(constructor: Function): void;
}
declare module "engine-components/Animator" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from 'three';
    import { AnimationActionLoopStyles } from "three";
    import { AnimatorControllerModel } from "engine/extensions/NEEDLE_animator_controller_model";
    import { AnimatorController } from "engine-components/AnimatorController";
    export class MixerEvent {
        type: string;
        action: THREE.AnimationAction;
        loopDelta: number;
        target: THREE.AnimationMixer;
    }
    export class PlayOptions {
        loop?: boolean | AnimationActionLoopStyles;
        clampWhenFinished?: boolean;
    }
    export class Animator extends Behaviour {
        applyRootMotion: boolean;
        hasRootMotion: boolean;
        keepAnimatorControllerStateOnDisable: boolean;
        set runtimeAnimatorController(val: AnimatorControllerModel | AnimatorController | undefined | null);
        get runtimeAnimatorController(): AnimatorController | undefined | null;
        Play(name: string | number, layer?: number, normalizedTime?: number, transitionDurationInSec?: number): void;
        Reset(): void;
        SetBool(name: string | number, value: boolean): void;
        GetBool(name: string | number): boolean;
        SetFloat(name: string | number, val: number): void;
        GetFloat(name: string | number): number;
        SetInteger(name: string | number, val: number): void;
        GetInteger(name: string | number): number;
        SetTrigger(name: string | number): void;
        ResetTrigger(name: string | number): void;
        IsInTransition(): boolean;
        SetSpeed(speed: number): void;
        set minMaxSpeed(minMax: {
            x: number;
            y: number;
        });
        set minMaxOffsetNormalized(minMax: {
            x: number;
            y: number;
        });
        private speed;
        private normalizedStartOffset;
        private _animatorController?;
        awake(): void;
        onDisable(): void;
        onBeforeRender(): void;
    }
}
declare module "engine-components/Animation" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from 'three';
    import { AnimationAction, AnimationClip } from "three";
    import { Vec2 } from "engine/engine_types";
    export class PlayOptions {
        fadeDuration?: number;
        loop?: boolean;
        exclusive?: boolean;
        startTime?: number;
        endTime?: number;
        clampWhenFinished?: boolean;
        minMaxSpeed?: Vec2;
        minMaxOffsetNormalized?: Vec2;
    }
    export class Animation extends Behaviour {
        playAutomatically: boolean;
        randomStartTime: boolean;
        minMaxSpeed?: Vec2;
        minMaxOffsetNormalized?: Vec2;
        loop: boolean;
        clampWhenFinished: boolean;
        private _tempAnimationClipBeforeGameObjectExisted;
        get clip(): AnimationClip | null;
        set clip(val: AnimationClip | null);
        set clips(animations: AnimationClip[]);
        set animations(animations: THREE.AnimationClip[]);
        get animations(): AnimationClip[];
        /**
         * @deprecated Currently unsupported
         */
        get currentAction(): THREE.AnimationAction | null;
        /**
         * @deprecated Currently unsupported
         */
        get currentActions(): THREE.AnimationAction[];
        private mixer;
        get actions(): Array<THREE.AnimationAction>;
        set actions(val: Array<THREE.AnimationAction>);
        private _actions;
        private _currentActions;
        private _handles;
        awake(): void;
        onEnable(): void;
        start(): void;
        update(): void;
        getAction(name: string): THREE.AnimationAction | undefined | null;
        get isPlaying(): boolean;
        play(clipOrNumber: AnimationClip | number | string | undefined, options?: PlayOptions): Promise<AnimationAction> | void;
        internalOnPlay(action: AnimationAction, options?: PlayOptions): Promise<AnimationAction>;
        private tryFindHandle;
        private _didInit;
        init(): void;
    }
}
declare module "engine/extensions/NEEDLE_techniques_webgl" {
    import { GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import * as THREE from 'three';
    import { RawShaderMaterial } from 'three';
    import { SourceIdentifier } from "engine/engine_types";
    export const NEEDLE_TECHNIQUES_WEBGL_NAME = "NEEDLE_techniques_webgl";
    export class CustomShader extends RawShaderMaterial {
        private identifier;
        private onBeforeRenderSceneCallback;
        clone(): this;
        constructor(identifier: SourceIdentifier, ...args: any[]);
        dispose(): void;
        waitForLighting(): Promise<void>;
        private _sphericalHarmonicsName;
        private _objToWorldName;
        private _worldToObjectName;
        private static viewProjection;
        private static _viewProjectionValues;
        private _viewProjectionName;
        private static viewMatrix;
        private static _viewMatrixValues;
        private _viewMatrixName;
        private static _worldSpaceCameraPosName;
        private static _worldSpaceCameraPos;
        private static _mainLightColor;
        private static _mainLightPosition;
        private static _lightData;
        private _rendererData;
        private get depthTextureUniform();
        private get opaqueTextureUniform();
        private onBeforeRenderScene;
        onBeforeRender(_renderer: any, _scene: any, camera: any, _geometry: any, obj: any, _group: any): void;
        onUpdateUniforms(camera?: THREE.Camera, obj?: any): void;
    }
    export class NEEDLE_techniques_webgl implements GLTFLoaderPlugin {
        get name(): string;
        private parser;
        private identifier;
        constructor(loader: GLTFParser, identifier: SourceIdentifier);
        loadMaterial(index: number): Promise<THREE.Material> | null;
    }
}
declare module "engine/extensions/EXT_texture_exr" {
    import { Texture } from "three";
    import { GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    export class EXT_texture_exr implements GLTFLoaderPlugin {
        private parser;
        private name;
        constructor(parser: GLTFParser);
        loadTexture(textureIndex: any): Promise<Texture> | null;
    }
}
declare module "engine/extensions/NEEDLE_gameobject_data" {
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    export const EXTENSION_NAME = "NEEDLE_gameobject_data";
    export class NEEDLE_gameobject_data implements GLTFLoaderPlugin {
        get name(): string;
        private parser;
        constructor(parser: GLTFParser);
        afterRoot(_result: GLTF): Promise<void> | null;
        private findAndApplyExtensionData;
        private applyExtensionData;
    }
}
declare module "engine/extensions/NEEDLE_render_objects" {
    import { SourceIdentifier } from "engine/engine_types";
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { IRenderer } from "engine/engine_types";
    export class NEEDLE_render_objects implements GLTFLoaderPlugin {
        private static stencils;
        static applyStencil(obj?: IRenderer | null): void;
        private parser;
        private source;
        constructor(parser: GLTFParser, source: SourceIdentifier);
        afterRoot(_result: GLTF): Promise<void> | null;
    }
    export const EXTENSION_NAME = "NEEDLE_render_objects";
}
declare module "engine/extensions/NEEDLE_progressive" {
    import { Material } from "three";
    import { GLTF, GLTFLoaderPlugin, GLTFParser } from "three/examples/jsm/loaders/GLTFLoader";
    import { SourceIdentifier } from "engine/engine_types";
    import { Context } from "engine/engine_setup";
    export const EXTENSION_NAME = "NEEDLE_progressive";
    export class NEEDLE_progressive implements GLTFLoaderPlugin {
        static assignTextureLOD(context: Context, source: SourceIdentifier | undefined, material: Material, level?: number): void;
        get name(): string;
        private parser;
        private sourceId;
        private context;
        constructor(parser: GLTFParser, sourceId: SourceIdentifier, context: Context);
        private _loading;
        afterRoot(gltf: GLTF): null;
        private static cache;
        private static resolved;
        private static getOrLoadTexture;
    }
}
declare module "engine/extensions/extensions" {
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
    import { NEEDLE_components } from "engine/extensions/NEEDLE_components";
    import { SourceIdentifier } from "engine/engine_types";
    import { Context } from "engine/engine_setup";
    export function registerComponentExtension(loader: GLTFLoader): NEEDLE_components;
    export function registerExtensions(loader: GLTFLoader, context: Context, sourceId: SourceIdentifier): void;
}
declare module "engine-components/EventList" {
    export class CallInfo {
        method?: Function;
        enabled: boolean;
        constructor(method?: Function, enabled?: boolean);
        invoke(...args: any): void;
    }
    export class EventListEvent extends Event {
        args?: [];
    }
    export class EventList {
        private target?;
        private key?;
        /** set an event target to try invoke the EventTarget dispatchEvent when this EventList is invoked */
        setEventTarget(key: string, target: object): void;
        private _isInvoking;
        private methods;
        constructor(evts?: CallInfo[]);
        invoke(...args: any): void;
        addEventListener(cb: Function): Function;
        removeEventListener(cb: Function | null | undefined): void;
        removeAllEventListeners(): void;
    }
}
declare module "engine/engine_texture" {
    import { WebGLRenderTarget } from "three";
    export class RenderTexture extends WebGLRenderTarget {
    }
}
declare module "engine/engine_serialization_builtin_serializer" {
    import * as THREE from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { SerializationContext, TypeSerializer } from "engine/engine_serialization_core";
    import { Behaviour, GameObject } from "engine-components/Component";
    import { EventList } from "engine-components/EventList";
    import { RenderTexture } from "engine/engine_texture";
    class ColorSerializer extends TypeSerializer {
        constructor();
        onDeserialize(data: any): THREE.Color | RGBAColor | void;
        onSerialize(data: any): any | void;
    }
    export const colorSerializer: ColorSerializer;
    type ObjectData = {
        node?: number;
        guid?: string;
    };
    class ObjectSerializer extends TypeSerializer {
        constructor();
        onSerialize(data: any, context: SerializationContext): {
            node: number;
        } | undefined;
        onDeserialize(data: ObjectData, context: SerializationContext): THREE.Object3D<THREE.Event> | GameObject | Behaviour | null | undefined;
    }
    export const objectSerializer: ObjectSerializer;
    class ComponentSerializer extends TypeSerializer {
        constructor();
        onSerialize(data: any, _context: SerializationContext): {
            guid: any;
        } | undefined;
        onDeserialize(data: any, context: SerializationContext): any;
        findObjectForGuid(guid: string, root: THREE.Object3D): any;
    }
    export const componentSerializer: ComponentSerializer;
    class EventListData {
        type: string;
        calls: Array<EventListCall>;
    }
    type EventListCall = {
        method: string;
        target: string;
        argument?: any;
        enabled?: boolean;
    };
    class EventListSerializer extends TypeSerializer {
        constructor();
        onSerialize(_data: EventList, _context: SerializationContext): EventListData | undefined;
        onDeserialize(data: EventListData, context: SerializationContext): EventList | undefined | null;
    }
    export const eventListSerializer: EventListSerializer;
    export class RenderTextureSerializer extends TypeSerializer {
        constructor();
        onSerialize(_data: any, _context: SerializationContext): void;
        onDeserialize(data: any, context: SerializationContext): RenderTexture | undefined;
    }
}
declare module "engine/engine_serialization" {
    import { serializeObject, deserializeObject } from "engine/engine_serialization_core";
    import * as builtin from "engine/engine_serialization_builtin_serializer";
    export { serializeObject, deserializeObject, builtin };
    export { serializable, serializeable } from "engine/engine_serialization_decorator";
}
declare module "engine/engine_gltf_builtin_components" {
    import "./codegen/register_types";
    import { Component } from "engine-components/Component";
    import { Context } from "engine/engine_setup";
    import { SerializationContext } from "engine/engine_serialization_core";
    import { NEEDLE_components } from "engine/extensions/NEEDLE_components";
    import { SourceIdentifier } from "engine/engine_types";
    import { UIDProvider } from "engine/engine_types";
    export function writeBuiltinComponentData(comp: Component, context: SerializationContext): object | null;
    export function createBuiltinComponents(context: Context, gltfId: SourceIdentifier, gltf: any, seed?: number | null | UIDProvider, extension?: NEEDLE_components): Promise<void>;
}
declare module "engine/engine_scenetools" {
    import { Context } from "engine/engine_setup";
    import { GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { INeedleGltfLoader } from "engine/engine_gltf";
    import { UIDProvider } from "engine/engine_types";
    import { SerializationContext } from "engine/engine_serialization_core";
    import { NEEDLE_components } from "engine/extensions/NEEDLE_components";
    export class NeedleGltfLoader implements INeedleGltfLoader {
        createBuiltinComponents(context: Context, gltfId: string, gltf: any, seed: number | UIDProvider | null, extension?: NEEDLE_components | undefined): Promise<void>;
        writeBuiltinComponentData(comp: any, context: SerializationContext): object | null;
        parseSync(context: Context, data: any, path: string, seed: number | UIDProvider | null): Promise<GLTF | undefined>;
        loadSync(context: Context, url: string, seed: number | UIDProvider | null, _allowAddingAnimator: boolean, prog?: ((ProgressEvent: any) => void) | undefined): Promise<GLTF | undefined>;
    }
    export enum GltfLoadEventType {
        BeforeLoad = 0,
        AfterLoaded = 1,
        FinishedSetup = 10
    }
    export class GltfLoadEvent {
        context: Context;
        loader: GLTFLoader;
        path: string;
        gltf?: GLTF;
        constructor(context: Context, path: string, loader: GLTFLoader, gltf?: GLTF);
    }
    export type GltfLoadEventCallback = (event: GltfLoadEvent) => void;
    export function addGltfLoadEventListener(type: GltfLoadEventType, listener: GltfLoadEventCallback): void;
    export function removeGltfLoadEventListener(type: GltfLoadEventType, listener: GltfLoadEventCallback): void;
    export function parseSync(context: Context, data: any, path: string, seed: number | UIDProvider | null): Promise<GLTF | undefined>;
    export function loadSync(context: Context, url: string, seed: number | UIDProvider | null, _allowAddingAnimator?: boolean, prog?: (ProgressEvent: any) => void): Promise<GLTF | undefined>;
    export function findAnimationsLate(_context: Context, gltf: any, callbackarray: any, allowAddingAnimator?: boolean): void;
    export function findAnimations(gltf: GLTF, allowAddingAnimator?: boolean): void;
    export function tryFindObjectByName(name: any, obj: any, recursive?: boolean): any;
    export function tryFindObject(globalObjectIdentifier: any, obj: any, recursive?: boolean): any;
    export function tryFindScript(globalObjectIdentifier: any, list?: null): import("engine/engine_types").IComponent | null;
}
declare module "engine/engine_element" {
    import { Context } from "engine/engine_setup";
    import { INeedleEngineComponent } from "engine/engine_types";
    export class EngineElement extends HTMLElement implements INeedleEngineComponent {
        get loadingProgress01(): number;
        get loadingFinished(): boolean;
        getContext(): Promise<Context>;
        get Context(): Context | null;
        /**@obsolete use GameObject */
        private gameObject;
        private GameObject;
        private _context;
        private _overlay_ar;
        private _loadingProgress01;
        private _watcher?;
        private _loadingView?;
        constructor();
        connectedCallback(): Promise<void>;
        disconnectedCallback(): void;
        static get observedAttributes(): string[];
        attributeChangedCallback(name: string, _oldValue: string, newValue: string): void;
        private registerEventFromAttribute;
        getAROverlayContainer(): HTMLElement;
        getVROverlayContainer(): HTMLElement | null;
        onEnterAR(session: XRSession, overlayContainer: HTMLElement): void;
        onExitAR(session: XRSession): void;
        onEnterVR(session: XRSession): void;
        onExitVR(session: XRSession): void;
        private onElementsChanged;
        private onSetupAR;
        private onSetupVR;
        private onSetupDesktop;
        private setupElementsForMode;
        private foreachHtmlElement;
        private onBeforeBeginLoading;
    }
}
declare module "engine-components/AlignmentConstraint" {
    import { Behaviour } from "engine-components/Component";
    export class AlignmentConstraint extends Behaviour {
        private from;
        private to;
        private width;
        private centered;
        private _centerPos;
        awake(): void;
        update(): void;
    }
}
declare module "engine-components/AnimationCurve" {
    class Keyframe {
        time: number;
        value: number;
        inTangent: number;
        inWeight: number;
        outTangent: number;
        outWeight: number;
        weightedMode: number;
    }
    export class AnimationCurve {
        keys: Array<Keyframe>;
        get duration(): number;
        evaluate(time: number): number;
    }
}
declare module "engine-components/AudioSource" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export enum AudioRolloffMode {
        Logarithmic = 0,
        Linear = 1,
        Custom = 2
    }
    export class AudioSource extends Behaviour {
        private static _didCallBeginWaitForUserInteraction;
        static get userInteractionRegistered(): boolean;
        private static callbacks;
        static registerWaitForAllowAudio(cb: Function): void;
        private static _userInteractionRegistered;
        private static _beginWaitForUserInteraction;
        clip: string;
        playOnAwake: boolean;
        get loop(): boolean;
        set loop(val: boolean);
        get spatialBlend(): number;
        set spatialBlend(val: number);
        get minDistance(): number;
        set minDistance(val: number);
        get maxDistance(): number;
        set maxDistance(val: number);
        private _spatialBlend;
        private _minDistance;
        private _maxDistance;
        get volume(): number;
        set volume(val: number);
        private _volume;
        rollOffMode: AudioRolloffMode;
        private _loop;
        private sound;
        private helper;
        private wasPlaying;
        private audioLoader;
        private shouldPlay;
        private _lastClipStartedLoading;
        get Sound(): THREE.PositionalAudio | null;
        get ShouldPlay(): boolean;
        private _focusCallback?;
        awake(): void;
        onDestroy(): void;
        onEnable(): void;
        onDisable(): void;
        private lerp;
        private onLoaded;
        private applySpatialDistanceSettings;
        private loadAndPlay;
        play(clip?: string | undefined): void;
        pause(): void;
        stop(): void;
        private _lastContextTime;
        get isPlaying(): boolean;
        set isPlaying(_: boolean);
        get time(): number;
        set time(val: number);
        private _hasEnded;
        private _needUpdateSpatialDistanceSettings;
        update(): void;
    }
}
declare module "engine-components/Camera" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { Ray } from "three";
    import { ICamera } from "engine/engine_types";
    export enum ClearFlags {
        Skybox = 1,
        SolidColor = 2,
        Uninitialized = 4
    }
    export class Camera extends Behaviour implements ICamera {
        get isCamera(): boolean;
        get aspect(): number;
        get fieldOfView(): number;
        set fieldOfView(val: number);
        get nearClipPlane(): number;
        set nearClipPlane(val: number);
        private _nearClipPlane;
        get farClipPlane(): number;
        set farClipPlane(val: number);
        private _farClipPlane;
        get clearFlags(): ClearFlags;
        set clearFlags(val: ClearFlags);
        orthographic: boolean;
        orthographicSize: number;
        ARBackgroundAlpha: number;
        set cullingMask(val: number);
        get cullingMask(): number;
        private _cullingMask;
        set backgroundBlurriness(val: number | undefined);
        get backgroundBlurriness(): number | undefined;
        private _backgroundBlurriness?;
        set backgroundIntensity(val: number | undefined);
        get backgroundIntensity(): number | undefined;
        private _backgroundIntensity?;
        get backgroundColor(): RGBAColor | null;
        set backgroundColor(val: RGBAColor | null);
        private _backgroundColor?;
        private _fov;
        private _cam;
        private _clearFlags;
        private _skybox?;
        get cam(): THREE.PerspectiveCamera | THREE.OrthographicCamera;
        private static _origin;
        private static _direction;
        screenPointToRay(x: number, y: number, ray?: Ray): Ray;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        buildCamera(): void;
        applyClearFlagsIfIsActiveCamera(): void;
        private environmentIsTransparent;
        private enableSkybox;
    }
}
declare module "engine-components/AudioListener" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export class AudioListener extends Behaviour {
        get listener(): THREE.AudioListener;
        private _listener;
        awake(): void;
    }
}
declare module "engine-components/AvatarLoader" {
    import * as THREE from "three";
    import { Context } from "engine/engine_setup";
    export class AvatarModel {
        root: THREE.Object3D;
        head: THREE.Object3D;
        leftHand: THREE.Object3D | null;
        rigthHand: THREE.Object3D | null;
        get isValid(): boolean;
        constructor(root: THREE.Object3D, head: THREE.Object3D, leftHand: THREE.Object3D | null, rigthHand: THREE.Object3D | null);
    }
    export class AvatarLoader {
        private readonly avatarRegistryUrl;
        getOrCreateNewAvatarInstance(context: Context, avatarId: string | THREE.Object3D): Promise<AvatarModel | null>;
        private loadAvatar;
        private cacheModel;
        private findAvatar;
        private findAvatarPart;
        private handleCustomAvatarErrors;
    }
}
declare module "engine-components/AxesHelper" {
    import { Behaviour } from "engine-components/Component";
    export class AxesHelper extends Behaviour {
        length: number;
        depthTest: boolean;
        isGizmo: boolean;
        private _axes;
        onEnable(): void;
        onDisable(): void;
    }
}
declare module "engine-components/BasicIKConstraint" {
    import { Behaviour } from "engine-components/Component";
    export class BasicIKConstraint extends Behaviour {
        private from;
        private to;
        private hint;
        private desiredDistance;
        onEnable(): void;
        update(): void;
    }
}
declare module "engine-components/BoxHelperComponent" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export class BoxHelperComponent extends Behaviour {
        private box;
        private static testBox;
        private _lastMatrixUpdateFrame;
        private static _position;
        private static _size;
        isInBox(obj: THREE.Object3D, scaleFactor?: number): boolean | undefined;
        intersects(box: THREE.Box3): boolean;
        updateBox(force?: boolean): THREE.Box3;
        private _helper;
        private _color;
        awake(): void;
        showHelper(col?: THREE.ColorRepresentation | null, force?: boolean): void;
    }
}
declare module "engine-components/RigidBody" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from 'three';
    import { Vector3 } from "three";
    import { IRigidbody } from "engine/engine_types";
    import { CollisionDetectionMode, RigidbodyConstraints } from "engine/engine_physics.types";
    export class Rigidbody extends Behaviour implements IRigidbody {
        mass: number;
        useGravity: boolean;
        constraints: RigidbodyConstraints;
        isKinematic: boolean;
        drag: number;
        angularDrag: number;
        detectCollisions: boolean;
        sleepThreshold: number;
        collisionDetectionMode: CollisionDetectionMode;
        get lockPositionX(): boolean;
        get lockPositionY(): boolean;
        get lockPositionZ(): boolean;
        get lockRotationX(): boolean;
        get lockRotationY(): boolean;
        get lockRotationZ(): boolean;
        set lockPositionX(v: boolean);
        set lockPositionY(v: boolean);
        set lockPositionZ(v: boolean);
        set lockRotationX(v: boolean);
        set lockRotationY(v: boolean);
        set lockRotationZ(v: boolean);
        private static tempPosition;
        private _propertiesChanged;
        private _currentVelocity;
        private _smoothedVelocity;
        private _smoothedVelocityGetter;
        private _lastPosition;
        private _watch?;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        onValidate(): void;
        beforePhysics(): Generator<undefined, void, unknown>;
        private get body();
        teleport(pt: {
            x: number;
            y: number;
            z: number;
        }, localspace?: boolean): void;
        resetForces(): void;
        resetTorques(): void;
        resetVelocities(): void;
        resetForcesAndTorques(): void;
        wakeUp(): void;
        applyForce(vec: Vector3, _rel?: THREE.Vector3): void;
        applyImpulse(vec: Vector3): void;
        setForce(x: number, y: number, z: number): void;
        getVelocity(): Vector3;
        setVelocity(x: number | Vector3, y?: number, z?: number): void;
        setAngularVelocity(x: number | Vector3, y?: number, z?: number): void;
        setTorque(x: number | Vector3, y: number, z: number): void;
        get smoothedVelocity(): Vector3;
        /**d
         * @deprecated not used anymore
         */
        setBodyFromGameObject(_velocity?: THREE.Vector3 | null | {
            x: number;
            y: number;
            z: number;
        }): void;
        private captureVelocity;
    }
}
declare module "engine-components/Collider" {
    import { Behaviour } from "engine-components/Component";
    import { Rigidbody } from "engine-components/RigidBody";
    import { Mesh, Vector3 } from "three";
    import { ICollider } from "engine/engine_types";
    export class Collider extends Behaviour implements ICollider {
        get isCollider(): any;
        attachedRigidbody: Rigidbody | null;
        isTrigger: boolean;
        awake(): void;
        start(): void;
        onEnable(): void;
        onDisable(): void;
    }
    export class SphereCollider extends Collider {
        radius: number;
        center: Vector3;
        onEnable(): void;
    }
    export class BoxCollider extends Collider {
        size: Vector3;
        center: Vector3;
        onEnable(): void;
    }
    export class MeshCollider extends Collider {
        sharedMesh?: Mesh;
        convex: boolean;
        onEnable(): void;
    }
    export class CapsuleCollider extends Collider {
        center: Vector3;
        radius: number;
        height: number;
        onEnable(): void;
    }
}
declare module "engine-components/CharacterController" {
    import { Vector3 } from "three";
    import { Collision } from "engine/engine_types";
    import { Behaviour } from "engine-components/Component";
    import { Rigidbody } from "engine-components/RigidBody";
    import { Animator } from "engine-components/Animator";
    export class CharacterController extends Behaviour {
        center: Vector3;
        radius: number;
        height: number;
        private _rigidbody;
        get rigidbody(): Rigidbody;
        onEnable(): void;
        move(vec: Vector3): void;
        private _activeGroundCollisions;
        onCollisionEnter(col: Collision): void;
        onCollisionExit(col: Collision): void;
        get isGrounded(): boolean;
    }
    export class CharacterControllerInput extends Behaviour {
        controller?: CharacterController;
        movementSpeed: number;
        rotationSpeed: number;
        jumpForce: number;
        animator?: Animator;
        lookForward: boolean;
        private _currentSpeed;
        private _currentAngularSpeed;
        private _temp;
        private _jumpCount;
        private _currentRotation;
        awake(): void;
        update(): void;
        private _raycastOptions;
    }
}
declare module "engine-components/ui/PointerEvents" {
    export interface IInputEventArgs {
        get used(): boolean;
        Use(): void;
        StopPropagation?(): void;
    }
    export class PointerEventData implements IInputEventArgs {
        used: boolean;
        Use(): void;
        StopPropagation(): void;
        inputSource: any;
        object: THREE.Object3D;
        isDown: boolean | undefined;
        isUp: boolean | undefined;
        isPressed: boolean | undefined;
        isClicked: boolean | undefined;
        private event?;
        constructor(events?: Event);
    }
    export interface IPointerDownHandler {
        onPointerDown?(args: PointerEventData): any;
    }
    export interface IPointerUpHandler {
        onPointerUp?(args: PointerEventData): any;
    }
    export interface IPointerEnterHandler {
        onPointerEnter?(args: PointerEventData): any;
    }
    export interface IPointerExitHandler {
        onPointerExit?(args: PointerEventData): any;
    }
    export interface IPointerClickHandler {
        onPointerClick?(args: PointerEventData): any;
    }
    export interface IPointerEventHandler extends IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler {
    }
}
declare module "engine-components/Interactable" {
    import { Behaviour } from "engine-components/Component";
    import { IPointerClickHandler, PointerEventData } from "engine-components/ui/PointerEvents";
    export class Interactable extends Behaviour implements IPointerClickHandler {
        canGrab: boolean;
        onPointerClick(_args: PointerEventData): void;
    }
    export class UsageMarker extends Behaviour {
        isUsed: boolean;
        usedBy: any;
    }
}
declare module "engine-components/DeleteBox" {
    import { BoxHelperComponent } from "engine-components/BoxHelperComponent";
    import { Behaviour } from "engine-components/Component";
    export class DeleteBox extends BoxHelperComponent {
    }
    export class Deletable extends Behaviour {
        private deleteBoxes;
        awake(): void;
        update(): void;
    }
}
declare module "engine-components/DeviceFlag" {
    import { Behaviour } from "engine-components/Component";
    export enum DeviceType {
        Never = 0,
        Desktop = 1,
        Mobile = 2
    }
    export class DeviceFlag extends Behaviour {
        visibleOn: DeviceType;
        onEnable(): void;
        apply(): void;
        private test;
    }
}
declare module "engine-components/SyncedTransform" {
    import { Behaviour } from "engine-components/Component";
    export const SyncedTransformIdentifier = "STRS";
    export function createTransformModel(guid: string, b: Behaviour, fast?: boolean): Uint8Array;
    export class SyncedTransform extends Behaviour {
        overridePhysics: boolean;
        interpolatePosition: boolean;
        interpolateRotation: boolean;
        fastMode: boolean;
        syncDestroy: boolean;
        private _model;
        private _needsUpdate;
        private rb;
        private _wasKinematic;
        private _receivedDataBefore;
        private _targetPosition;
        private _targetRotation;
        private _receivedFastUpdate;
        private _shouldRequestOwnership;
        requestOwnership(): void;
        hasOwnership(): boolean | undefined;
        isOwned(): boolean | undefined;
        private joinedRoomCallback;
        private receivedDataCallback;
        awake(): void;
        onDestroy(): void;
        private tryGetLastState;
        private tempEuler;
        private onReceivedData;
        onEnable(): void;
        onDisable(): void;
        private receivedUpdate;
        private lastWorldPos;
        private lastWorldRotation;
        onBeforeRender(): void;
    }
}
declare module "engine-components/Voip" {
    import { Behaviour } from "engine-components/Component";
    export const noVoip = "noVoip";
    export class Voip extends Behaviour {
        requireParam: boolean;
        set muteInput(value: boolean);
        get muteInput(): boolean;
        set muteOutput(value: boolean);
        get muteOutput(): boolean;
        getFrequency(userId: string | null): number | null;
        private peer;
        private model;
        private connections;
        private currentIncomingCalls;
        private _inputMuted;
        private _outputMuted;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        private onOpenPeerConnection;
        private onReceiveCall;
        static HasMicrophonePermissions(): Promise<boolean>;
    }
}
declare module "engine-components/WebARSessionRoot" {
    import { Behaviour } from "engine-components/Component";
    import { Matrix4, Object3D } from "three";
    import { WebAR } from "engine-components/WebXR";
    export class WebARSessionRoot extends Behaviour {
        webAR: WebAR | null;
        get rig(): Object3D | undefined;
        invertForward: boolean;
        get arScale(): number;
        set arScale(val: number);
        private readonly _initalMatrix;
        private readonly _selectStartFn;
        private readonly _selectEndFn;
        start(): void;
        private _arScale;
        private _rig;
        private _startPose;
        private _placementPose;
        private _isTouching;
        private _rigStartPose;
        onBegin(session: XRSession): void;
        onUpdate(rig: Object3D | null, _session: XRSession, pose: XRPose | null | undefined): boolean;
        placeAt(rig: Object3D | null, mat: Matrix4): void;
        onEnd(rig: Object3D | null, _session: XRSession): void;
        private onSelectStart;
        private onSelectEnd;
        private setScale;
    }
}
declare module "engine-components/XRFlag" {
    import { Behaviour } from "engine-components/Component";
    export enum XRStateFlag {
        Never = 0,
        Browser = 1,
        AR = 2,
        VR = 4,
        FirstPerson = 8,
        ThirdPerson = 16,
        All = 4294967295
    }
    export class XRState {
        static Global: XRState;
        Mask: XRStateFlag;
        Has(state: XRStateFlag): boolean;
        Set(state: number): void;
        Enable(state: number): void;
        Disable(state: number): void;
        Toggle(state: number): void;
        EnableAll(): void;
        DisableAll(): void;
    }
    export class XRFlag extends Behaviour {
        private static registry;
        static Apply(): void;
        private static firstApply;
        private static buffer;
        awake(): void;
        onEnable(): void;
        onDestroy(): void;
        visibleIn: number;
        get isOn(): boolean;
        UpdateVisible(state?: XRState | XRStateFlag | null): void;
    }
}
declare module "engine-schemes/vec4" {
    import * as flatbuffers from 'flatbuffers';
    export class Vec4 {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): Vec4;
        x(): number;
        y(): number;
        z(): number;
        w(): number;
        static sizeOf(): number;
        static createVec4(builder: flatbuffers.Builder, x: number, y: number, z: number, w: number): flatbuffers.Offset;
    }
}
declare module "engine-schemes/vr-user-state-buffer" {
    import * as flatbuffers from 'flatbuffers';
    import { Vec3 } from "engine-schemes/vec3";
    import { Vec4 } from "engine-schemes/vec4";
    export class VrUserStateBuffer {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): VrUserStateBuffer;
        static getRootAsVrUserStateBuffer(bb: flatbuffers.ByteBuffer, obj?: VrUserStateBuffer): VrUserStateBuffer;
        static getSizePrefixedRootAsVrUserStateBuffer(bb: flatbuffers.ByteBuffer, obj?: VrUserStateBuffer): VrUserStateBuffer;
        guid(): string | null;
        guid(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
        time(): flatbuffers.Long;
        avatarId(): string | null;
        avatarId(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
        position(obj?: Vec3): Vec3 | null;
        rotation(obj?: Vec4): Vec4 | null;
        scale(): number;
        posLeftHand(obj?: Vec3): Vec3 | null;
        posRightHand(obj?: Vec3): Vec3 | null;
        rotLeftHand(obj?: Vec4): Vec4 | null;
        rotRightHand(obj?: Vec4): Vec4 | null;
        static startVrUserStateBuffer(builder: flatbuffers.Builder): void;
        static addGuid(builder: flatbuffers.Builder, guidOffset: flatbuffers.Offset): void;
        static addTime(builder: flatbuffers.Builder, time: flatbuffers.Long): void;
        static addAvatarId(builder: flatbuffers.Builder, avatarIdOffset: flatbuffers.Offset): void;
        static addPosition(builder: flatbuffers.Builder, positionOffset: flatbuffers.Offset): void;
        static addRotation(builder: flatbuffers.Builder, rotationOffset: flatbuffers.Offset): void;
        static addScale(builder: flatbuffers.Builder, scale: number): void;
        static addPosLeftHand(builder: flatbuffers.Builder, posLeftHandOffset: flatbuffers.Offset): void;
        static addPosRightHand(builder: flatbuffers.Builder, posRightHandOffset: flatbuffers.Offset): void;
        static addRotLeftHand(builder: flatbuffers.Builder, rotLeftHandOffset: flatbuffers.Offset): void;
        static addRotRightHand(builder: flatbuffers.Builder, rotRightHandOffset: flatbuffers.Offset): void;
        static endVrUserStateBuffer(builder: flatbuffers.Builder): flatbuffers.Offset;
        static finishVrUserStateBufferBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
        static finishSizePrefixedVrUserStateBufferBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
    }
}
declare module "engine-components/WebXRSync" {
    import { Behaviour } from "engine-components/Component";
    import { NetworkConnection } from "engine/engine_networking";
    import { WebXR } from "engine-components/WebXR";
    import { Group, Quaternion, Vector3, Vector4 } from "three";
    import { Builder } from "flatbuffers";
    import { VrUserStateBuffer } from "engine-schemes/vr-user-state-buffer";
    export class VRUserState {
        guid: string;
        time: number;
        avatarId: string;
        position: Vector3;
        rotation: Vector4;
        scale: number;
        posLeftHand: Vector3;
        posRightHand: Vector3;
        rotLeftHand: Quaternion;
        rotRightHand: Quaternion;
        constructor(guid: string);
        private static invertRotation;
        update(rig: Group, pos: DOMPointReadOnly, rot: DOMPointReadOnly, webXR: WebXR, avatarId: string): void;
        private static quat0;
        private static quat1;
        sendAsBuffer(builder: Builder, net: NetworkConnection): void;
        setFromBuffer(guid: string, state: VrUserStateBuffer): void;
    }
    export class WebXRSync extends Behaviour {
        webXR: WebXR | null;
        private debugAvatarUser;
        private voip;
        awake(): Promise<void>;
        onEnable(): void;
        private tempState;
        private onTryGetAvatar;
        onDisable(): void;
        update(): void;
        private _removeAvatarsList;
        private detectPotentiallyDisconnectedAvatarsAndRemove;
        private buildLocalAvatar;
        private eventSub_ConnectionEvent;
        private eventSub_WebXRStartEvent;
        private eventSub_WebXREndEvent;
        private eventSub_WebXRUpdateEvent;
        private avatars;
        private localAvatar;
        private k_LocalAvatarNoNetworkingGuid;
        private onConnected;
        private onXRSessionStart;
        private onXRSessionEnded;
        private ownership;
        private xrState;
        private builder;
        private onXRSessionUpdate;
        private getAvatarId;
    }
}
declare module "engine-components/WebXRAvatar" {
    import { Behaviour } from "engine-components/Component";
    import { WebXR } from "engine-components/WebXR";
    import { XRFlag } from "engine-components/XRFlag";
    import { Context } from "engine/engine_setup";
    import { Object3D } from "three";
    import { VRUserState } from "engine-components/WebXRSync";
    export const debug: string | boolean;
    export type AvatarMarkerEventArgs = {
        avatarMarker: AvatarMarker;
        gameObject: Object3D;
    };
    export class AvatarMarker extends Behaviour {
        static getAvatar(index: number): AvatarMarker | null;
        static instances: AvatarMarker[];
        static onAvatarMarkerCreated(cb: (args: AvatarMarkerEventArgs) => void): Function;
        static onAvatarMarkerDestroyed(cb: (args: AvatarMarkerEventArgs) => void): Function;
        private static _onNewAvatarMarkerAdded;
        private static _onAvatarMarkerDestroyed;
        connectionId: string;
        avatar?: WebXRAvatar | Object3D;
        awake(): void;
        onDestroy(): void;
        isLocalAvatar(): boolean;
        setVisible(visible: boolean): void;
    }
    export class WebXRAvatar {
        private static loader;
        private _isVisible;
        setVisible(visible: boolean): void;
        get isWebXRAvatar(): boolean;
        /** the user id */
        guid: string;
        private root;
        head: Object3D | null;
        handLeft: Object3D | null;
        handRight: Object3D | null;
        lastUpdate: number;
        isLocalAvatar: boolean;
        flags: XRFlag[] | null;
        private headScale;
        private handLeftScale;
        private handRightScale;
        private readonly webxr;
        private lastAvatarId;
        private hasAvatarOverride;
        private context;
        private avatarMarker;
        constructor(context: Context, guid: string, webXR: WebXR);
        updateFlags(): void;
        setAvatarOverride(avatarId: string | null): Promise<boolean | null>;
        private _headTarget;
        private _handLeftTarget;
        private _handRightTarget;
        private _canInterpolate;
        private static invertRotation;
        tryUpdate(state: VRUserState, _timeDiff: number): void;
        update(): void;
        destroy(): void;
        private updateVisibility;
        private setupCustomAvatar;
    }
}
declare module "engine-components/avatar/Avatar_Brain_LookAt" {
    import * as THREE from "three";
    import { Behaviour } from "engine-components/Component";
    import { AvatarMarker } from "engine-components/WebXRAvatar";
    import { Context } from "engine/engine_setup";
    export class Avatar_POI {
        static Pois: {
            obj: THREE.Object3D;
            avatar: AvatarMarker | null;
        }[];
        static LastChangeTime: number;
        static Add(context: Context, obj: THREE.Object3D, ignoredBy?: AvatarMarker | null): void;
        static Remove(context: Context | null, obj: THREE.Object3D | null): void;
    }
    export class Avatar_Brain_LookAt extends Behaviour {
        set controlledTarget(target: THREE.Object3D);
        private target;
        private avatar;
        private _model;
        private _targetModel;
        private _currentTargetObject;
        private _lastUpdateTime;
        private _lookDuration;
        private _lastPoiChangedTime;
        awake(): void;
        update(): void;
        private selectTarget;
    }
}
declare module "engine-components/LookAtConstraint" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export class LookAtConstraint extends Behaviour {
        constraintActive: boolean;
        locked: boolean;
        sources: THREE.Object3D[];
    }
}
declare module "engine-components/OrbitControls" {
    import { Behaviour } from "engine-components/Component";
    import { OrbitControls as ThreeOrbitControls } from "three/examples/jsm/controls/OrbitControls";
    import { LookAtConstraint } from "engine-components/LookAtConstraint";
    import * as THREE from "three";
    export class OrbitControls extends Behaviour {
        get controls(): ThreeOrbitControls | null;
        get controllerObject(): THREE.Object3D | null;
        onStartInteraction(func: Function): void;
        autoRotate: boolean;
        autoRotateSpeed: number;
        enableKeys: boolean;
        enableDamping: boolean;
        dampingFactor: number;
        enableZoom: boolean;
        minZoom: number;
        maxZoom: number;
        enablePan: boolean;
        lookAtConstraint: LookAtConstraint | null;
        lookAtConstraint01: number;
        middleClickToFocus: boolean;
        doubleClickToFocus: boolean;
        useSlerp: boolean;
        debugLog: boolean;
        targetLerpSpeed: number;
        private _lookTargetPosition;
        private _controls;
        private _cameraObject;
        private _lerpToTargetPosition;
        private _lerpCameraToTarget;
        private _cameraTargetPosition;
        private _inputs;
        private _enableTime;
        private _startedListeningToKeyEvents;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        start(): void;
        private startRaycastDelayed;
        onBeforeRender(): void;
        setCameraTarget(position?: THREE.Vector3 | null, immediate?: boolean): void;
        setFromTargetPosition(index?: number, t?: number): boolean;
        setTarget(position?: THREE.Vector3 | null, immediate?: boolean): void;
        lerpTarget(position: THREE.Vector3, delta: number): void;
        distanceToTarget(position: THREE.Vector3): number;
        private setTargetFromRaycast;
    }
}
declare module "engine-components/ui/Raycaster" {
    import { RaycastOptions } from "engine/engine_physics";
    import { Behaviour } from "engine-components/Component";
    export class Raycaster extends Behaviour {
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        performRaycast(_opts?: RaycastOptions | null): THREE.Intersection[] | null;
    }
    export class ObjectRaycaster extends Raycaster {
        private targets;
        private raycastHits;
        start(): void;
        performRaycast(opts?: RaycastOptions | null): THREE.Intersection[] | null;
    }
    export class GraphicRaycaster extends ObjectRaycaster {
    }
}
declare module "engine-components/ui/Interfaces" {
    export interface ICanvasGroup {
        get isCanvasGroup(): boolean;
        blocksRaycasts: boolean;
        interactable: boolean;
    }
    export interface IGraphic {
        get isGraphic(): boolean;
        raycastTarget: boolean;
    }
}
declare module "engine-components/ui/EventSystem" {
    import { Behaviour } from "engine-components/Component";
    import { Context } from "engine/engine_setup";
    import { Raycaster } from "engine-components/ui/Raycaster";
    export class EventSystem extends Behaviour {
        private static _eventSystemMap;
        static didSearchEventSystem: boolean;
        static createIfNoneExists(context: Context): void;
        static get systems(): EventSystem[];
        static ensureUpdateMeshUI(instance: any, context: Context): void;
        static markUIDirty(_context: Context): void;
        static get instance(): EventSystem | null;
        private orbitControl;
        private orbitControlWasEnabled;
        private raycaster;
        constructor();
        onDestroy(): void;
        start(): void;
        register(rc: Raycaster): void;
        unregister(rc: Raycaster): void;
        private _selectStartFn?;
        private _selectEndFn?;
        private _selectUpdateFn?;
        onEnable(): void;
        onDisable(): void;
        onPointerDown(): void;
        private lastPointerEvent;
        private objectsHoveredThisFrame;
        private objectsHoveredLastFrame;
        private raisedPointerDownEvents;
        private raisedPointerDownObjects;
        private _didMove;
        onBeforeUpdate(): void;
        private _tempComponentsArray;
        onBeforeRender(): void;
        private _sortedHits;
        private performRaycast;
        private handleIntersections;
        private _sortingBuffer;
        private _noDepthTestingResults;
        private sortCandidates;
        private handleEventsArray;
        private out;
        private handleEvents;
        private handleMeshUiObjectWithoutShadowDom;
        private currentActiveMeshUIComponents;
        private handleMeshUIIntersection;
        private resetMeshUIStates;
        private testIsVisible;
    }
}
declare module "engine-components/RendererLightmap" {
    import { GameObject } from "engine-components/Component";
    import * as THREE from "three";
    import { Texture } from "three";
    import { Context } from "engine/engine_setup";
    export class RendererLightmap {
        get lightmap(): Texture | null;
        set lightmap(tex: Texture | null);
        lightmapIndex: number;
        lightmapScaleOffset: THREE.Vector4;
        private context;
        private gameObject;
        private lightmapTexture;
        private lightmapScaleOffsetUniform;
        private lightmapUniform;
        private beforeRenderCallback?;
        constructor(gameObject: GameObject, context: Context);
        init(lightmapIndex: number, lightmapScaleOffset: THREE.Vector4, lightmapTexture: THREE.Texture, debug?: boolean): void;
        bindOnBeforeRender(): void;
        private onBeforeRenderThreeComplete;
        private setupLightmap;
        onBeforeRenderThree(material: THREE.Material): void;
        private setLightmapDebugMaterial;
    }
}
declare module "engine-components/ReflectionProbe" {
    import { Behaviour } from "engine-components/Component";
    import { Object3D, Texture, Vector3 } from "three";
    import { Context } from "engine/engine_setup";
    import { IRenderer } from "engine/engine_types";
    export const debug: string | boolean;
    export class ReflectionProbe extends Behaviour {
        private static _probes;
        static get(object: Object3D | null | undefined, context: Context, isAnchor: boolean): ReflectionProbe | null;
        private _texture;
        set texture(tex: Texture);
        get texture(): Texture;
        center?: Vector3;
        size?: Vector3;
        private _boxHelper?;
        private isInBox;
        constructor();
        awake(): void;
        onDestroy(): void;
        private static _rendererMaterialsCache;
        onSet(_rend: IRenderer): void;
        onUnset(_rend: IRenderer): void;
    }
}
declare module "engine/js-extensions/Layers" {
    import { Object3D } from "three";
    export function setCustomVisibility(obj: Object3D, visible: boolean): void;
    export function patchLayers(): void;
}
declare module "engine-components/Renderer" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { Mesh, Object3D, Texture } from "three";
    import { IRenderer, ISharedMaterials } from "engine/engine_types";
    export { InstancingUtil } from "engine/engine_instancing";
    export enum ReflectionProbeUsage {
        Off = 0,
        BlendProbes = 1,
        BlendProbesAndSkybox = 2,
        Simple = 3
    }
    export class FieldWithDefault {
        path: string | null;
        asset: object | null;
        default: any;
    }
    export enum RenderState {
        Both = 0,
        Back = 1,
        Front = 2
    }
    class SharedMaterialArray implements ISharedMaterials {
        [num: number]: THREE.Material;
        private _renderer;
        private _targets;
        is(renderer: Renderer): boolean;
        constructor(renderer: Renderer);
        get length(): number;
        private setMaterial;
        private getMaterial;
    }
    export class Renderer extends Behaviour implements IRenderer {
        /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
         *
         * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
        static setVisible(obj: Object3D, visible: boolean): void;
        receiveShadows: boolean;
        shadowCastingMode: ShadowCastingMode;
        lightmapIndex: number;
        lightmapScaleOffset: THREE.Vector4;
        enableInstancing: boolean[] | undefined;
        renderOrder: number[] | undefined;
        allowOcclusionWhenDynamic: boolean;
        probeAnchor?: Object3D;
        reflectionProbeUsage: ReflectionProbeUsage;
        private _lightmaps?;
        get sharedMesh(): Mesh | undefined;
        get sharedMaterial(): THREE.Material;
        set sharedMaterial(mat: THREE.Material);
        /**@deprecated please use sharedMaterial */
        get material(): THREE.Material;
        /**@deprecated please use sharedMaterial */
        set material(mat: THREE.Material);
        private _sharedMaterials;
        get sharedMaterials(): SharedMaterialArray;
        static get shouldSuppressInstancing(): string | boolean;
        private _lightmapTextureOverride;
        get lightmap(): Texture | null;
        set lightmap(tex: Texture | null | undefined);
        get hasLightmap(): boolean;
        allowProgressiveLoading: boolean;
        awake(): void;
        private _isInstancingEnabled;
        private handles;
        private prevLayers;
        private clearInstancingState;
        setInstancingEnabled(enabled: boolean): boolean;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        applyStencil(): void;
        static envmap: THREE.Texture | null;
        onBeforeRender(): void;
        onBeforeRenderThree(_renderer: any, _scene: any, _camera: any, _geometry: any, material: any, _group: any): void;
        onAfterRender(): void;
        private applySettings;
        private _reflectionProbe;
        private updateReflectionProbe;
        private _updateReflectionProbe;
        private setVisibility;
        private isMultiMaterialObject;
        private isMeshOrSkinnedMesh;
    }
    export class MeshRenderer extends Renderer {
    }
    export class SkinnedMeshRenderer extends MeshRenderer {
        awake(): void;
    }
    export enum ShadowCastingMode {
        Off = 0,
        On = 1,
        TwoSided = 2,
        ShadowsOnly = 3
    }
}
declare module "engine-components/ui/BaseUIComponent" {
    import * as ThreeMeshUI from 'three-mesh-ui';
    import { Behaviour } from "engine-components/Component";
    export const includesDir = "./include";
    export const $shadowDomOwner: unique symbol;
    export class BaseUIComponent extends Behaviour {
        isRoot(): boolean;
        markDirty(): void;
        shadowComponent: ThreeMeshUI.Block | null;
        private _controlsChildLayout;
        get controlsChildLayout(): boolean;
        set controlsChildLayout(val: boolean);
        private _root?;
        protected get Root(): UIRootComponent | null;
        protected _parentComponent?: BaseUIComponent | null;
        onEnable(): void;
        protected addShadowComponent(container: any, parent?: BaseUIComponent): void;
        set(_state: object): void;
        private traverseOwnedShadowComponents;
        protected removeShadowComponent(): void;
        protected onAfterAddedToScene(): void;
        setInteractable(value: boolean): void;
    }
    export class UIRootComponent extends BaseUIComponent {
        awake(): void;
    }
}
declare module "engine-components/ui/RaycastUtils" {
    import { ICanvasGroup, IGraphic } from "engine-components/ui/Interfaces";
    import { Object3D } from "three";
    export class UIRaycastUtils {
        /** returns the real object when dealing with shadow UI */
        static getObject(obj: Object3D): Object3D;
        static isInteractable(obj: THREE.Object3D, out?: {
            canvasGroup?: ICanvasGroup;
            graphic?: IGraphic;
        }): boolean;
        private static tryFindCanvasGroup;
    }
}
declare module "engine-components/WebXRController" {
    import { Group, Intersection, Mesh, Object3D, Quaternion, Ray, Vector3 } from "three";
    import { OculusHandPointerModel } from 'three/examples/jsm/webxr/OculusHandPointerModel.js';
    import { XRControllerModel, XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';
    import { Behaviour, GameObject } from "engine-components/Component";
    import { SyncedTransform } from "engine-components/SyncedTransform";
    import { WebXR } from "engine-components/WebXR";
    export enum ControllerType {
        PhysicalDevice = 0,
        Touch = 1
    }
    export enum ControllerEvents {
        SelectStart = "select-start",
        SelectEnd = "select-end",
        Update = "update"
    }
    export class TeleportTarget extends Behaviour {
    }
    export class WebXRController extends Behaviour {
        static Factory: XRControllerModelFactory;
        private static raycastColor;
        private static raycastNoHitColor;
        private static geometry;
        private static handModels;
        private static CreateRaycastLine;
        private static CreateRaycastHitPoint;
        static Create(owner: WebXR, index: number, addTo: GameObject, type: ControllerType): WebXRController;
        static addEventListener(evt: ControllerEvents, callback: (controller: WebXRController, args: any) => void): void;
        static removeEventListener(evt: ControllerEvents, callback: (controller: WebXRController, args: any) => void): void;
        private static eventSubs;
        webXR: WebXR;
        index: number;
        controllerModel: XRControllerModel;
        controller: Group;
        controllerGrip: Group;
        hand: Group;
        handPointerModel: OculusHandPointerModel;
        grabbed: AttachedObject | null;
        input: XRInputSource | null;
        type: ControllerType;
        showRaycastLine: boolean;
        get isUsingHands(): boolean;
        get wrist(): Object3D | null;
        private _wristQuaternion;
        getWristQuaternion(): Quaternion | null;
        private movementVector;
        private worldRot;
        private joystick;
        private didRotate;
        private didTeleport;
        private didChangeScale;
        private static PreviousCameraFarDistance;
        private static MovementSpeedFactor;
        private lastHit;
        private raycastLine;
        private _raycastHitPoint;
        private _connnectedCallback;
        private _disconnectedCallback;
        private _selectStartEvt;
        private _selectEndEvt;
        get selectionDown(): boolean;
        get selectionUp(): boolean;
        get selectionPressed(): boolean;
        get selectionClick(): boolean;
        get raycastHitPoint(): Object3D | null;
        private _selectionPressed;
        private _selectionPressedLastFrame;
        private _selectionStartTime;
        private _selectionEndTime;
        get useSmoothing(): boolean;
        private _useSmoothing;
        awake(): void;
        onDestroy(): void;
        onEnable(): void;
        onDisable(): void;
        private _isConnected;
        private onSourceConnected;
        private onSourceDisconnected;
        private createPointerEvent;
        rayRotation: Quaternion;
        update(): void;
        private _pinchStartTime;
        onUpdate(session: XRSession): void;
        private runTeleport;
        private isValidTeleportTarget;
        private updateStick;
        private updateLastHit;
        private onSelectStart;
        private selectStartCallback;
        private lastSelectStartObject;
        private onHandleSelectStart;
        private _didNotEndSelection;
        private onSelectEnd;
        private testIsVisible;
        private setControllerLayers;
        getRay(): Ray;
        private closeGrabBoundingBoxHelper?;
        overlap(): Intersection[];
        raycast(): Intersection[];
    }
    export enum AttachedObjectEvents {
        WillTake = "WillTake",
        DidTake = "DidTake",
        WillFree = "WillFree",
        DidFree = "DidFree"
    }
    export class AttachedObject {
        static Events: {
            [key: string]: Function[];
        };
        static AddEventListener(event: AttachedObjectEvents, callback: Function): Function;
        static RemoveEventListener(event: AttachedObjectEvents, callback: Function | null): void;
        static Current: AttachedObject[];
        private static Register;
        private static Remove;
        static TryTake(controller: WebXRController, candidate: Object3D, intersection: Intersection, closeGrab: boolean): AttachedObject | null;
        sync: SyncedTransform | null;
        selected: Object3D | null;
        selectedParent: Object3D | null;
        selectedMesh: Mesh | null;
        controller: WebXRController | null;
        grabTime: number;
        grabUUID: string;
        isCloseGrab: boolean;
        private originalMaterial;
        private usageMarker;
        private rigidbodies;
        private didReparent;
        private grabDistance;
        private interactable;
        private positionSource;
        private Take;
        free(): void;
        grabPoint: Vector3;
        private localPositionOffsetToGrab;
        private localPositionOffsetToGrab_worldSpace;
        private localQuaternionToGrab;
        private targetDir;
        private quaternionLerp;
        private controllerDir;
        private controllerWorldPos;
        private lastControllerWorldPos;
        private controllerPosDelta;
        private totalChangeAlongDirection;
        private rigPositionLastFrame;
        private controllerMovementSinceLastFrame;
        update(): void;
    }
}
declare module "engine-components/Gizmos" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export class BoxGizmo extends Behaviour {
        objectBounds: boolean;
        color?: THREE.Color;
        isGizmo: boolean;
        private _gizmoObject;
        private _boxHelper;
        onEnable(): void;
        onDisable(): void;
        private syncObjectBounds;
    }
}
declare module "engine-components/WebXRRig" {
    import { Behaviour } from "engine-components/Component";
    export class XRRig extends Behaviour {
        awake(): void;
    }
}
declare module "engine-components/WebXR" {
    import { Object3D, Quaternion } from 'three';
    import { AssetReference } from "engine/engine_addressables";
    import { Behaviour } from "engine-components/Component";
    import { WebXRController } from "engine-components/WebXRController";
    export function detectARSupport(): Promise<boolean>;
    export function detectVRSupport(): Promise<boolean>;
    export enum WebXREvent {
        XRStarted = "xrStarted",
        XRStopped = "xrStopped",
        XRUpdate = "xrUpdate",
        RequestVRSession = "requestVRSession"
    }
    export type CreateButtonOptions = {
        registerClick: boolean;
    };
    export class WebXR extends Behaviour {
        enableVR: boolean;
        enableAR: boolean;
        defaultAvatar?: AssetReference;
        handModelPath: string;
        createVRButton: boolean;
        createARButton: boolean;
        private static _isInXr;
        private static events;
        static get IsInWebXR(): boolean;
        static get XRSupported(): boolean;
        static get IsARSupported(): boolean;
        static get IsVRSupported(): boolean;
        static addEventListener(type: string, listener: any): any;
        static removeEventListener(type: string, listener: any): any;
        static createVRButton(webXR: WebXR, opts?: CreateButtonOptions): HTMLButtonElement;
        static createARButton(webXR: WebXR, opts?: CreateButtonOptions): HTMLButtonElement;
        static resetButtonStyles(button: any): void;
        endSession(): void;
        get Rig(): Object3D;
        private controllers;
        get Controllers(): WebXRController[];
        get LeftController(): WebXRController | null;
        get RightController(): WebXRController | null;
        get ARButton(): HTMLButtonElement | undefined;
        get VRButton(): HTMLButtonElement | undefined;
        get IsInVR(): boolean;
        get IsInAR(): boolean;
        private rig;
        private isInit;
        private _requestedAR;
        private _requestedVR;
        private _isInAR;
        private _isInVR;
        private _arButton?;
        private _vrButton?;
        private webAR;
        awake(): void;
        onEnable(): void;
        private _transformOrientation;
        get TransformOrientation(): Quaternion;
        private _currentHeadPose;
        get HeadPose(): XRViewerPose | null;
        onBeforeRender(frame: any): void;
        private onClickedARButton;
        private onClickedVRButton;
        private captureStateBeforeXR;
        private ensureRig;
        private _originalCameraParent;
        private _originalCameraPosition;
        private _originalCameraRotation;
        private _originalXRRigParent;
        private _originalXRRigPosition;
        private _originalXRRigRotation;
        private onEnterXR;
        private onExitXR;
        private onEnterVR;
        private destroyControllers;
        private xrMirrorWindow;
        private onEnterXR_HandleMirrorWindow;
    }
    export class WebAR {
        get webxr(): WebXR;
        private _webxr;
        private reticle;
        private reticleParent;
        private hitTestSource;
        private reticleActive;
        private previousBackground;
        private previousEnvironment;
        private sessionRoot;
        private _previousParent;
        private static tempWebXRObject;
        private get context();
        constructor(webxr: WebXR);
        private arDomOverlay;
        private arOverlayElement;
        private noHitTestAvailable;
        private didPlaceARSessionRoot;
        getAROverlayContainer(): HTMLElement | null;
        setReticleActive(active: boolean): void;
        onBegin(session: XRSession): Promise<void>;
        onEnd(session: XRSession): void;
        onUpdate(session: XRSession, frame: XRFrame): void;
    }
}
declare module "engine-components/DragControls" {
    import { GameObject } from "engine-components/Component";
    import * as THREE from "three";
    import { IPointerDownHandler, IPointerEnterHandler, IPointerExitHandler, IPointerUpHandler, PointerEventData } from "engine-components/ui/PointerEvents";
    import { Interactable } from "engine-components/Interactable";
    export enum DragEvents {
        SelectStart = "selectstart",
        SelectEnd = "selectend"
    }
    interface SelectArgs {
        selected: THREE.Object3D;
        attached: THREE.Object3D | GameObject | null;
    }
    export interface IDragEventListener {
        onDragStart?(): any;
        onDragEnd?(): any;
    }
    export class DragControls extends Interactable implements IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler {
        private static _active;
        static get HasAnySelected(): boolean;
        transformSelf: boolean;
        private orbit;
        private selectStartEventListener;
        private selectEndEventListener;
        constructor();
        addDragEventListener(type: DragEvents, cb: (ctrls: DragControls, args: SelectArgs) => void | Function): void;
        private _dragHelper;
        start(): void;
        private static lastHovered;
        private _draggingRigidbodies;
        private allowEdit;
        onPointerEnter(evt: PointerEventData): void;
        onPointerExit(evt: PointerEventData): void;
        private _waitingForDragStart;
        onPointerDown(args: PointerEventData): void;
        onPointerUp(args: PointerEventData): void;
        update(): void;
        private _isDragging;
        private _marker;
        private _dragDelta;
        private _didDrag;
        private onDragStart;
        private onUpdateDrag;
        private onDragEnd;
    }
}
declare module "engine-components/Networking" {
    import { INetworkingWebsocketUrlProvider } from "engine/engine_networking";
    import { Behaviour } from "engine-components/Component";
    export class Networking extends Behaviour implements INetworkingWebsocketUrlProvider {
        url: string | null;
        urlParameterName: string | null;
        localhost: string | null;
        awake(): void;
        getWebsocketUrl(): string | null;
        static GetUrl(url: string, localhostFallback?: string | null): string;
        static IsLocalNetwork(hostname?: string): boolean;
    }
}
declare module "engine-components/DropListener" {
    import { Behaviour } from "engine-components/Component";
    export enum DropListenerEvents {
        ObjectAdded = "object-added"
    }
    export class DropListener extends Behaviour {
        filesBackendUrl?: string;
        localhost?: string;
        private _dragOver;
        private _drop;
        onEnable(): void;
        onDisable(): void;
        private onDrag;
        private onDrop;
        private addObject;
    }
}
declare module "engine-components/Duplicatable" {
    import { GameObject } from "engine-components/Component";
    import { Interactable } from "engine-components/Interactable";
    export class Duplicatable extends Interactable {
        parent: GameObject | null;
        object: GameObject | null;
        limitCount: number;
        limitInterval: number;
        private _currentCount;
        private _startPosition;
        private _startQuaternion;
        awake(): void;
        private cloneLimitIntervalFn;
        private handleDuplication;
        private handleMultiObject;
        private isInChildren;
    }
}
declare module "engine-components/EventType" {
    export enum EventType {
        PointerEnter = 0,
        PointerExit = 1,
        PointerDown = 2,
        PointerUp = 3,
        PointerClick = 4,
        Drag = 5,
        Drop = 6,
        Scroll = 7,
        UpdateSelected = 8,
        Select = 9,
        Deselect = 10,
        Move = 11,
        InitializePotentialDrag = 12,
        BeginDrag = 13,
        EndDrag = 14,
        Submit = 15,
        Cancel = 16
    }
}
declare module "engine-components/EventTrigger" {
    import { IPointerEventHandler, PointerEventData } from "engine-components/ui/PointerEvents";
    import { Behaviour } from "engine-components/Component";
    import { EventType } from "engine-components/EventType";
    export class EventTrigger extends Behaviour implements IPointerEventHandler {
        private triggers?;
        invoke(type: EventType): void;
        onPointerClick(_: PointerEventData): void;
        onPointerEnter(_: PointerEventData): void;
        onPointerExit(_: PointerEventData): void;
        onPointerDown(_: PointerEventData): void;
        onPointerUp(_: PointerEventData): void;
    }
}
declare module "engine-components/FlyControls" {
    import { Behaviour } from "engine-components/Component";
    export class FlyControls extends Behaviour {
        private _controls;
        onEnable(): void;
        onDisable(): void;
        update(): void;
    }
}
declare module "engine-components/GridHelper" {
    import { Behaviour } from "engine-components/Component";
    export class GridHelper extends Behaviour {
        isGizmo: boolean;
        private color0;
        private color1;
        private gridHelper;
        private size;
        private divisions;
        private offset;
        onEnable(): void;
    }
}
declare module "engine-components/GroundProjection" {
    import { Behaviour } from "engine-components/Component";
    export class GroundProjectedEnv extends Behaviour {
        set scale(val: number);
        get scale(): number;
        private _scale;
        set radius(val: number);
        get radius(): number;
        private _radius;
        set height(val: number);
        get height(): number;
        private _height;
        private _lastEnvironment?;
        private env?;
        private _watcher?;
        onEnable(): void;
        start(): void;
        onDisable(): void;
        private updateAndCreate;
        updateProjection(): void;
    }
}
declare module "engine-components/Joints" {
    import { Vector3 } from "three";
    import { Behaviour } from "engine-components/Component";
    import { Rigidbody } from "engine-components/RigidBody";
    export abstract class Joint extends Behaviour {
        connectedBody?: Rigidbody;
        get rigidBody(): Rigidbody | null;
        private _rigidBody;
        onEnable(): void;
        private create;
        protected abstract createJoint(self: Rigidbody, other: Rigidbody): any;
    }
    export class FixedJoint extends Joint {
        protected createJoint(self: Rigidbody, other: Rigidbody): void;
    }
    export class HingeJoint extends Joint {
        anchor?: Vector3;
        axis?: Vector3;
        protected createJoint(self: Rigidbody, other: Rigidbody): void;
    }
}
declare module "engine-components/Light" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { ILight } from "engine/engine_types";
    export enum LightType {
        Spot = 0,
        Directional = 1,
        Point = 2,
        Area = 3,
        Rectangle = 3,
        Disc = 4
    }
    export enum LightmapBakeType {
        Realtime = 4,
        Baked = 2,
        Mixed = 1
    }
    enum LightShadows {
        None = 0,
        Hard = 1,
        Soft = 2
    }
    export class Light extends Behaviour implements ILight {
        private type;
        range: number;
        spotAngle: number;
        innerSpotAngle: number;
        color: THREE.Color;
        set shadowNearPlane(val: number);
        get shadowNearPlane(): number;
        private _shadowNearPlane;
        set shadowBias(val: number);
        get shadowBias(): number;
        private _shadowBias;
        set shadowNormalBias(val: number);
        get shadowNormalBias(): number;
        private _shadowNormalBias;
        /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
        private _overrideShadowBiasSettings;
        set shadows(val: LightShadows);
        get shadows(): LightShadows;
        private _shadows;
        private lightmapBakeType;
        set intensity(val: number);
        get intensity(): number;
        private _intensity;
        get shadowDistance(): number;
        set shadowDistance(val: number);
        private _shadowDistance?;
        private shadowWidth?;
        private shadowHeight?;
        get shadowResolution(): number;
        set shadowResolution(val: number);
        private _shadowResolution?;
        get isBaked(): boolean;
        private get selfIsLight();
        private light;
        getWorldPosition(vec: THREE.Vector3): THREE.Vector3;
        updateIntensity(): void;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        private _webXRStartedListener?;
        private _webXREndedListener?;
        private _webARRoot?;
        private onWebXRStarted;
        private _updateLightIntensityInARRoutine;
        private onWebXREnded;
        createLight(): void;
        updateMainLightRoutine(): Generator<undefined, void, unknown>;
        static allowChangingRendererShadowMapType: boolean;
        private updateShadowSoftHard;
        private setDirectionalLight;
    }
}
declare module "engine-components/LODGroup" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    enum LODFadeMode {
        None = 0,
        CrossFade = 1,
        SpeedTree = 2
    }
    export class LODModel {
        screenRelativeTransitionHeight: number;
        distance: number;
        renderers: string[];
    }
    export class LODGroup extends Behaviour {
        fadeMode: LODFadeMode;
        localReferencePoint: THREE.Vector3 | undefined;
        lodCount: number;
        size: number;
        animateCrossFading: boolean;
        lodModels?: LODModel[];
        private _lods;
        private _settings;
        private _lodsHandler?;
        start(): void;
        update(): void;
        private onAddLodLevel;
        private _distanceFactor;
        distanceFactor(factor: number): void;
    }
}
declare module "engine-components/NestedGltf" {
    import { Behaviour } from "engine-components/Component";
    import { AssetReference, ProgressCallback } from "engine/engine_addressables";
    export class NestedGltf extends Behaviour {
        filePath?: AssetReference;
        private _isLoadingOrDoneLoading;
        listenToProgress(evt: ProgressCallback): void;
        preload(): void;
        start(): Promise<void>;
        hash(str: string): number;
    }
}
declare module "engine-components/OffsetConstraint" {
    import { Behaviour } from "engine-components/Component";
    export class OffsetConstraint extends Behaviour {
        private referenceSpace;
        private from;
        private affectPosition;
        private affectRotation;
        private alignLookDirection;
        private levelLookDirection;
        private levelPosition;
        private positionOffset;
        private rotationOffset;
        private offset;
        update(): void;
    }
}
declare module "engine-components/ParticleSystemModules" {
    import { Matrix4, Object3D, Quaternion, Vector3, Vector2, Vector4 } from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { AnimationCurve } from "engine-components/AnimationCurve";
    import { Vec2, Vec3 } from "engine/engine_types";
    import { Context } from "engine/engine_setup";
    import { EmitterShape, Particle, ShapeJSON } from "three.quarks";
    type Color4 = {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    type ColorKey = {
        time: number;
        color: Color4;
    };
    type AlphaKey = {
        time: number;
        alpha: number;
    };
    export interface IParticleSystem {
        get currentParticles(): number;
        get maxParticles(): number;
        get time(): number;
        get deltaTime(): number;
        get duration(): number;
        readonly main: MainModule;
        get container(): Object3D;
        get worldspace(): boolean;
        get worldPos(): Vector3;
        get worldQuaternion(): Quaternion;
        get worldQuaternionInverted(): Quaternion;
        get worldScale(): Vector3;
        get matrixWorld(): Matrix4;
    }
    export enum ParticleSystemRenderMode {
        Billboard = 0,
        Mesh = 4
    }
    export class Gradient {
        alphaKeys: Array<AlphaKey>;
        colorKeys: Array<ColorKey>;
        get duration(): number;
        evaluate(time: number, target: RGBAColor): RGBAColor;
    }
    export enum ParticleSystemCurveMode {
        Constant = 0,
        Curve = 1,
        TwoCurves = 2,
        TwoConstants = 3
    }
    export enum ParticleSystemGradientMode {
        Color = 0,
        Gradient = 1,
        TwoColors = 2,
        TwoGradients = 3,
        RandomColor = 4
    }
    export enum ParticleSystemSimulationSpace {
        Local = 0,
        World = 1,
        Custom = 2
    }
    export enum ParticleSystemShapeType {
        Sphere = 0,
        SphereShell = 1,
        Hemisphere = 2,
        HemisphereShell = 3,
        Cone = 4,
        Box = 5,
        Mesh = 6,
        ConeShell = 7,
        ConeVolume = 8,
        ConeVolumeShell = 9,
        Circle = 10,
        CircleEdge = 11,
        SingleSidedEdge = 12,
        MeshRenderer = 13,
        SkinnedMeshRenderer = 14,
        BoxShell = 15,
        BoxEdge = 16,
        Donut = 17,
        Rectangle = 18,
        Sprite = 19,
        SpriteRenderer = 20
    }
    export enum ParticleSystemShapeMultiModeValue {
        Random = 0,
        Loop = 1,
        PingPong = 2,
        BurstSpread = 3
    }
    export class MinMaxCurve {
        mode: ParticleSystemCurveMode;
        constant: number;
        constantMin: number;
        constantMax: number;
        curve?: AnimationCurve;
        curveMin?: AnimationCurve;
        curveMax?: AnimationCurve;
        curveMultiplier?: number;
        evaluate(t01: number, lerpFactor?: number): number;
    }
    export class MinMaxGradient {
        mode: ParticleSystemGradientMode;
        color: RGBAColor;
        colorMin: RGBAColor;
        colorMax: RGBAColor;
        gradient: Gradient;
        gradientMin: Gradient;
        gradientMax: Gradient;
        private static _temp;
        private static _temp2;
        evaluate(t01: number, lerpFactor?: number): RGBAColor;
    }
    type ParticleSystemScalingMode = {
        Hierarchy: number;
        Local: number;
        Shape: number;
    };
    export class MainModule {
        cullingMode: number;
        duration: number;
        emitterVelocityMode: number;
        flipRotation: number;
        gravityModifier: MinMaxCurve;
        gravityModifierMultiplier: number;
        loop: boolean;
        maxParticles: number;
        playOnAwake: boolean;
        prewarm: boolean;
        ringBufferLoopRange: {
            x: number;
            y: number;
        };
        ringBufferMode: boolean;
        scalingMode: ParticleSystemScalingMode;
        simulationSpace: ParticleSystemSimulationSpace;
        simulationSpeed: number;
        startColor: MinMaxGradient;
        startDelay: MinMaxCurve;
        startDelayMultiplier: number;
        startLifetime: MinMaxCurve;
        startLifetimeMultiplier: number;
        startRotation: MinMaxCurve;
        startRotationMultiplier: number;
        startRotation3D: boolean;
        startRotationX: MinMaxCurve;
        startRotationXMultiplier: number;
        startRotationY: MinMaxCurve;
        startRotationYMultiplier: number;
        startRotationZ: MinMaxCurve;
        startRotationZMultiplier: number;
        startSize: MinMaxCurve;
        startSize3D: boolean;
        startSizeMultiplier: number;
        startSizeX: MinMaxCurve;
        startSizeXMultiplier: number;
        startSizeY: MinMaxCurve;
        startSizeYMultiplier: number;
        startSizeZ: MinMaxCurve;
        startSizeZMultiplier: number;
        startSpeed: MinMaxCurve;
        startSpeedMultiplier: number;
        stopAction: number;
        useUnscaledTime: boolean;
    }
    export class ParticleBurst {
        cycleCount: number;
        maxCount: number;
        minCount: number;
        probability: number;
        repeatInterval: number;
        time: number;
        count: {
            constant: number;
            constantMax: number;
            constantMin: number;
            curve?: AnimationCurve;
            curveMax?: AnimationCurve;
            curveMin?: AnimationCurve;
            curveMultiplier?: number;
            mode: ParticleSystemCurveMode;
        };
        private _performed;
        reset(): void;
        run(time: number): number;
    }
    export class EmissionModule {
        enabled: boolean;
        get burstCount(): number;
        bursts: ParticleBurst[];
        rateOverTime: MinMaxCurve;
        rateOverTimeMultiplier: number;
        rateOverDistance: MinMaxCurve;
        rateOverDistanceMultiplier: number;
        /** set from system */
        system: IParticleSystem;
        reset(): void;
        getBurst(): number;
    }
    export class ColorOverLifetimeModule {
        enabled: boolean;
        color: MinMaxGradient;
    }
    export class SizeOverLifetimeModule {
        enabled: boolean;
        separateAxes: boolean;
        size: MinMaxCurve;
        sizeMultiplier: number;
        x: MinMaxCurve;
        xMultiplier: number;
        y: MinMaxCurve;
        yMultiplier: number;
        z: MinMaxCurve;
        zMultiplier: number;
        private _time;
        private _temp;
        evaluate(t01: number, target?: Vec3, lerpFactor?: number): Vec3;
    }
    export class ShapeModule implements EmitterShape {
        get type(): string;
        initialize(particle: Particle): void;
        toJSON(): ShapeJSON;
        clone(): EmitterShape;
        shapeType: ParticleSystemShapeType;
        enabled: boolean;
        alignToDirection: boolean;
        angle: number;
        arc: number;
        arcSpread: number;
        arcSpeedMultiplier: number;
        arcMode: ParticleSystemShapeMultiModeValue;
        boxThickness: Vector3;
        position: Vector3;
        rotation: Vector3;
        private _rotation;
        scale: Vector3;
        radius: number;
        radiusThickness: number;
        sphericalDirectionAmount: number;
        randomDirectionAmount: number;
        randomPositionAmount: number;
        private system;
        private _space?;
        private readonly _worldSpaceMatrix;
        private readonly _worldSpaceMatrixInverse;
        constructor();
        update(system: IParticleSystem, _context: Context, simulationSpace: ParticleSystemSimulationSpace, obj: Object3D): void;
        /** nebula implementations: */
        /** initializer implementation */
        private _vector;
        private _temp;
        /** called by nebula on initialize */
        get vector(): Vector3;
        getPosition(): void;
        private _dir;
        getDirection(position: any): Vector3;
        private static _randomQuat;
        private static _tempVec;
        private randomizePosition;
        private randomizeDirection;
        private spherizeDirection;
        private randomSpherePoint;
        private _loopTime;
        private _loopDirection;
        private randomConePoint;
    }
    export class NoiseModule {
        damping: boolean;
        enabled: boolean;
        frequency: number;
        octaveCount: number;
        octaveMultiplier: number;
        octaveScale: number;
        positionAmount: MinMaxCurve;
        quality: number;
        remap: MinMaxCurve;
        remapEnabled: boolean;
        remapMultiplier: number;
        remapX: MinMaxCurve;
        remapXMultiplier: number;
        remapY: MinMaxCurve;
        remapYMultiplier: number;
        remapZ: MinMaxCurve;
        remapZMultiplier: number;
        scrollSpeedMultiplier: number;
        separateAxes: boolean;
        strengthMultiplier: number;
        strengthX: MinMaxCurve;
        strengthXMultiplier: number;
        strengthY: MinMaxCurve;
        strengthYMultiplier: number;
        strengthZ: MinMaxCurve;
        strengthZMultiplier: number;
        private _noise?;
        private _time;
        update(context: Context): void;
        /** nebula implementations: */
        private _temp;
        apply(_index: number, pos: Vec3, vel: Vec3, _deltaTime: number, age: number, life: number): void;
    }
    export enum ParticleSystemTrailMode {
        PerParticle = 0,
        Ribbon = 1
    }
    export enum ParticleSystemTrailTextureMode {
        Stretch = 0,
        Tile = 1,
        DistributePerSegment = 2,
        RepeatPerSegment = 3
    }
    export class TrailModule {
        enabled: boolean;
        attachRibbonToTransform: boolean;
        colorOverLifetime: MinMaxGradient;
        colorOverTrail: MinMaxGradient;
        dieWithParticles: boolean;
        inheritParticleColor: boolean;
        lifetime: MinMaxCurve;
        lifetimeMultiplier: number;
        minVertexDistance: number;
        mode: ParticleSystemTrailMode;
        ratio: number;
        ribbonCount: number;
        shadowBias: number;
        sizeAffectsLifetime: boolean;
        sizeAffectsWidth: boolean;
        splitSubEmitterRibbons: boolean;
        textureMode: ParticleSystemTrailTextureMode;
        widthOverTrail: MinMaxCurve;
        widthOverTrailMultiplier: number;
        worldSpace: boolean;
        getWidth(size: number, _life01: number, pos01: number): number;
        getColor(color: Vector4, life01: number, pos01: number): void;
    }
    export class VelocityOverLifetimeModule {
        enabled: boolean;
        space: ParticleSystemSimulationSpace;
        speedModifier: MinMaxCurve;
        speedModifierMultiplier: number;
        x: MinMaxCurve;
        xMultiplier: number;
        y: MinMaxCurve;
        yMultiplier: number;
        z: MinMaxCurve;
        zMultiplier: number;
        private _system?;
        update(system: IParticleSystem): void;
        private _temp;
        apply(_index: number, _pos: Vec3, vel: Vec3, _dt: number, age: number, life: number): void;
    }
    enum ParticleSystemAnimationTimeMode {
        Lifetime = 0,
        Speed = 1,
        FPS = 2
    }
    enum ParticleSystemAnimationRowMode {
        Custom = 0,
        Random = 1,
        MeshIndex = 2
    }
    enum ParticleSystemAnimationType {
        WholeSheet = 0,
        SingleRow = 1
    }
    export class TextureSheetAnimationModule {
        animation: ParticleSystemAnimationType;
        enabled: boolean;
        cycleCount: number;
        frameOverTime: MinMaxCurve;
        frameOverTimeMultiplier: number;
        numTilesX: number;
        numTilesY: number;
        startFrame: MinMaxCurve;
        startFrameMultiplier: number;
        rowMode: ParticleSystemAnimationRowMode;
        rowIndex: number;
        spriteCount: number;
        timeMode: ParticleSystemAnimationTimeMode;
        private sampleOnceAtStart;
        getStartIndex(): number;
        evaluate(t01: number): number | undefined;
        private getIndex;
    }
    export class RotationOverLifetimeModule {
        enabled: boolean;
        separateAxes: boolean;
        x: MinMaxCurve;
        xMultiplier: number;
        y: MinMaxCurve;
        yMultiplier: number;
        z: MinMaxCurve;
        zMultiplier: number;
        evaluate(t01: number): number;
    }
    export class RotationBySpeedModule {
        enabled: boolean;
        range: Vec2;
        separateAxes: boolean;
        x: MinMaxCurve;
        xMultiplier: number;
        y: MinMaxCurve;
        yMultiplier: number;
        z: MinMaxCurve;
        zMultiplier: number;
        evaluate(_t01: number, speed: number): number;
    }
    export class LimitVelocityOverLifetimeModule {
        enabled: boolean;
        dampen: number;
        drag: MinMaxCurve;
        dragMultiplier: number;
        limit: MinMaxCurve;
        limitMultiplier: number;
        separateAxes: boolean;
        limitX: MinMaxCurve;
        limitXMultiplier: number;
        limitY: MinMaxCurve;
        limitYMultiplier: number;
        limitZ: MinMaxCurve;
        limitZMultiplier: number;
        multiplyDragByParticleSize: boolean;
        multiplyDragByParticleVelocity: boolean;
        space: ParticleSystemSimulationSpace;
        private _temp;
        private _temp2;
        apply(_position: Vec3, baseVelocity: Vector3, currentVelocity: Vector3, _size: number, t01: number, _dt: number, _scale: number): void;
    }
    export enum ParticleSystemInheritVelocityMode {
        Initial = 0,
        Current = 1
    }
    export class InheritVelocityModule {
        enabled: boolean;
        curve: MinMaxCurve;
        curveMultiplier: number;
        mode: ParticleSystemInheritVelocityMode;
        system: IParticleSystem;
        private _lastWorldPosition;
        private _velocity;
        private _temp;
        update(_context: Context): void;
        applyInitial(vel: Vector3): void;
        applyCurrent(vel: Vector3, t01: number, lerpFactor: number): void;
    }
    export class SizeBySpeedModule {
        enabled: boolean;
        range: Vector2;
        separateAxes: boolean;
        size: MinMaxCurve;
        sizeMultiplier: number;
        x: MinMaxCurve;
        xMultiplier: number;
        y: MinMaxCurve;
        yMultiplier: number;
        z: MinMaxCurve;
        zMultiplier: number;
        evaluate(vel: Vector3, _t01: number, lerpFactor: number, size: number): number;
    }
    export class ColorBySpeedModule {
        enabled: boolean;
        range: Vector2;
        color: MinMaxGradient;
        evaluate(vel: Vector3, lerpFactor: number, color: Vector4): void;
    }
}
declare module "engine-components/ParticleSystemSubEmitter" {
    import { Behavior, Particle, ParticleSystem } from "three.quarks";
    import { IParticleSystem } from "engine-components/ParticleSystemModules";
    export class ParticleSubEmitter implements Behavior {
        private system;
        private particleSystem;
        private subSystem;
        subParticleSystem?: ParticleSystem | undefined;
        type: string;
        private q_;
        private v_;
        private v2_;
        private _emitterMatrix;
        private _circularBuffer;
        constructor(system: IParticleSystem, particleSystem: ParticleSystem, subSystem: IParticleSystem, subParticleSystem?: ParticleSystem | undefined);
        clone(): Behavior;
        initialize(particle: Particle): void;
        update(particle: Particle, delta: number): void;
        frameUpdate(_delta: number): void;
        toJSON(): any;
    }
}
declare module "engine-components/ParticleSystem" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { MainModule, EmissionModule, ShapeModule, ColorOverLifetimeModule, SizeOverLifetimeModule, NoiseModule, IParticleSystem, ParticleSystemRenderMode, TrailModule, VelocityOverLifetimeModule, TextureSheetAnimationModule, RotationOverLifetimeModule, LimitVelocityOverLifetimeModule, RotationBySpeedModule, InheritVelocityModule, SizeBySpeedModule, ColorBySpeedModule } from "engine-components/ParticleSystemModules";
    import { Matrix4, Mesh, Object3D, Quaternion, SpriteMaterial, Vector3 } from "three";
    import { Context } from "engine/engine_setup";
    export class SubEmitterSystem {
        particleSystem?: ParticleSystem;
        _deserialize(context: Context): void;
    }
    export class ParticleSystemRenderer extends Behaviour {
        renderMode?: ParticleSystemRenderMode;
        particleMaterial?: SpriteMaterial;
        trailMaterial?: SpriteMaterial;
        particleMesh?: Mesh | string;
        get transparent(): boolean;
        getMaterial(trailEnabled?: boolean): THREE.SpriteMaterial | undefined;
        getMesh(): THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial>;
    }
    export class ParticleSystem extends Behaviour implements IParticleSystem {
        play(includeChildren?: boolean): void;
        pause(): void;
        stop(): void;
        private _state?;
        emit(count: number): void;
        readonly colorOverLifetime: ColorOverLifetimeModule;
        readonly main: MainModule;
        readonly emission: EmissionModule;
        readonly sizeOverLifetime: SizeOverLifetimeModule;
        readonly shape: ShapeModule;
        readonly noise: NoiseModule;
        readonly trails: TrailModule;
        readonly velocityOverLifetime: VelocityOverLifetimeModule;
        readonly limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
        readonly inheritVelocity: InheritVelocityModule;
        readonly colorBySpeed: ColorBySpeedModule;
        readonly textureSheetAnimation: TextureSheetAnimationModule;
        readonly rotationOverLifetime: RotationOverLifetimeModule;
        readonly rotationBySpeed: RotationBySpeedModule;
        readonly sizeBySpeed: SizeBySpeedModule;
        get renderer(): ParticleSystemRenderer;
        get isPlaying(): boolean;
        get currentParticles(): number;
        get maxParticles(): number;
        get time(): number;
        get duration(): number;
        get deltaTime(): number;
        get scale(): number;
        get cameraScale(): number;
        private _cameraScale;
        get container(): Object3D;
        get worldspace(): boolean;
        private __worldQuaternion;
        get worldQuaternion(): Quaternion;
        private _worldQuaternionInverted;
        get worldQuaternionInverted(): Quaternion;
        private _worldScale;
        get worldScale(): Vector3;
        private _worldPositionFrame;
        private _worldPos;
        get worldPos(): Vector3;
        get matrixWorld(): Matrix4;
        get isSubsystem(): boolean;
        private _renderer;
        private _batchSystem?;
        private _particleSystem?;
        private _interface;
        private _container;
        private _time;
        private _isPlaying;
        private _isUsedAsSubsystem;
        /** called from deserialization */
        private set bursts(value);
        private _bursts?;
        /** called from deserialization */
        private set subEmitterSystems(value);
        private _subEmitterSystems?;
        awake(): void;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        onBeforeRender(): void;
        private addSubParticleSystems;
    }
}
declare module "engine/engine_coroutine" {
    import { Context } from "engine/engine_setup";
    export function WaitForSeconds(seconds: number, context?: Context | null): Generator<undefined, void, unknown>;
    export function WaitForFrames(frames: number): Generator<undefined, void, unknown>;
}
declare module "engine-components/PlayerColor" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export class PlayerColor extends Behaviour {
        awake(): void;
        private _didAssignPlayerColor;
        onEnable(): void;
        private waitForConnection;
        private tryAssignColor;
        assignUserColor(id: string): void;
        private assignColor;
        static hashCode(str: string): number;
        static colorFromHashCode(hash: number): THREE.Color;
    }
}
declare module "engine/engine_input_utils" {
    export function awaitInputAsync(): Promise<void>;
    export function awaitInput(cb: any): Promise<void>;
}
declare module "engine/engine_create_objects" {
    import { Mesh, Material } from "three";
    export enum PrimitiveType {
        Quad = 0
    }
    export type ObjectOptions = {
        name?: string;
        material?: Material;
    };
    export class ObjectUtils {
        static createPrimitive(type: PrimitiveType, opts?: ObjectOptions): Mesh;
    }
}
declare module "engine-components/VideoPlayer" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    export enum AspectMode {
        None = 0,
        AdjustHeight = 1,
        AdjustWidth = 2
    }
    export enum VideoSource {
        VideoClip = 0,
        Url = 1
    }
    export enum VideoAudioOutputMode {
        None = 0,
        AudioSource = 1,
        Direct = 2,
        APIOnly = 3
    }
    export enum VideoRenderMode {
        CameraFarPlane = 0,
        CameraNearPlane = 1,
        RenderTexture = 2,
        MaterialOverride = 3
    }
    export class VideoPlayer extends Behaviour {
        renderer: THREE.Object3D | null;
        playOnAwake: boolean;
        playOnEnable?: boolean;
        aspectMode: AspectMode;
        private renderMode?;
        private targetMaterialProperty?;
        private targetMaterialRenderer?;
        private targetTexture?;
        private time;
        private _playbackSpeed;
        get playbackSpeed(): number;
        set playbackSpeed(val: number);
        private _isLooping;
        get isLooping(): boolean;
        set isLooping(val: boolean);
        get currentTime(): number;
        set currentTime(val: number);
        get isPlaying(): boolean;
        get crossOrigin(): string | null;
        set crossOrigin(val: string | null);
        get videoTexture(): THREE.VideoTexture | null;
        private _crossOrigin;
        private audioOutputMode;
        private source;
        private clip?;
        private url?;
        private videoElement;
        private _videoTexture;
        private videoMaterial;
        private _isPlaying;
        private wasPlaying;
        setVideo(video: MediaStream): void;
        setClipURL(url: string): void;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        private _receivedInput;
        constructor();
        play(): void;
        stop(): void;
        pause(): void;
        create(playAutomatically: boolean): void;
        updateAspect(): void;
        private _overlay;
        get screenspace(): boolean;
        set screenspace(val: boolean);
        private _targetObjects;
        private createVideoElement;
        private handleBeginPlaying;
        private updateVideoElementSettings;
        private updateVideoElementStyles;
        private _updateAspectRoutineId;
        private updateAspectImpl;
    }
}
declare module "engine-components/ScreenCapture" {
    import { Behaviour } from "engine-components/Component";
    import { VideoPlayer } from "engine-components/VideoPlayer";
    import { IPointerClickHandler } from "engine-components/ui/PointerEvents";
    export enum ScreenCaptureDevice {
        Screen = 0,
        Camera = 1,
        Canvas = 2
    }
    export enum ScreenCaptureMode {
        Idle = 0,
        Sending = 1,
        Receiving = 2
    }
    type ScreenCaptureOptions = {
        device?: ScreenCaptureDevice;
        deviceId?: string;
        constraints?: MediaTrackConstraints;
    };
    export class ScreenCapture extends Behaviour implements IPointerClickHandler {
        onPointerClick(): void;
        videoPlayer?: VideoPlayer;
        device: ScreenCaptureDevice;
        get currentScream(): MediaStream | null;
        get currentMode(): ScreenCaptureMode;
        get isSending(): boolean | undefined;
        get isReceiving(): boolean;
        private _net?;
        private _requestOpen;
        private _currentStream;
        private _currentMode;
        awake(): void;
        start(): void;
        share(opts?: ScreenCaptureOptions): Promise<void>;
        close(): void;
        private setVideo;
        private onReceiveVideo;
        private tryShareUserCamera;
    }
}
declare module "engine-components/ShadowCatcher" {
    import { Behaviour } from "engine-components/Component";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    enum ShadowMode {
        ShadowMask = 0,
        Additive = 1
    }
    export class ShadowCatcher extends Behaviour {
        mode: ShadowMode;
        shadowColor: RGBAColor;
        awake(): void;
        applyLightBlendMaterial(): void;
        applyShadowMaterial(): void;
        private applyMaterialOptions;
    }
}
declare module "engine/engine_networking_auto" {
    export type SyncFieldOptions = {
        onPropertyChanged: Function;
    };
    /**
     * Decorate a field to be automatically networked synced
     * @param onFieldChanged name of a callback function that will be called when the field is changed.
     * This function may return false to prevent notifyChanged from being called
     * (for example a networked color is sent as a number and may be converted to a color in the receiver again)
     *
     * Parameters: (newValue, previousValue)
     * @returns
     */
    export const syncField: (onFieldChanged?: string) => (target: any, propertyKey: string) => void;
    export type SyncOptions = {
        key?: string;
        fieldName?: string;
    };
    export const sync: (_options?: SyncOptions) => <T>(target: any, _propertyKey: string, descriptor: PropertyDescriptor) => void;
}
declare module "engine-components/Skybox" {
    import { Behaviour } from "engine-components/Component";
    export class RemoteSkybox extends Behaviour {
        url?: string;
        allowDrop: boolean;
        background: boolean;
        backgroundBlurriness: number;
        environment: boolean;
        private _loader?;
        private _prevLoadedEnvironment?;
        private _prevEnvironment;
        private _prevBackground;
        onEnable(): void;
        onDisable(): void;
        setSkybox(url: string | undefined | null): Promise<void>;
        private dragOverEvent?;
        private dropEvent?;
        private registerDropEvents;
        private unregisterDropEvents;
    }
}
declare module "engine-components/SmoothFollow" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { Axes } from "engine/engine_physics.types";
    export class SmoothFollow extends Behaviour {
        target: THREE.Object3D | null;
        followFactor: number;
        rotateFactor: number;
        positionAxes: Axes;
        flipForward: boolean;
        private static _invertForward;
        private _firstUpdate;
        onBeforeRender(): void;
        updateNow(hard: boolean): void;
    }
}
declare module "engine-components/SpatialTrigger" {
    import { Behaviour } from "engine-components/Component";
    import { EventList } from "engine-components/EventList";
    export class SpatialTriggerReceiver extends Behaviour {
        triggerMask: number;
        onEnter?: EventList;
        onStay?: EventList;
        onExit?: EventList;
        start(): void;
        update(): void;
        currentIntersected: SpatialTrigger[];
        lastIntersected: SpatialTrigger[];
        onEnterTrigger(trigger: SpatialTrigger): void;
        onExitTrigger(trigger: SpatialTrigger): void;
        onStayTrigger(trigger: SpatialTrigger): void;
    }
    export class SpatialTrigger extends Behaviour {
        static triggers: SpatialTrigger[];
        triggerMask?: number;
        private boxHelper?;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        test(obj: THREE.Object3D): boolean;
        raiseOnEnterEvent(rec: SpatialTriggerReceiver): void;
        raiseOnStayEvent(rec: SpatialTriggerReceiver): void;
        raiseOnExitEvent(rec: SpatialTriggerReceiver): void;
    }
}
declare module "engine-components/SpectatorCamera" {
    import { Behaviour } from "engine-components/Component";
    import { Camera } from "engine-components/Camera";
    import { PlayerView } from "engine/engine_playerview";
    export enum SpectatorMode {
        FirstPerson = 0,
        ThirdPerson = 1
    }
    export class SpectatorCamera extends Behaviour {
        cam: Camera | null;
        private _mode;
        get mode(): SpectatorMode;
        set mode(val: SpectatorMode);
        /** if this user is currently spectating someone else */
        get isSpectating(): boolean;
        isSpectatingUser(userId: string): boolean;
        isFollowedBy(userId: string): boolean;
        /** list of other users that are following me */
        get followers(): string[];
        stopSpectating(): void;
        private get localId();
        /** player view to follow */
        set target(target: PlayerView | undefined);
        get target(): PlayerView | undefined;
        requestAllFollowMe(): void;
        private get isSpectatingSelf();
        private orbit;
        private _handler?;
        private eventSub_WebXRRequestStartEvent;
        private eventSub_WebXRStartEvent;
        private eventSub_WebXREndEvent;
        private _debug?;
        private _networking;
        awake(): void;
        onDestroy(): void;
        private isSupportedPlatform;
        private onXRSessionRequestStart;
        private onXRSessionStart;
        private onXRSessionEnded;
        private followSelf;
        onAfterRender(): void;
        private setAvatarFlagsBeforeRender;
        private resetAvatarFlags;
    }
}
declare module "engine-components/SpriteRenderer" {
    import { Behaviour } from "engine-components/Component";
    import * as THREE from "three";
    import { Vector2 } from "three";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    export enum SpriteDrawMode {
        Simple = 0,
        Sliced = 1,
        Tiled = 2
    }
    class Vec2 {
        x: number;
        y: number;
    }
    export class Sprite {
        guid?: string;
        texture?: THREE.Texture;
        triangles: Array<number>;
        uv: Array<Vec2>;
        vertices: Array<Vec2>;
        _geometry?: THREE.BufferGeometry;
    }
    class Slice {
        name: string;
        offset: Vector2;
        size: Vector2;
    }
    export class SpriteSheet {
        sprite?: Sprite;
        index: number;
        slices: Slice[];
        update(): void;
    }
    export class SpriteRenderer extends Behaviour {
        drawMode: SpriteDrawMode;
        size: Vec2;
        color?: RGBAColor;
        sharedMaterial?: THREE.Material;
        get sprite(): SpriteSheet | undefined;
        set sprite(value: SpriteSheet | undefined | number);
        set spriteIndex(value: number);
        get spriteIndex(): number;
        get spriteFrames(): number;
        private _spriteSheet?;
        private _currentSprite?;
        awake(): void;
        start(): void;
        private updateSprite;
    }
}
declare module "engine-schemes/synced-camera-model" {
    import * as flatbuffers from 'flatbuffers';
    import { Vec3 } from "engine-schemes/vec3";
    export class SyncedCameraModel {
        bb: flatbuffers.ByteBuffer | null;
        bb_pos: number;
        __init(i: number, bb: flatbuffers.ByteBuffer): SyncedCameraModel;
        static getRootAsSyncedCameraModel(bb: flatbuffers.ByteBuffer, obj?: SyncedCameraModel): SyncedCameraModel;
        static getSizePrefixedRootAsSyncedCameraModel(bb: flatbuffers.ByteBuffer, obj?: SyncedCameraModel): SyncedCameraModel;
        userId(): string | null;
        userId(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
        guid(): string | null;
        guid(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
        dontSave(): boolean;
        pos(obj?: Vec3): Vec3 | null;
        rot(obj?: Vec3): Vec3 | null;
        static startSyncedCameraModel(builder: flatbuffers.Builder): void;
        static addUserId(builder: flatbuffers.Builder, userIdOffset: flatbuffers.Offset): void;
        static addGuid(builder: flatbuffers.Builder, guidOffset: flatbuffers.Offset): void;
        static addDontSave(builder: flatbuffers.Builder, dontSave: boolean): void;
        static addPos(builder: flatbuffers.Builder, posOffset: flatbuffers.Offset): void;
        static addRot(builder: flatbuffers.Builder, rotOffset: flatbuffers.Offset): void;
        static endSyncedCameraModel(builder: flatbuffers.Builder): flatbuffers.Offset;
        static finishSyncedCameraModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
        static finishSizePrefixedSyncedCameraModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
    }
}
declare module "engine-components/SyncedCamera" {
    import { Behaviour } from "engine-components/Component";
    import { AssetReference } from "engine/engine_addressables";
    type UserCamInfo = {
        obj: THREE.Object3D;
        lastUpdate: number;
        userId: string;
    };
    export class SyncedCamera extends Behaviour {
        static instances: UserCamInfo[];
        getCameraObject(userId: string): THREE.Object3D | null;
        cameraPrefab: THREE.Object3D | null | AssetReference;
        private _lastWorldPosition;
        private _lastWorldQuaternion;
        private _model;
        private _needsUpdate;
        private _lastUpdateTime;
        private remoteCams;
        private userToCamMap;
        private _camTimeoutInSeconds;
        private _receiveCallback;
        awake(): Promise<void>;
        onEnable(): void;
        onDisable(): void;
        update(): void;
        private onReceivedRemoteCameraInfoBin;
    }
}
declare module "engine-components/SyncedRoom" {
    import { Behaviour } from "engine-components/Component";
    export class SyncedRoom extends Behaviour {
        roomName: string;
        urlParameterName: string;
        joinRandomRoom: boolean;
        requireRoomParameter: boolean;
        autoRejoin: boolean;
        private _roomPrefix?;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        tryJoinRoom(call?: number): boolean;
        private _lastPingTime;
        private _lastRoomTime;
        update(): void;
        get currentRoomName(): string | null;
        setRandomRoomUrlParameter(): void;
        generateRoomName(): string;
        getViewOnlyUrl(): string | null;
    }
}
declare module "engine/tests/test_utils" {
    export function detect_run_tests(): void;
    export function spawnWindows(count: number): Window[] | null;
}
declare module "engine-components/TestRunner" {
    import { Behaviour } from "engine-components/Component";
    export class TestRunner extends Behaviour {
        awake(): void;
    }
    export class TestSimulateUserData extends Behaviour {
        transformsPerFrame: number;
        interval: number;
        useFlatbuffers: boolean;
        awake(): void;
        private builder;
        private models;
        update(): void;
    }
}
declare module "engine-components/TransformGizmo" {
    import { Behaviour } from "engine-components/Component";
    export class TransformGizmo extends Behaviour {
        isGizmo: boolean;
        private control?;
        private orbit?;
        awake(): void;
        start(): void;
        private changeEventListener?;
        private windowKeyDownListener?;
        private windowKeyUpListener?;
        onEnable(): void;
        onDisable(): void;
        private onControlChangedEvent;
        private attachWindowEvents;
    }
}
declare module "engine-components/Volume" {
    import { Behaviour } from "engine-components/Component";
    import { Context } from "engine/engine_setup";
    export enum TonemappingMode {
        None = 0,
        Neutral = 1,
        ACES = 2
    }
    export class VolumeParameter {
        overrideState: boolean;
        value: number;
    }
    export class VolumeComponent {
        active: boolean;
        parameters?: VolumeParameter[];
    }
    export class ToneMapping extends VolumeComponent {
        mode?: VolumeParameter;
        get isToneMapping(): boolean;
    }
    export class ColorAdjustments extends VolumeComponent {
        postExposure?: VolumeParameter;
    }
    export class VolumeProfile {
        components?: VolumeComponent[];
        apply(context: Context): void;
        unapply(context: Context): void;
        private onUpdate;
    }
    export class Volume extends Behaviour {
        sharedProfile?: VolumeProfile;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
    }
}
declare module "engine-components/WebXRGrabRendering" {
    import { Behaviour } from "engine-components/Component";
    import { Object3D, Vector3 } from "three";
    import { Context } from "engine/engine_setup";
    import { IModel } from "engine/engine_networking_types";
    export class XRGrabModel implements IModel {
        guid: any;
        dontSave: boolean;
        userId: string | null | undefined;
        point: {
            x: number;
            y: number;
            z: number;
        };
        source: {
            x: number;
            y: number;
            z: number;
        };
        target: string | undefined;
        update(context: Context, point: Vector3, source: Vector3, target?: string | undefined): void;
    }
    export class XRGrabRendering extends Behaviour {
        prefab: Object3D | null;
        private _grabModels;
        private _grabModelsUpdateTime;
        private _addOrUpdateSub;
        private _endSub;
        private _freeSub;
        private _instances;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        addOrUpdateGrab(model: XRGrabModel): void;
        endGrab(model: XRGrabModel): void;
        private onRemoteGrabStartOrUpdate;
        private onRemoteGrabEnd;
        private onAttachedObjectFree;
        onBeforeRender(): void;
        private updateModel;
        private temp;
        private updateRendering;
    }
}
declare module "engine-components/avatar/AvatarBlink_Simple" {
    import { Behaviour } from "engine-components/Component";
    export class AvatarBlink_Simple extends Behaviour {
        private eyes;
        private lastBlinkTime;
        private blinkLength;
        private eyesOpen;
        private state;
        awake(): void;
        update(): void;
    }
}
declare module "engine-components/avatar/AvatarEyeLook_Rotation" {
    import { Behaviour, GameObject } from "engine-components/Component";
    import * as THREE from "three";
    export class AvatarEyeLook_Rotation extends Behaviour {
        head: GameObject | null;
        eyes: GameObject[] | null;
        target: THREE.Object3D | null;
        private brain;
        awake(): void;
        private vec;
        private static forward;
        private currentTargetPoint;
        update(): void;
    }
}
declare module "engine-components/avatar/Avatar_MouthShapes" {
    import { Behaviour } from "engine-components/Component";
    export class Avatar_MouthShapes extends Behaviour {
        idle: THREE.Object3D[];
        talking: THREE.Object3D[];
        private marker;
        private voip;
        private lastMouthChangeTime;
        private mouthChangeLength;
        awake(): void;
        update(): void;
        private updateLips;
        private setMouthShapeActive;
    }
}
declare module "engine-components/avatar/Avatar_MustacheShake" {
    import { Behaviour } from "engine-components/Component";
    export class Avatar_MustacheShake extends Behaviour {
        private voip;
        private marker;
        private _startPosition;
        awake(): void;
        update(): void;
    }
}
declare module "engine-components/debug/LogStats" {
    import { Behaviour } from "engine-components/Component";
    export class LogStats extends Behaviour {
        onEnable(): void;
        run(): Generator<undefined, void, unknown>;
    }
}
declare module "engine-components/timeline/SignalAsset" {
    import { EventList } from "engine-components/EventList";
    import { Behaviour } from "engine-components/Component";
    import { ISerializable } from "engine/engine_serialization_core";
    export class SignalAsset {
        guid: string;
    }
    export class SignalReceiverEvent implements ISerializable {
        signal: SignalAsset;
        reaction: EventList;
        $serializedTypes: {
            signal: typeof SignalAsset;
            reaction: typeof EventList;
        };
    }
    export class SignalReceiver extends Behaviour {
        events?: SignalReceiverEvent[];
        start(): void;
        invoke(sig: SignalAsset | string): void;
    }
}
declare module "engine-components/timeline/TimelineModels" {
    export type TimelineAssetModel = {
        name: string;
        tracks: TrackModel[];
    };
    export enum TrackType {
        Activation = "ActivationTrack",
        Animation = "AnimationTrack",
        Audio = "AudioTrack",
        Control = "ControlTrack",
        Marker = "MarkerTrack",
        Signal = "SignalTrack"
    }
    export enum ClipExtrapolation {
        None = 0,
        Hold = 1,
        Loop = 2,
        PingPong = 3,
        Continue = 4
    }
    export type TrackModel = {
        name: string;
        type: TrackType;
        muted: boolean;
        outputs: Array<null | string | object>;
        clips: Array<ClipModel>;
        markers: Array<MarkerModel>;
        trackOffset?: TrackOffset;
    };
    type Vec3 = {
        x: number;
        y: number;
        z: number;
    };
    type Quat = {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    export type TrackOffset = {
        position: Vec3 | THREE.Vector3;
        rotation: Quat | THREE.Quaternion;
    };
    export type ClipModel = {
        start: number;
        end: number;
        duration: number;
        timeScale: number;
        asset: any | AudioClipModel | ControlClipModel | AnimationClipModel;
        clipIn: number;
        easeInDuration: number;
        easeOutDuration: number;
        preExtrapolationMode: ClipExtrapolation;
        postExtrapolationMode: ClipExtrapolation;
    };
    export type AnimationClipModel = {
        clip: string | number | THREE.AnimationClip;
        loop: boolean;
        duration: number;
        removeStartOffset: boolean;
        position: Vec3 | THREE.Vector3;
        rotation: Quat | THREE.Quaternion;
    };
    export type AudioClipModel = {
        clip: string;
        loop: boolean;
        volume: number;
    };
    export type ControlClipModel = {
        sourceObject: string | THREE.Object3D;
        controlActivation: boolean;
        updateDirector: boolean;
    };
    export enum MarkerType {
        Signal = "SignalEmitter"
    }
    export class MarkerModel {
        type: MarkerType;
        time: number;
    }
    export class SignalMarkerModel extends MarkerModel {
        retroActive: boolean;
        emitOnce: boolean;
        asset: string;
    }
}
declare module "engine-components/timeline/TimelineTracks" {
    import { PlayableDirector } from "engine-components/timeline/PlayableDirector";
    import * as Models from "engine-components/timeline/TimelineModels";
    import * as THREE from 'three';
    import { Context } from "engine/engine_setup";
    import { SignalReceiver } from "engine-components/timeline/SignalAsset";
    export abstract class TrackHandler {
        director: PlayableDirector;
        track: Models.TrackModel;
        get muted(): boolean;
        set muted(val: boolean);
        forEachClip(backwards?: boolean): IterableIterator<Models.ClipModel>;
        onEnable?(): any;
        onDisable?(): any;
        onDestroy?(): any;
        abstract evaluate(time: number): any;
        onMuteChanged?(): any;
        getClipTime(time: number, model: Models.ClipModel): number;
        getClipTimeNormalized(time: number, model: Models.ClipModel): number;
        evaluateWeight(time: number, index: number, models: Array<Models.ClipModel>, isActive?: boolean): number;
    }
    export class AnimationTrackHandler extends TrackHandler {
        models: Array<Models.ClipModel>;
        trackOffset?: Models.TrackOffset;
        target?: THREE.Object3D;
        mixer?: THREE.AnimationMixer;
        clips: Array<THREE.AnimationClip>;
        actions: Array<THREE.AnimationAction>;
        /** holds data/info about clips differences */
        private _actionOffsets;
        private _didBind;
        createHooks(clipModel: Models.AnimationClipModel, clip: any): void;
        bind(): void;
        private ensureTrackOffsets;
        private _useclipOffsets;
        private _totalOffsetPosition;
        private _totalOffsetRotation;
        private _totalOffsetPosition2;
        private _totalOffsetRotation2;
        private _summedPos;
        private _tempPos;
        private _summedRot;
        private _tempRot;
        evaluate(time: number): void;
        private createRotationInterpolant;
        private createPositionInterpolant;
    }
    export class AudioTrackHandler extends TrackHandler {
        models: Array<Models.ClipModel>;
        listener: THREE.AudioListener;
        audio: Array<THREE.Audio>;
        audioContextTimeOffset: Array<number>;
        lastTime: number;
        private getAudioFilePath;
        onAllowAudioChanged(allow: boolean): void;
        addModel(model: Models.ClipModel): void;
        onDisable(): void;
        onMuteChanged(): void;
        evaluate(time: number): void;
    }
    export class SignalTrackHandler extends TrackHandler {
        models: Models.SignalMarkerModel[];
        didTrigger: boolean[];
        receivers: Array<SignalReceiver | null>;
        evaluate(time: number): void;
    }
    export class ControlTrackHandler extends TrackHandler {
        models: Array<Models.ClipModel>;
        timelines: Array<PlayableDirector | null>;
        private static resolved;
        resolveSourceObjects(context: Context): void;
        private _previousActiveModel;
        evaluate(time: number): void;
    }
}
declare module "engine-components/timeline/PlayableDirector" {
    import { Behaviour } from "engine-components/Component";
    import * as Models from "engine-components/timeline/TimelineModels";
    import * as Tracks from "engine-components/timeline/TimelineTracks";
    import { GuidsMap } from "engine/engine_types";
    export enum DirectorWrapMode {
        Hold = 0,
        Loop = 1,
        None = 2
    }
    export enum ClipExtrapolation {
        None = 0,
        Hold = 1,
        Loop = 2,
        PingPong = 3,
        Continue = 4
    }
    export type CreateTrackFunction = (director: PlayableDirector, track: Models.TrackModel) => Tracks.TrackHandler | undefined | null;
    export class PlayableDirector extends Behaviour {
        private static createTrackFunctions;
        static registerCreateTrack(type: string, fn: CreateTrackFunction): void;
        playableAsset?: Models.TimelineAssetModel;
        playOnAwake?: boolean;
        extrapolationMode: DirectorWrapMode;
        get isPlaying(): boolean;
        get isPaused(): boolean;
        get time(): number;
        set time(value: number);
        get duration(): number;
        set duration(value: number);
        get weight(): number;
        set weight(value: number);
        private _visibilityChangeEvt?;
        private _clonedPlayableAsset;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        rebuildGraph(): void;
        play(): void;
        pause(): void;
        stop(): void;
        evaluate(): void;
        isValid(): boolean | undefined;
        forEachTrack(): Generator<Tracks.TrackHandler, void, unknown>;
        get audioTracks(): Tracks.AudioTrackHandler[];
        private _guidsMap?;
        resolveGuids(map: GuidsMap): void;
        private _isPlaying;
        private _internalUpdateRoutine;
        private _isPaused;
        private _time;
        private _duration;
        private _weight;
        private _animationTracks;
        private _audioTracks;
        private _signalTracks;
        private _controlTracks;
        private _customTracks;
        private _allTracks;
        private internalUpdate;
        private internalEvaluate;
        private resolveBindings;
        private findRoot;
        private updateTimelineDuration;
        private setupAndCreateTrackHandlers;
        private setAudioTracksAllowPlaying;
    }
}
declare module "engine-components/ui/Utils" {
    import { FrameEvent } from "engine/engine_setup";
    import { Behaviour } from "engine-components/Component";
    export function isUIObject(obj: THREE.Object3D): boolean;
    export type RenderSettings = {
        renderOnTop?: boolean;
        doubleSided?: boolean;
        depthWrite?: boolean;
        castShadows?: boolean;
        receiveShadows?: boolean;
    };
    export function updateRenderSettings(shadowComponent: THREE.Object3D, settings: RenderSettings): void;
    export type RevocableProxy = {
        proxy: any;
        revoke: () => void;
    };
    /** internal method to proxy a field to detect changes */
    /**@deprecated use watcher instead */
    export function onChange<T extends object>(caller: T, field: string, callback: (newValue: any, oldValue: any) => void): RevocableProxy;
    /** internal method to schedule a function at a specific moment in the update loop */
    export function scheduleAction(caller: Behaviour, action: Function, timing?: FrameEvent): void;
}
declare module "engine-components/ui/RectTransform" {
    import * as ThreeMeshUI from 'three-mesh-ui';
    import { BaseUIComponent } from "engine-components/ui/BaseUIComponent";
    import { Vector3 } from "three";
    export class Size {
        width: number;
        height: number;
    }
    export class Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }
    export class RectTransform extends BaseUIComponent {
        offset: number;
        get translation(): Vector3;
        get rotation(): import("three").Quaternion;
        get scale(): THREE.Vector3;
        private _anchoredPosition;
        private get anchoredPosition();
        rect?: Rect;
        sizeDelta: THREE.Vector2;
        anchoredPosition3D?: THREE.Vector3;
        pivot?: THREE.Vector2;
        private lastMatrix;
        private rectBlock;
        private _transformNeedsUpdate;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        private applyTransform;
        markDirty(): void;
        onBeforeRender(): void;
        private applyAnchoring;
        getBasicOptions(): ThreeMeshUI.BlockOptions;
        private ensureValidSize;
        private _createdBlocks;
        createNewBlock(opts?: ThreeMeshUI.BlockOptions | object): ThreeMeshUI.Block;
    }
}
declare module "engine-components/ui/Graphic" {
    import { IGraphic } from "engine-components/ui/Interfaces";
    import * as ThreeMeshUI from 'three-mesh-ui';
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { BaseUIComponent } from "engine-components/ui/BaseUIComponent";
    import { Texture } from 'three';
    import { RectTransform } from "engine-components/ui/RectTransform";
    export class Graphic extends BaseUIComponent implements IGraphic {
        get isGraphic(): boolean;
        get color(): RGBAColor;
        set color(col: RGBAColor);
        protected onColorChanged(): void;
        private get m_Color();
        raycastTarget: boolean;
        protected uiObject: ThreeMeshUI.Block | null;
        private _color;
        private _rect;
        protected get rectTransform(): RectTransform;
        setState(state: string): void;
        setupState(state: object): void;
        setOptions(opts: object): void;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        private _currentlyCreatingPanel;
        protected makePanel(): void;
        protected onBeforeCreate(_opts: any): void;
        protected onCreate(opts: any): void;
        protected onAfterCreated(): void;
        /** used internally to ensure textures assigned to UI use linear encoding */
        static textureCache: Map<Texture, Texture>;
        protected setTexture(tex: Texture | null | undefined): Promise<void>;
        protected onAfterAddedToScene(): void;
    }
    export class MaskableGraphic extends Graphic {
        protected onAfterCreated(): void;
    }
}
declare module "engine-components/ui/Image" {
    import { Texture } from 'three';
    import { MaskableGraphic } from "engine-components/ui/Graphic";
    class Sprite {
        texture?: THREE.Texture;
        rect?: {
            width: number;
            height: number;
        };
    }
    export class Image extends MaskableGraphic {
        sprite?: Sprite;
        private isBuiltinSprite;
        protected onBeforeCreate(opts: any): void;
        protected onAfterCreated(): void;
    }
    export class RawImage extends MaskableGraphic {
        mainTexture?: Texture;
        protected onAfterCreated(): void;
    }
}
declare module "engine-components/ui/Button" {
    import { Behaviour } from "engine-components/Component";
    import { EventList } from "engine-components/EventList";
    import { IPointerEventHandler, PointerEventData } from "engine-components/ui/PointerEvents";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    import { Animator } from "engine-components/Animator";
    export enum Transition {
        None = 0,
        ColorTint = 1,
        SpriteSwap = 2,
        Animation = 3
    }
    class ButtonColors {
        colorMultiplier: 1;
        disabledColor: RGBAColor;
        fadeDuration: number;
        highlightedColor: RGBAColor;
        normalColor: RGBAColor;
        pressedColor: RGBAColor;
        selectedColor: RGBAColor;
    }
    type AnimationTriggers = {
        disabledTrigger: string;
        highlightedTrigger: string;
        normalTrigger: string;
        pressedTrigger: string;
        selectedTrigger: string;
    };
    export class Button extends Behaviour implements IPointerEventHandler {
        onClick?: EventList;
        private _isHovered;
        onPointerEnter(_: any): void;
        onPointerExit(): void;
        onPointerDown(_: any): void;
        onPointerUp(_: any): void;
        onPointerClick(_args: PointerEventData): void;
        colors?: ButtonColors;
        transition?: Transition;
        animationTriggers?: AnimationTriggers;
        animator?: Animator;
        set interactable(value: boolean);
        get interactable(): boolean;
        private _interactable;
        private set_interactable;
        awake(): void;
        start(): void;
        onEnable(): void;
        private _requestedAnimatorTrigger?;
        private setAnimatorTriggerAtEndOfFrame;
        private _isInit;
        private _image?;
        private init;
        private stateSetup;
        private getFinalColor;
    }
}
declare module "engine-components/ui/Canvas" {
    import { UIRootComponent } from "engine-components/ui/BaseUIComponent";
    export enum RenderMode {
        ScreenSpaceOverlay = 0,
        ScreenSpaceCamera = 1,
        WorldSpace = 2
    }
    export class Canvas extends UIRootComponent {
        set renderOnTop(val: boolean);
        get renderOnTop(): boolean;
        private _renderOnTop;
        set depthWrite(val: boolean);
        get depthWrite(): boolean;
        private _depthWrite;
        set doubleSided(val: boolean);
        get doubleSided(): boolean;
        private _doubleSided;
        set castShadows(val: boolean);
        get castShadows(): boolean;
        private _castShadows;
        set receiveShadows(val: boolean);
        get receiveShadows(): boolean;
        private _receiveShadows;
        get renderMode(): RenderMode;
        set renderMode(val: RenderMode);
        private _renderMode;
        private _rootCanvas;
        set rootCanvas(val: Canvas);
        get rootCanvas(): Canvas;
        private _scaleFactor;
        get scaleFactor(): number;
        private set scaleFactor(value);
        awake(): void;
        onEnable(): void;
        private previousAspect;
        onBeforeRender(): void;
        private _updateRenderSettingsRoutine?;
        private onRenderSettingsChanged;
        private _updateRenderSettingsDelayed;
        private _activeRenderMode;
        private get isScreenSpace();
        private updateRenderMode;
    }
}
declare module "engine-components/ui/CanvasGroup" {
    import { Behaviour } from "engine-components/Component";
    import { ICanvasGroup } from "engine-components/ui/Interfaces";
    export class CanvasGroup extends Behaviour implements ICanvasGroup {
        get alpha(): number;
        set alpha(val: number);
        get isCanvasGroup(): boolean;
        private _alpha;
        interactable: boolean;
        blocksRaycasts: boolean;
        private _isDirty;
        private markDirty;
        private applyChangesDelayed;
        private _buffer;
        private applyChangesNow;
    }
}
declare module "engine-components/ui/Text" {
    import { Graphic } from "engine-components/ui/Graphic";
    import { Canvas } from "engine-components/ui/Canvas";
    export enum TextAnchor {
        UpperLeft = 0,
        UpperCenter = 1,
        UpperRight = 2,
        MiddleLeft = 3,
        MiddleCenter = 4,
        MiddleRight = 5,
        LowerLeft = 6,
        LowerCenter = 7,
        LowerRight = 8
    }
    export enum VerticalWrapMode {
        Truncate = 0,
        Overflow = 1
    }
    enum HorizontalWrapMode {
        Wrap = 0,
        Overflow = 1
    }
    enum FontStyle {
        Normal = 0,
        Bold = 1,
        Italic = 2,
        BoldAndItalic = 3
    }
    export class Text extends Graphic {
        canvas?: Canvas;
        alignment: TextAnchor;
        verticalOverflow: VerticalWrapMode;
        horizontalOverflow: HorizontalWrapMode;
        lineSpacing: number;
        supportRichText: boolean;
        font?: string;
        fontStyle: FontStyle;
        get text(): string;
        set text(val: string);
        private set_text;
        get fontSize(): number;
        set fontSize(val: number);
        protected onColorChanged(): void;
        private _isWaitingForRebuild;
        private requestRebuild;
        private rebuildDelayedRoutine;
        protected onCreate(_opts: any): void;
        onAfterAddedToScene(): void;
        private _text;
        private _fontSize;
        private _textMeshUi;
        private _textContainer;
        private getTextOpts;
        onEnable(): void;
        private createBlock;
        private getAlignment;
        private updateWidth;
        private ensureShadowComponentOwner;
        private createText;
        private _didHandleTextRenderOnTop;
        private handleTextRenderOnTop;
        private renderOnTopCoroutine;
        private handleTag;
        private getText;
        private getNextTag;
        private setFont;
        private getFontName;
    }
}
declare module "engine-components/ui/InputField" {
    import { Behaviour } from "engine-components/Component";
    import { IPointerEventHandler } from "engine-components/ui/PointerEvents";
    import { EventList } from "engine-components/EventList";
    export class InputField extends Behaviour implements IPointerEventHandler {
        get text(): string;
        get isFocused(): boolean;
        private textComponent?;
        private placeholder?;
        onValueChanged?: EventList;
        onEndEdit?: EventList;
        private static active;
        private static activeTime;
        private static htmlField;
        private inputEventFn;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        onPointerClick(_args: any): void;
        private activeLoop;
        private onSelected;
        private onDeselected;
        private onInput;
        private setTextFromInputField;
        private selectInputField;
    }
}
declare module "engine-components/ui/Keyboard" {
    import { BaseUIComponent } from "engine-components/ui/BaseUIComponent";
    import { Text } from "engine-components/ui/Text";
    enum KeymapOption {
        fr = 0,
        ru = 1,
        de = 2,
        es = 3,
        el = 4,
        nord = 5,
        eng = 6
    }
    export class Keyboard extends BaseUIComponent {
        font?: string;
        text?: Text;
        keymap?: KeymapOption;
        padding?: number;
        margin?: number;
        fontSize?: number;
        borderRadius?: number;
        private colors;
        awake(): void;
        onEnable(): void;
        onDisable(): void;
        private keyboard;
        private _lastKeyPressed;
        private _lastKeyPressedStartTime;
        private _lastKeyPressedTime;
        private makeKeyboard;
        private tryAppend;
    }
}
declare module "engine-components/ui/Layout" {
    import { Behaviour } from "engine-components/Component";
    export class LayoutGroup extends Behaviour {
        reverseArrangement: boolean;
    }
    export class VerticalLayoutGroup extends LayoutGroup {
    }
    export class HorizontalLayoutGroup extends LayoutGroup {
    }
    export class GridLayoutGroup extends LayoutGroup {
    }
}
declare module "engine-components/ui/SpatialHtml" {
    import { Behaviour } from "engine-components/Component";
    export class SpatialHtml extends Behaviour {
        id: string | null;
        keepAspect: boolean;
        start(): void;
    }
}
declare module "engine-components/export/gltf/GltfExport" {
    import { Behaviour } from "engine-components/Component";
    import { Object3D } from "three";
    import { BoxHelperComponent } from "engine-components/BoxHelperComponent";
    type ExportOptions = {
        binary: boolean;
        pivot?: THREE.Vector3;
    };
    export const componentsArrayExportKey = "$___Export_Components";
    export class GltfExportBox extends BoxHelperComponent {
        sceneRoot?: THREE.Object3D;
        start(): void;
        updateGltfBox(): Generator<undefined, void, unknown>;
    }
    export class GltfExport extends Behaviour {
        binary: boolean;
        objects: Object3D[];
        private exporter?;
        private ext?;
        exportNow(name: string): Promise<void>;
        export(objectsToExport: Object3D[], opts?: ExportOptions): Promise<any>;
        private static saveArrayBuffer;
        private static saveJson;
        private static save;
        private static collectAnimations;
        private static calculateCenter;
        private static filterTopmostParent;
    }
}
declare module "engine-components/export/usdz/types" {
    import { Object3D, Matrix4, Material, BufferGeometry } from "three";
    /** implementation is in three */
    export class USDZDocument {
        name: string;
        get isDocumentRoot(): boolean;
        add(obj: USDZObject): any;
        remove(obj: USDZObject): any;
        traverse(callback: (obj: USDZObject) => void): any;
        findById(uuid: string): USDZObject | undefined;
        get isDynamic(): boolean;
    }
    /** implementation is in three */
    export class USDZObject {
        static createEmptyParent(parent: USDZObject): any;
        uuid: string;
        name: string;
        matrix: Matrix4;
        material: Material;
        geometry: BufferGeometry;
        parent: USDZObject | USDZDocument | null;
        children: USDZObject[];
        _eventListeners: {
            [event: string]: Function[];
        };
        isDynamic: boolean;
        is(obj: Object3D): boolean;
        isEmpty(): boolean;
        clone(): any;
        getPath(): any;
        add(child: USDZObject): any;
        remove(child: USDZObject): any;
        addEventListener(evt: string, listener: Function): any;
        removeEventListener(evt: string, listener: Function): any;
    }
}
declare module "engine-components/export/usdz/Extension" {
    import { USDZObject } from "engine-components/export/usdz/types";
    export interface IUSDZExporterExtension {
        get extensionName(): string;
        onBeforeBuildDocument?(context: any): any;
        onAfterBuildDocument?(context: any): any;
        onExportObject?(object: any, model: USDZObject, context: any): any;
        onAfterSerialize?(context: any): any;
        onAfterHierarchy?(context: any): any;
    }
}
declare module "engine-components/export/usdz/extensions/Animation" {
    import { Object3D } from "three";
    import { USDZObject } from "three/examples/jsm/exporters/USDZExporter";
    import { IUSDZExporterExtension } from "engine-components/export/usdz/Extension";
    export interface UsdzAnimation {
        createAnimation(ext: AnimationExtension, model: USDZObject, context: any): any;
    }
    export type AnimationClipCollection = Array<{
        root: Object3D;
        clips: Array<THREE.AnimationClip>;
    }>;
    export class RegisteredAnimationInfo {
        get start(): number;
        get duration(): number;
        private ext;
        private root;
        private clip;
        constructor(ext: AnimationExtension, root: THREE.Object3D, clip: THREE.AnimationClip);
    }
    export class TransformData {
        clip: THREE.AnimationClip;
        pos?: THREE.KeyframeTrack;
        rot?: THREE.KeyframeTrack;
        scale?: THREE.KeyframeTrack;
        get frameRate(): number;
        private ext;
        private root;
        private target;
        constructor(ext: AnimationExtension, root: Object3D, target: Object3D, clip: THREE.AnimationClip);
        addTrack(track: any): void;
        getFrames(): number;
        getDuration(): number;
        getStartTime(arr: TransformData[]): number;
    }
    export class AnimationExtension implements IUSDZExporterExtension {
        get extensionName(): string;
        private dict;
        private rootTargetMap;
        getStartTime01(root: Object3D, clip: THREE.AnimationClip): number;
        registerAnimation(root: Object3D, clip: THREE.AnimationClip): RegisteredAnimationInfo | null;
        onAfterHierarchy(_context: any): void;
        private serializers;
        onAfterBuildDocument(_context: any): void;
        onExportObject(object: any, model: USDZObject, _context: any): void;
    }
}
declare module "engine-components/export/usdz/utils/quicklook" {
    import { Context } from "engine/engine_setup";
    export function ensureQuicklookLinkIsCreated(context: Context): HTMLAnchorElement;
}
declare module "engine-components/export/usdz/utils/timeutils" {
    export function getFormattedDate(): string;
}
declare module "engine-components/export/usdz/utils/animationutils" {
    import { Object3D } from "three";
    import { AnimationExtension } from "engine-components/export/usdz/extensions/Animation";
    export function registerAnimatorsImplictly(root: Object3D, ext: AnimationExtension): void;
}
declare module "engine-components/export/usdz/USDZExporter" {
    import * as THREE from "three";
    import { IUSDZExporterExtension } from "engine-components/export/usdz/Extension";
    import { Behaviour } from "engine-components/Component";
    export type QuickLookOverlay = {
        callToAction?: string;
        checkoutTitle?: string;
        checkoutSubtitle?: string;
    };
    export class USDZExporter extends Behaviour {
        objectToExport?: THREE.Object3D;
        autoExportAnimations: boolean;
        extensions: IUSDZExporterExtension[];
        private link;
        private webxr?;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        exportAsync(): Promise<void>;
        private lastCallback?;
        private quicklookCallback;
        private buildQuicklookOverlay;
        private _arButton?;
        private createQuicklookButton;
        private resetStyles;
    }
}
declare module "engine-components/codegen/components" {
    export class __Ignore {
    }
    export { AlignmentConstraint } from "engine-components/AlignmentConstraint";
    export { Animation } from "engine-components/Animation";
    export { AnimationCurve } from "engine-components/AnimationCurve";
    export { Animator } from "engine-components/Animator";
    export { AnimatorController } from "engine-components/AnimatorController";
    export { AudioListener } from "engine-components/AudioListener";
    export { AudioSource } from "engine-components/AudioSource";
    export { AvatarModel } from "engine-components/AvatarLoader";
    export { AvatarLoader } from "engine-components/AvatarLoader";
    export { AxesHelper } from "engine-components/AxesHelper";
    export { BasicIKConstraint } from "engine-components/BasicIKConstraint";
    export { BoxHelperComponent } from "engine-components/BoxHelperComponent";
    export { Camera } from "engine-components/Camera";
    export { CharacterController } from "engine-components/CharacterController";
    export { CharacterControllerInput } from "engine-components/CharacterController";
    export { Collider } from "engine-components/Collider";
    export { SphereCollider } from "engine-components/Collider";
    export { BoxCollider } from "engine-components/Collider";
    export { MeshCollider } from "engine-components/Collider";
    export { CapsuleCollider } from "engine-components/Collider";
    export { DeleteBox } from "engine-components/DeleteBox";
    export { Deletable } from "engine-components/DeleteBox";
    export { DeviceFlag } from "engine-components/DeviceFlag";
    export { DragControls } from "engine-components/DragControls";
    export { DropListener } from "engine-components/DropListener";
    export { Duplicatable } from "engine-components/Duplicatable";
    export { CallInfo } from "engine-components/EventList";
    export { EventListEvent } from "engine-components/EventList";
    export { EventList } from "engine-components/EventList";
    export { EventTrigger } from "engine-components/EventTrigger";
    export { FlyControls } from "engine-components/FlyControls";
    export { BoxGizmo } from "engine-components/Gizmos";
    export { GridHelper } from "engine-components/GridHelper";
    export { GroundProjectedEnv } from "engine-components/GroundProjection";
    export { Interactable } from "engine-components/Interactable";
    export { UsageMarker } from "engine-components/Interactable";
    export { FixedJoint } from "engine-components/Joints";
    export { HingeJoint } from "engine-components/Joints";
    export { Light } from "engine-components/Light";
    export { LODModel } from "engine-components/LODGroup";
    export { LODGroup } from "engine-components/LODGroup";
    export { LookAtConstraint } from "engine-components/LookAtConstraint";
    export { NestedGltf } from "engine-components/NestedGltf";
    export { Networking } from "engine-components/Networking";
    export { OffsetConstraint } from "engine-components/OffsetConstraint";
    export { OrbitControls } from "engine-components/OrbitControls";
    export { SubEmitterSystem } from "engine-components/ParticleSystem";
    export { ParticleSystemRenderer } from "engine-components/ParticleSystem";
    export { ParticleSystem } from "engine-components/ParticleSystem";
    export { Gradient } from "engine-components/ParticleSystemModules";
    export { MinMaxCurve } from "engine-components/ParticleSystemModules";
    export { MinMaxGradient } from "engine-components/ParticleSystemModules";
    export { MainModule } from "engine-components/ParticleSystemModules";
    export { ParticleBurst } from "engine-components/ParticleSystemModules";
    export { EmissionModule } from "engine-components/ParticleSystemModules";
    export { ColorOverLifetimeModule } from "engine-components/ParticleSystemModules";
    export { SizeOverLifetimeModule } from "engine-components/ParticleSystemModules";
    export { ShapeModule } from "engine-components/ParticleSystemModules";
    export { NoiseModule } from "engine-components/ParticleSystemModules";
    export { TrailModule } from "engine-components/ParticleSystemModules";
    export { VelocityOverLifetimeModule } from "engine-components/ParticleSystemModules";
    export { TextureSheetAnimationModule } from "engine-components/ParticleSystemModules";
    export { RotationOverLifetimeModule } from "engine-components/ParticleSystemModules";
    export { RotationBySpeedModule } from "engine-components/ParticleSystemModules";
    export { LimitVelocityOverLifetimeModule } from "engine-components/ParticleSystemModules";
    export { InheritVelocityModule } from "engine-components/ParticleSystemModules";
    export { SizeBySpeedModule } from "engine-components/ParticleSystemModules";
    export { ColorBySpeedModule } from "engine-components/ParticleSystemModules";
    export { ParticleSubEmitter } from "engine-components/ParticleSystemSubEmitter";
    export { PlayerColor } from "engine-components/PlayerColor";
    export { ReflectionProbe } from "engine-components/ReflectionProbe";
    export { FieldWithDefault } from "engine-components/Renderer";
    export { Renderer } from "engine-components/Renderer";
    export { MeshRenderer } from "engine-components/Renderer";
    export { SkinnedMeshRenderer } from "engine-components/Renderer";
    export { RendererLightmap } from "engine-components/RendererLightmap";
    export { Rigidbody } from "engine-components/RigidBody";
    export { ScreenCapture } from "engine-components/ScreenCapture";
    export { ShadowCatcher } from "engine-components/ShadowCatcher";
    export { RemoteSkybox } from "engine-components/Skybox";
    export { SmoothFollow } from "engine-components/SmoothFollow";
    export { SpatialTriggerReceiver } from "engine-components/SpatialTrigger";
    export { SpatialTrigger } from "engine-components/SpatialTrigger";
    export { SpectatorCamera } from "engine-components/SpectatorCamera";
    export { Sprite } from "engine-components/SpriteRenderer";
    export { SpriteSheet } from "engine-components/SpriteRenderer";
    export { SpriteRenderer } from "engine-components/SpriteRenderer";
    export { SyncedCamera } from "engine-components/SyncedCamera";
    export { SyncedRoom } from "engine-components/SyncedRoom";
    export { SyncedTransform } from "engine-components/SyncedTransform";
    export { TestRunner } from "engine-components/TestRunner";
    export { TestSimulateUserData } from "engine-components/TestRunner";
    export { TransformGizmo } from "engine-components/TransformGizmo";
    export { VideoPlayer } from "engine-components/VideoPlayer";
    export { Voip } from "engine-components/Voip";
    export { VolumeParameter } from "engine-components/Volume";
    export { VolumeComponent } from "engine-components/Volume";
    export { ToneMapping } from "engine-components/Volume";
    export { ColorAdjustments } from "engine-components/Volume";
    export { VolumeProfile } from "engine-components/Volume";
    export { Volume } from "engine-components/Volume";
    export { WebARSessionRoot } from "engine-components/WebARSessionRoot";
    export { WebXR } from "engine-components/WebXR";
    export { WebAR } from "engine-components/WebXR";
    export { AvatarMarker } from "engine-components/WebXRAvatar";
    export { WebXRAvatar } from "engine-components/WebXRAvatar";
    export { TeleportTarget } from "engine-components/WebXRController";
    export { WebXRController } from "engine-components/WebXRController";
    export { AttachedObject } from "engine-components/WebXRController";
    export { XRGrabModel } from "engine-components/WebXRGrabRendering";
    export { XRGrabRendering } from "engine-components/WebXRGrabRendering";
    export { XRRig } from "engine-components/WebXRRig";
    export { VRUserState } from "engine-components/WebXRSync";
    export { WebXRSync } from "engine-components/WebXRSync";
    export { XRState } from "engine-components/XRFlag";
    export { XRFlag } from "engine-components/XRFlag";
    export { AvatarBlink_Simple } from "engine-components/avatar/AvatarBlink_Simple";
    export { AvatarEyeLook_Rotation } from "engine-components/avatar/AvatarEyeLook_Rotation";
    export { Avatar_POI } from "engine-components/avatar/Avatar_Brain_LookAt";
    export { Avatar_Brain_LookAt } from "engine-components/avatar/Avatar_Brain_LookAt";
    export { Avatar_MouthShapes } from "engine-components/avatar/Avatar_MouthShapes";
    export { Avatar_MustacheShake } from "engine-components/avatar/Avatar_MustacheShake";
    export { LogStats } from "engine-components/debug/LogStats";
    export { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    export { PlayableDirector } from "engine-components/timeline/PlayableDirector";
    export { SignalAsset } from "engine-components/timeline/SignalAsset";
    export { SignalReceiverEvent } from "engine-components/timeline/SignalAsset";
    export { SignalReceiver } from "engine-components/timeline/SignalAsset";
    export { AnimationTrackHandler } from "engine-components/timeline/TimelineTracks";
    export { AudioTrackHandler } from "engine-components/timeline/TimelineTracks";
    export { SignalTrackHandler } from "engine-components/timeline/TimelineTracks";
    export { ControlTrackHandler } from "engine-components/timeline/TimelineTracks";
    export { BaseUIComponent } from "engine-components/ui/BaseUIComponent";
    export { UIRootComponent } from "engine-components/ui/BaseUIComponent";
    export { Button } from "engine-components/ui/Button";
    export { Canvas } from "engine-components/ui/Canvas";
    export { CanvasGroup } from "engine-components/ui/CanvasGroup";
    export { EventSystem } from "engine-components/ui/EventSystem";
    export { Graphic } from "engine-components/ui/Graphic";
    export { MaskableGraphic } from "engine-components/ui/Graphic";
    export { Image } from "engine-components/ui/Image";
    export { RawImage } from "engine-components/ui/Image";
    export { InputField } from "engine-components/ui/InputField";
    export { Keyboard } from "engine-components/ui/Keyboard";
    export { LayoutGroup } from "engine-components/ui/Layout";
    export { VerticalLayoutGroup } from "engine-components/ui/Layout";
    export { HorizontalLayoutGroup } from "engine-components/ui/Layout";
    export { GridLayoutGroup } from "engine-components/ui/Layout";
    export { PointerEventData } from "engine-components/ui/PointerEvents";
    export { Raycaster } from "engine-components/ui/Raycaster";
    export { ObjectRaycaster } from "engine-components/ui/Raycaster";
    export { GraphicRaycaster } from "engine-components/ui/Raycaster";
    export { UIRaycastUtils } from "engine-components/ui/RaycastUtils";
    export { Size } from "engine-components/ui/RectTransform";
    export { Rect } from "engine-components/ui/RectTransform";
    export { RectTransform } from "engine-components/ui/RectTransform";
    export { SpatialHtml } from "engine-components/ui/SpatialHtml";
    export { Text } from "engine-components/ui/Text";
    export { GltfExportBox } from "engine-components/export/gltf/GltfExport";
    export { GltfExport } from "engine-components/export/gltf/GltfExport";
    export { USDZExporter } from "engine-components/export/usdz/USDZExporter";
    export { RegisteredAnimationInfo } from "engine-components/export/usdz/extensions/Animation";
    export { TransformData } from "engine-components/export/usdz/extensions/Animation";
    export { AnimationExtension } from "engine-components/export/usdz/extensions/Animation";
}
declare module "needle-engine" {
    import "engine/engine_element";
    import "engine/engine_setup";
    export { GameObject, Behaviour } from "engine-components/Component";
    export { serializable, serializeable } from "engine/engine_serialization_decorator";
    export { Collision } from "engine/engine_types";
    export * from "engine/api";
    export * from "engine-components/codegen/components";
    export * from "engine-components/js-extensions/Object3D";
}
declare module "engine/engine" {
    import * as engine_setup from "engine/engine_setup";
    import * as engine_scenetools from "engine/engine_scenetools";
    import "engine/tests/test_utils";
    import { RGBAColor } from "engine-components/js-extensions/RGBAColor";
    const engine: {
        RGBAColor: typeof RGBAColor;
        addGltfLoadEventListener(type: engine_scenetools.GltfLoadEventType, listener: engine_scenetools.GltfLoadEventCallback): void;
        removeGltfLoadEventListener(type: engine_scenetools.GltfLoadEventType, listener: engine_scenetools.GltfLoadEventCallback): void;
        parseSync(context: engine_setup.Context, data: any, path: string, seed: number | import("engine/engine_types").UIDProvider | null): Promise<import("three/examples/jsm/loaders/GLTFLoader").GLTF | undefined>;
        loadSync(context: engine_setup.Context, url: string, seed: number | import("engine/engine_types").UIDProvider | null, _allowAddingAnimator?: boolean, prog?: ((ProgressEvent: any) => void) | undefined): Promise<import("three/examples/jsm/loaders/GLTFLoader").GLTF | undefined>;
        findAnimationsLate(_context: engine_setup.Context, gltf: any, callbackarray: any, allowAddingAnimator?: boolean): void;
        findAnimations(gltf: import("three/examples/jsm/loaders/GLTFLoader").GLTF, allowAddingAnimator?: boolean): void;
        tryFindObjectByName(name: any, obj: any, recursive?: boolean): any;
        tryFindObject(globalObjectIdentifier: any, obj: any, recursive?: boolean): any;
        tryFindScript(globalObjectIdentifier: any, list?: null): import("engine/engine_types").IComponent | null;
        NeedleGltfLoader: typeof engine_scenetools.NeedleGltfLoader;
        GltfLoadEventType: typeof engine_scenetools.GltfLoadEventType;
        GltfLoadEvent: typeof engine_scenetools.GltfLoadEvent;
        registerComponent(script: import("engine/engine_types").IComponent, context?: engine_setup.Context | undefined): void;
        build_scene_functions: {
            [name: string]: (context: engine_setup.Context) => Promise<void>;
        };
        LoadingProgressArgs: typeof engine_setup.LoadingProgressArgs;
        LoadingOptions: typeof engine_setup.LoadingOptions;
        ContextArgs: typeof engine_setup.ContextArgs;
        FrameEvent: typeof engine_setup.FrameEvent;
        XRSessionMode: typeof engine_setup.XRSessionMode;
        Context: typeof engine_setup.Context;
    };
    export { engine as engine };
}
declare module "engine-components/BoxCollider" {
    import { BoxCollider } from "engine-components/Collider";
    export default BoxCollider;
}
declare module "engine-components/CameraUtils" {
    import { Camera } from "engine-components/Camera";
    import { Scene } from "three";
    export function createCameraWithOrbitControl(scene: Scene): Camera;
}
declare module "engine-components/SphereCollider" {
    import { SphereCollider } from "engine-components/Collider";
    export default SphereCollider;
}
declare module "engine-components/js-extensions/Vector" {
    import { Vector3 } from "three";
    export function apply(object: Vector3): void;
}
