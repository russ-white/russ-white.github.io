"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTypes = exports.updateTypesRecursiveFromEngine = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const path = require("path");
const log_1 = require("../utils/log");
const package_utils_1 = require("../utils/package-utils");
function updateTypesRecursiveFromEngine(directory) {
    const enginePath = path.join(directory, 'node_modules/@needle-tools/engine/package.json');
    if ((0, fs_1.existsSync)(enginePath) === false) {
        (0, log_1.warning)("Could not find @needle-tools/engine at " + enginePath + ". Skipping update of @types/three. Please update manually");
        return false;
    }
    const json = (0, fs_1.readFileSync)(enginePath, 'utf8');
    const engineJson = JSON.parse(json);
    if (!engineJson.devDependencies) {
        return true;
    }
    const typesName = '@types/three';
    const typesVersion = engineJson.devDependencies[typesName];
    if (typesVersion === undefined) {
        return true;
    }
    updateTypes(directory, typesName, typesVersion);
    // update types for local dependencies
    const packageJsonPath = path.join(directory, 'package.json');
    if ((0, fs_1.existsSync)(packageJsonPath) === false) {
        (0, log_1.warning)("Could not find package.json in " + directory + ". Skipping update of @types/three to " + typesVersion + ". Please update manually");
        return false;
    }
    const packageJson = JSON.parse((0, fs_1.readFileSync)(packageJsonPath, 'utf8'));
    if (packageJson.dependencies !== undefined) {
        for (const dependency in packageJson.dependencies) {
            let dependencyPath = packageJson.dependencies[dependency];
            if (dependencyPath.startsWith('file:')) {
                dependencyPath = dependencyPath.substring(5);
                if ((0, path_1.isAbsolute)(dependencyPath)) {
                    updateTypes(dependencyPath, typesName, typesVersion);
                }
                else {
                    updateTypes(path.join(directory, dependencyPath), typesName, typesVersion);
                }
            }
        }
    }
}
exports.updateTypesRecursiveFromEngine = updateTypesRecursiveFromEngine;
function updateTypes(directory, typesName, typesVersion) {
    const packageJsonPath = path.join(directory, 'package.json');
    if ((0, fs_1.existsSync)(packageJsonPath) === false) {
        (0, log_1.warning)("Could not find package.json in " + directory + ". Skipping update of @types/three to " + typesVersion + ". Please update manually");
        return false;
    }
    const json = (0, fs_1.readFileSync)(packageJsonPath, 'utf8');
    const packageJson = JSON.parse(json);
    let updatedTypes = false;
    if (packageJson.devDependencies !== undefined) {
        if (packageJson.devDependencies[typesName] !== undefined && packageJson.devDependencies[typesName] !== typesVersion) {
            packageJson.devDependencies[typesName] = typesVersion;
            updatedTypes = true;
        }
    }
    if (updatedTypes) {
        console.log("Updating " + typesName + " in " + packageJson.name + " to " + typesVersion);
        (0, package_utils_1.savePackageJson)(packageJsonPath, packageJson);
    }
    return true;
}
exports.updateTypes = updateTypes;
