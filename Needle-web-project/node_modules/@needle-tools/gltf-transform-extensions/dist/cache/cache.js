"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKey = exports.tryGetFromCache = exports.addToCache = exports.clearCache = void 0;
const tmp = require('tmp');
const fs = require('fs');
const path = require('path');
function clearCache() {
    const dir = getCacheDirectory();
    fs.rmSync(dir, { recursive: true });
    console.log(`Cleared cache at ${dir}`);
}
exports.clearCache = clearCache;
function addToCache(key, bytes) {
    const dir = getCacheDirectory();
    const path = `${dir}/${key}.bin`;
    console.log(`Added ${bytes.byteLength} bytes to cache at ${path}`);
    fs.writeFileSync(path, bytes);
}
exports.addToCache = addToCache;
function tryGetFromCache(key) {
    const dir = getCacheDirectory();
    const path = `${dir}/${key}.bin`;
    if (fs.existsSync(path)) {
        const bytes = fs.readFileSync(path);
        return bytes;
    }
    return null;
}
exports.tryGetFromCache = tryGetFromCache;
function getKey(texture) {
    let hash = 0;
    const extensions = texture.listExtensions();
    const extras = texture.getExtras();
    // const slots = listTextureSlots(doc, texture);
    // const channels = getTextureChannelMask(doc, texture);
    hash += hashObject({
        extensions,
        extras,
    });
    const image = texture.getImage();
    const bytes = image?.buffer;
    if (bytes)
        hash += hashBuffer(bytes, image.byteOffset, image.byteLength);
    let key = hash.toString();
    key = `image-${key}`;
    return key;
}
exports.getKey = getKey;
function getCacheDirectory() {
    const tmpDir = path.join(tmp.tmpdir, "Needle", "build-pipeline-cache");
    if (!fs.existsSync(tmpDir)) {
        fs.mkdirSync(tmpDir, { recursive: true });
    }
    return tmpDir;
}
function hashObject(obj) {
    const str = JSON.stringify(obj);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return hash;
}
function hashBuffer(buffer, offset, length) {
    let hash = 0;
    const view = new Uint8Array(buffer, offset, length);
    for (let i = 0; i < view.length; i++) {
        hash = ((hash << 5) - hash) + view[i];
        hash |= 0;
    }
    return hash;
}
