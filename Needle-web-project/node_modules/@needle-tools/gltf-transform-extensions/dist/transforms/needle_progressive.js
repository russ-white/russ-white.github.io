"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resizeTextureToMax = exports.TEXTURE_RESIZE_DEFAULTS = exports.TextureResizeFilter = exports.make_progressive_textures = exports.createTransform = exports.make_progressive = void 0;
const ndarray_1 = __importDefault(require("ndarray"));
const ndarray_lanczos_1 = require("ndarray-lanczos");
const ndarray_pixels_1 = require("ndarray-pixels");
const core_1 = require("@gltf-transform/core");
const functions_1 = require("@gltf-transform/functions");
const NEEDLE_progressive_1 = require("../extensions/NEEDLE_progressive");
const extensions_1 = require("../extensions");
const path_1 = __importDefault(require("path"));
const glob_1 = __importDefault(require("glob"));
const fs_1 = require("fs");
const cache_1 = require("../cache");
function registerExtensions(io) {
    (0, extensions_1.registerExtensions)(io);
    io.registerExtensions([
        NEEDLE_progressive_1.NEEDLE_progressive,
        extensions_1.NEEDLE_progressive_texture_settings,
        //@ts-ignore
        (0, extensions_1.createOpaqueExtension)(extensions_1.NEEDLE_compression_texture.EXTENSION_NAME, core_1.PropertyType.TEXTURE),
        //@ts-ignore
        (0, extensions_1.createOpaqueExtension)(extensions_1.NEEDLE_mesh_compression.EXTENSION_NAME, [core_1.PropertyType.MESH, core_1.PropertyType.PRIMITIVE])
    ]);
}
async function make_progressive(opts) {
    const file = opts.path;
    const tasks = [];
    if (Array.isArray(file)) {
        for (const f of file) {
            const prog = process(f, opts);
            tasks.push(prog);
        }
    }
    else {
        if (path_1.default.extname(file) === "") {
            const files = glob_1.default.sync(file + "/**/*.glb").concat(glob_1.default.sync(file + "/**/*.gltf"));
            for (const f of files) {
                const prog = process(f, opts);
                tasks.push(prog);
            }
        }
        else {
            const prog = process(file, opts);
            tasks.push(prog);
        }
    }
    await Promise.all(tasks);
}
exports.make_progressive = make_progressive;
async function process(file, opts) {
    if (!file.endsWith(".glb") && !file.endsWith(".gltf")) {
        console.log("ERR: file is not gltf/glb");
        return;
    }
    if (!(0, fs_1.existsSync)(file)) {
        console.log("ERR: file does not exist: " + file);
    }
    const io = new core_1.NodeIO();
    registerExtensions(io);
    const document = await io.read(file).catch((err) => {
        console.log("ERR: failed to read file \"" + file + "\", Reason: " + err.message);
        return;
    });
    if (document) {
        //@ts-ignore
        document.getLogger().verbosity = 0;
        await document.transform(make_progressive_textures(file, { size: [256, 256] }));
        let filename = file;
        if (opts.debug === true) {
            // get extension
            const extension = filename.split('.').pop();
            // remove extension
            filename = filename.split('.').slice(0, -1).join('.');
            // add new extension
            filename = filename + ".prog." + extension;
        }
        io.write(filename, document);
    }
}
// basic idea:
// 1. iterate all images that have an extension marking them to be progressively loaded
// 2. for each image, create a new image that is a downsampled version of the original and create a new gltf that contains the high res texture
// 3. add extension to low res image containing info about where to find the high res texture
function createTransform(name, fn) {
    Object.defineProperty(fn, 'name', { value: name });
    return fn;
}
exports.createTransform = createTransform;
const NAME = 'textureResize';
function make_progressive_textures(filePath, _options = exports.TEXTURE_RESIZE_DEFAULTS) {
    console.log("Make progressive: " + filePath);
    const startTime = Date.now();
    const options = { ...exports.TEXTURE_RESIZE_DEFAULTS, ..._options };
    const directory = path_1.default.dirname(filePath);
    // const fileNameWithoutExtension = path.basename(filePath, path.extname(filePath));
    const textureLodBasePath = directory + "/";
    return createTransform(NAME, async (doc) => {
        const logger = doc.getLogger();
        let index = 0;
        for (const texture of doc.getRoot().listTextures()) {
            const textureIndex = index++;
            const name = texture.getName();
            const uri = texture.getURI();
            const match = !options.pattern || options.pattern.test(name) || options.pattern.test(uri);
            if (!match) {
                logger.debug(`${NAME}: Skipping, excluded by "pattern" parameter.`);
                continue;
            }
            if (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {
                logger.warn(`${NAME}: Skipping, unsupported texture type "${texture.getMimeType()}".`);
                continue;
            }
            const slots = (0, functions_1.listTextureSlots)(doc, texture);
            if (options.slots && !slots.some((slot) => options.slots?.test(slot))) {
                logger.debug(`${NAME}: Skipping, [${slots.join(', ')}] excluded by "slots" parameter.`);
                continue;
            }
            const settings = texture.getExtension(extensions_1.NEEDLE_progressive_texture_settings.EXTENSION_NAME);
            if (!settings) {
                logger.warn(`${NAME}: Skipping, no settings found`);
                continue;
            }
            if (!settings.isValid) {
                logger.warn(`${NAME}: Skipping, settings are invalid`);
                continue;
            }
            options.size[0] = settings.maxSize;
            options.size[1] = settings.maxSize;
            const existingExtension = texture.getExtension(NEEDLE_progressive_1.NEEDLE_PROGRESSIVE_TEXTURE_EXTENSION_NAME);
            if (existingExtension !== undefined && existingExtension !== null) {
                logger.debug(`${NAME}: Skipping, texture is already progressive`);
                continue;
            }
            const progressiveExt = doc.createExtension(NEEDLE_progressive_1.NEEDLE_progressive);
            if (!progressiveExt || !progressiveExt.create) {
                logger.debug(`${NAME}: Skipping because progressive extension is not available.`);
                continue;
            }
            const textureGuid = settings.guid?.length ? settings.guid : (0, NEEDLE_progressive_1.generateGuid)();
            const outPath = createTextureLod(textureLodBasePath, 0, texture, slots, textureGuid, textureIndex);
            if (!outPath) {
                continue;
            }
            const relName = path_1.default.relative(directory, outPath);
            // TODO: this path should be added to the NEEDLE dependencies extension
            texture.setExtension(NEEDLE_progressive_1.NEEDLE_PROGRESSIVE_TEXTURE_EXTENSION_NAME, progressiveExt.create({
                uri: relName,
                guid: textureGuid,
                level: 0,
            }));
            const key = (0, cache_1.getKey)(texture);
            const cached = (0, cache_1.tryGetFromCache)(key);
            if (cached) {
                logger.debug(`Progressive image ${index}: using cached preview version (size: ${options.size}))`);
                texture.setImage(cached);
                continue;
            }
            await resizeTexture(options, texture, logger, uri || name, slots);
            (0, cache_1.addToCache)(key, texture.getImage());
        }
        logger.debug(`Progressive transform finished in ${((Date.now() - startTime) / 1000).toFixed(1)} sec.`);
    });
}
exports.make_progressive_textures = make_progressive_textures;
function createTextureLod(basePath, level, texture, slots, guid, textureIndex) {
    // const imageBytes = texture.getImage();
    // if (imageBytes) {
    // 	// write bytes
    // 	const outPath = basePath + guid + "_" + level + ".png";
    // 	writeFileSync(outPath, imageBytes);
    // 	return outPath;
    // }
    const newDoc = new core_1.Document();
    newDoc.createScene();
    newDoc.createBuffer();
    // add texture
    const newTexture = newDoc.createTexture();
    const img = texture.getImage();
    newTexture.setImage(img);
    newTexture.setURI(texture.getURI());
    newTexture.setMimeType(texture.getMimeType());
    // create material adding the texture to the same slot
    for (const slot of slots) {
        const newMaterial = newDoc.createMaterial();
        switch (slot) {
            case "baseColorTexture":
                newMaterial.setBaseColorTexture(newTexture);
                break;
            case "metallicRoughnessTexture":
                newMaterial.setMetallicRoughnessTexture(newTexture);
                break;
            case "normalTexture":
                newMaterial.setNormalTexture(newTexture);
                break;
            case "occlusionTexture":
                newMaterial.setOcclusionTexture(newTexture);
                break;
            case "emissiveTexture":
                newMaterial.setEmissiveTexture(newTexture);
                break;
            default:
                console.warn("WARN: Unknown texture slot: " + slot + " for texture " + textureIndex + " → can not load progressively");
                return null;
        }
    }
    const compressionSettings = texture.getExtension(extensions_1.NEEDLE_compression_texture.EXTENSION_NAME);
    if (compressionSettings !== undefined && compressionSettings !== null && compressionSettings.getExtensionDefinition) {
        console.log("> Pass compression extension to new texture");
        const newExt = newDoc.createExtension(extensions_1.NEEDLE_compression_texture);
        const def = compressionSettings.getExtensionDefinition();
        const newProp = newExt.create(def);
        newTexture.setExtension(extensions_1.NEEDLE_compression_texture.EXTENSION_NAME, newProp);
    }
    // add progressive texture extension
    const progressiveExt = newDoc.createExtension(NEEDLE_progressive_1.NEEDLE_progressive);
    newTexture.setExtension(NEEDLE_progressive_1.NEEDLE_PROGRESSIVE_TEXTURE_EXTENSION_NAME, progressiveExt.create({
        guid: guid,
    }));
    const newIo = new core_1.NodeIO();
    registerExtensions(newIo);
    const ext = ".glb";
    const imageName = "image_" + level + "_" + guid;
    const outName = basePath + imageName + ext;
    newIo.write(outName, newDoc);
    return outName;
}
/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */
var TextureResizeFilter;
(function (TextureResizeFilter) {
    /** Lanczos3 (sharp) */
    TextureResizeFilter["LANCZOS3"] = "lanczos3";
    /** Lanczos2 (smooth) */
    TextureResizeFilter["LANCZOS2"] = "lanczos2";
})(TextureResizeFilter = exports.TextureResizeFilter || (exports.TextureResizeFilter = {}));
exports.TEXTURE_RESIZE_DEFAULTS = {
    size: [2048, 2048],
    filter: TextureResizeFilter.LANCZOS3,
    pattern: null,
    slots: null,
};
async function resizeTextureToMax(texture, maxSize, logger) {
    const options = { ...exports.TEXTURE_RESIZE_DEFAULTS };
    options.size = [maxSize, maxSize];
    await resizeTexture(options, texture, logger);
}
exports.resizeTextureToMax = resizeTextureToMax;
async function resizeTexture(options, texture, logger, uri, slots) {
    const [maxWidth, maxHeight] = options.size;
    const [srcWidth, srcHeight] = texture.getSize();
    if (srcWidth <= maxWidth && srcHeight <= maxHeight) {
        logger.debug(`${NAME}: Skipping, not within size range.`);
        return;
    }
    if (maxWidth <= 0 || maxHeight <= 0) {
        logger.debug(`${uri}: Skipping, invalid size range: ${maxWidth}x${maxHeight}`);
        return;
    }
    let dstWidth = srcWidth;
    let dstHeight = srcHeight;
    if (dstWidth > maxWidth) {
        dstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));
        dstWidth = maxWidth;
    }
    if (dstHeight > maxHeight) {
        dstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));
        dstHeight = maxHeight;
    }
    const srcImage = texture.getImage();
    const srcPixels = await (0, ndarray_pixels_1.getPixels)(srcImage, texture.getMimeType());
    const dstPixels = (0, ndarray_1.default)(new Uint8Array(dstWidth * dstHeight * 4), [dstWidth, dstHeight, 4]);
    logger.debug(`${NAME}: Resizing "${uri ?? texture.getName()}", ${srcPixels.shape} → ${dstPixels.shape}...`);
    if (slots)
        logger.debug(`${NAME}: Slots → [${slots.join(', ')}]`);
    try {
        options.filter === TextureResizeFilter.LANCZOS3
            ? (0, ndarray_lanczos_1.lanczos3)(srcPixels, dstPixels)
            : (0, ndarray_lanczos_1.lanczos2)(srcPixels, dstPixels);
    }
    catch (e) {
        if (e instanceof Error) {
            logger.warn(`${NAME}: Failed to resize "${uri}": "${e.message}".`);
            return;
        }
        throw e;
    }
    const image = await (0, ndarray_pixels_1.savePixels)(dstPixels, texture.getMimeType());
    texture.setImage(image);
}
