"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkKTXSoftware = exports.createParams = exports.UASTC_DEFAULTS = exports.ETC1S_DEFAULTS = exports.Filter = exports.Mode = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require('fs/promises');
const micromatch = require('micromatch');
const os = require('os');
const semver = require('semver');
const tmp = require('tmp');
const pLimit = require('p-limit');
const core_1 = require("@gltf-transform/core");
// import { TextureBasisu } from '@gltf-transform/extensions';
// import { getTextureChannelMask, listTextureSlots } from '@gltf-transform/functions';
const child_process_1 = require("child_process");
const util_1 = require("./util");
// import { existsSync, mkdirSync } from 'fs';
// import { tryGetFromCache, getKey, addToCache } from '../cache';
// import { resizeTextureIfNecessary } from "./needle_texture_transform"
tmp.setGracefulCleanup();
const NUM_CPUS = os.cpus().length || 1; // microsoft/vscode#112122
const KTX_SOFTWARE_VERSION_MIN = '4.0.0-rc1';
const KTX_SOFTWARE_VERSION_ACTIVE = '4.1.0-rc1';
const { R, G } = core_1.TextureChannel;
/**********************************************************************************************
 * Interfaces.
 */
exports.Mode = {
    ETC1S: 'etc1s',
    UASTC: 'uastc',
};
exports.Filter = {
    BOX: 'box',
    TENT: 'tent',
    BELL: 'bell',
    BSPLINE: 'b-spline',
    MITCHELL: 'mitchell',
    LANCZOS3: 'lanczos3',
    LANCZOS4: 'lanczos4',
    LANCZOS6: 'lanczos6',
    LANCZOS12: 'lanczos12',
    BLACKMAN: 'blackman',
    KAISER: 'kaiser',
    GAUSSIAN: 'gaussian',
    CATMULLROM: 'catmullrom',
    QUADRATIC_INTERP: 'quadratic_interp',
    QUADRATIC_APPROX: 'quadratic_approx',
    QUADRATIC_MIX: 'quadratic_mix',
};
const GLOBAL_DEFAULTS = {
    filter: exports.Filter.LANCZOS4,
    filterScale: 1,
    powerOfTwo: false,
    slots: '*',
    // See: https://github.com/donmccurdy/glTF-Transform/pull/389#issuecomment-1089842185
    jobs: 2 * NUM_CPUS,
};
exports.ETC1S_DEFAULTS = {
    quality: 128,
    compression: 1,
    ...GLOBAL_DEFAULTS,
};
exports.UASTC_DEFAULTS = {
    level: 2,
    rdo: 0,
    rdoDictionarySize: 32768,
    rdoBlockScale: 10.0,
    rdoStdDev: 18.0,
    rdoMultithreading: true,
    zstd: 18,
    ...GLOBAL_DEFAULTS,
};
/**********************************************************************************************
 * Utilities.
 */
/** Create CLI parameters from the given options. Attempts to write only non-default options. */
function createParams(slots, channels, size, logger, numTextures, options, version) {
    const params = [];
    params.push('--genmipmap');
    if (options.filter !== GLOBAL_DEFAULTS.filter)
        params.push('--filter', options.filter);
    if (options.filterScale !== GLOBAL_DEFAULTS.filterScale) {
        params.push('--fscale', options.filterScale);
    }
    if (options.mode === exports.Mode.UASTC) {
        const _options = options;
        params.push('--uastc', _options.level);
        if (_options.rdo !== exports.UASTC_DEFAULTS.rdo) {
            params.push('--uastc_rdo_l', _options.rdo);
        }
        if (_options.rdoDictionarySize !== exports.UASTC_DEFAULTS.rdoDictionarySize) {
            params.push('--uastc_rdo_d', _options.rdoDictionarySize);
        }
        if (_options.rdoBlockScale !== exports.UASTC_DEFAULTS.rdoBlockScale) {
            params.push('--uastc_rdo_b', _options.rdoBlockScale);
        }
        if (_options.rdoStdDev !== exports.UASTC_DEFAULTS.rdoStdDev) {
            params.push('--uastc_rdo_s', _options.rdoStdDev);
        }
        if (!_options.rdoMultithreading) {
            params.push('--uastc_rdo_m');
        }
        if (_options.zstd && _options.zstd > 0)
            params.push('--zcmp', _options.zstd);
    }
    else {
        const _options = options;
        params.push('--bcmp');
        if (_options.quality !== exports.ETC1S_DEFAULTS.quality) {
            params.push('--qlevel', _options.quality);
        }
        if (_options.compression !== exports.ETC1S_DEFAULTS.compression) {
            params.push('--clevel', _options.compression);
        }
        if (_options.maxEndpoints)
            params.push('--max_endpoints', _options.maxEndpoints);
        if (_options.maxSelectors)
            params.push('--max_selectors', _options.maxSelectors);
        if (_options.rdoOff) {
            params.push('--no_endpoint_rdo', '--no_selector_rdo');
        }
        else if (_options.rdoThreshold) {
            params.push('--endpoint_rdo_threshold', _options.rdoThreshold);
            params.push('--selector_rdo_threshold', _options.rdoThreshold);
        }
    }
    if (slots.find((slot) => micromatch.isMatch(slot, '*normal*', util_1.MICROMATCH_OPTIONS))) {
        // See: https://github.com/KhronosGroup/KTX-Software/issues/600
        if (semver.gte(version, KTX_SOFTWARE_VERSION_ACTIVE)) {
            params.push('--normal_mode', '--input_swizzle', 'rgb1');
        }
        else if (options.mode === exports.Mode.ETC1S) {
            params.push('--normal_map');
        }
    }
    if (slots.length && !slots.find((slot) => micromatch.isMatch(slot, '*{color,emissive}*', util_1.MICROMATCH_OPTIONS))) {
        // See: https://github.com/donmccurdy/glTF-Transform/issues/215
        params.push('--assign_oetf', 'linear', '--assign_primaries', 'none');
    }
    if (channels === R) {
        params.push('--target_type', 'R');
    }
    else if (channels === G || channels === (R | G)) {
        params.push('--target_type', 'RG');
    }
    // Minimum size on any dimension is 4px.
    // See: https://github.com/donmccurdy/glTF-Transform/issues/502
    let width;
    let height;
    if (options.powerOfTwo) {
        width = preferredPowerOfTwo(size[0]);
        height = preferredPowerOfTwo(size[1]);
    }
    else {
        if (!isPowerOfTwo(size[0]) || !isPowerOfTwo(size[1])) {
            logger.warn(`toktx: Texture dimensions ${size[0]}x${size[1]} are NPOT, and may` +
                ' fail in older APIs (including WebGL 1.0) on certain devices.');
        }
        width = isMultipleOfFour(size[0]) ? size[0] : ceilMultipleOfFour(size[0]);
        height = isMultipleOfFour(size[1]) ? size[1] : ceilMultipleOfFour(size[1]);
    }
    if (width !== size[0] || height !== size[1]) {
        if (width > 4096 || height > 4096) {
            logger.warn(`toktx: Resizing to nearest power of two, ${width}x${height}px. Texture dimensions` +
                ' greater than 4096px may not render on some mobile devices.' +
                ' Resize to a lower resolution before compressing, if needed.');
        }
        params.push('--resize', `${width}x${height}`);
    }
    if (options.jobs && options.jobs > 1 && numTextures > 1) {
        // See: https://github.com/donmccurdy/glTF-Transform/pull/389#issuecomment-1089842185
        const threads = Math.max(2, Math.min(NUM_CPUS, (3 * NUM_CPUS) / numTextures));
        params.push('--threads', threads);
    }
    return params;
}
exports.createParams = createParams;
async function checkKTXSoftware(logger, env) {
    if (!process.env.CI) {
        const toktxCommandExists = await toktxCommandExistsSync(env);
        if (!toktxCommandExists) {
            throw new Error('Command "toktx" not found. Please install KTX-Software, from:\n\nhttps://github.com/KhronosGroup/KTX-Software');
        }
    }
    const [status, stdout, stderr] = await (0, util_1.waitExit)((0, util_1.spawn)('toktx', ['--version'], { env: env }));
    const version = (stdout || stderr)
        .replace(/toktx\s+/, '')
        .replace(/~\d+/, '')
        .trim();
    if (status !== 0 || !semver.valid(semver.clean(version))) {
        throw new Error('Unable to find "toktx" version. Confirm KTX-Software is installed.');
    }
    else if (semver.lt(semver.clean(version), KTX_SOFTWARE_VERSION_MIN)) {
        logger.warn(`toktx: Expected KTX-Software >= v${KTX_SOFTWARE_VERSION_MIN}, found ${version}.`);
    }
    else {
        logger.debug(`toktx: Found KTX-Software ${version}.`);
    }
    return semver.clean(version);
}
exports.checkKTXSoftware = checkKTXSoftware;
async function toktxCommandExistsSync(env) {
    if (env) {
        // if env is defined use that to check if toktx is installed
        try {
            (0, child_process_1.execSync)('toktx --version', { encoding: 'utf-8', env: env });
            return true;
        }
        catch (error) {
            return false;
        }
    }
    else if (!await (0, util_1.commandExists)('toktx')) {
        return false;
    }
    return true;
}
function isPowerOfTwo(value) {
    if (value <= 2)
        return true;
    return (value & (value - 1)) === 0 && value !== 0;
}
function preferredPowerOfTwo(value) {
    if (value <= 4)
        return 4;
    const lo = floorPowerOfTwo(value);
    const hi = ceilPowerOfTwo(value);
    if (hi - value > value - lo)
        return lo;
    return hi;
}
function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function isMultipleOfFour(value) {
    return value % 4 === 0;
}
function ceilMultipleOfFour(value) {
    if (value <= 4)
        return 4;
    return value % 4 ? value + 4 - (value % 4) : value;
}
